\chapter{Аналитическая часть}
В данном разделе будут рассмотрены теоретические основы алгоритмов умножения матриц: стандартного, Винограда и Винограда с оптимизациями. Все алгоритмы рассматриваются для матриц, включающих в себя только целочисленные элементы.

Для программной реализации матрицу можно рассматривать как двумерный массив, или массив, содержащий элементы типа массив элементов заданного типа.

Соответственно, две матрицы можно перемножить тогда и только тогда, когда количество столбцов (количество элементов в массивах, хранящихся в массиве массивов) первой матрицы-множителя совпадает с количеством строк (количеством массивов в массиве массивов) второй матрицы-множителя. У результирующей матрицы количество строк будет совпадать с количеством строк в первой матрице, а количество столбцов с количеством столбцов во второй матрице.

\section{Стандартный алгоритм умножения матриц}
Стандартный алгоритм умножения матриц можно описать следующими соображениями.

Если существуют две матрицы, $A$ и $B$ (\ref{eqn:AB}), для которых количество строк и столбцов обозначить как $m_A$,$n_A$ и $m_B$,$n_B$ соответственно, и при этом $n_A=m_B$, то результатом их умножения (\ref{eqn:ABmul}) будет матрица $C$ (\ref{eqn:С}). Для матрицы $C$ количество строк $m_C = m_A$, а количество столбцов $n_C=n_B$.

Данные соображения представимы формулами
\begin{equation} \label{eqn:AB}
	A = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n_A}\\
		a_{21} & a_{22} & \ldots & a_{2n_A}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m_A1} & a_{m_A2} & \ldots & a_{m_An_A}
	\end{pmatrix},
	\quad
	B = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n_B}\\
		b_{21} & b_{22} & \ldots & b_{2n_B}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m_B1} & b_{m_B2} & \ldots & b_{m_Bn_B}
	\end{pmatrix},
\end{equation}

\begin{equation} \label{eqn:ABmul}
	A \cdot B = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n_A}\\
		a_{21} & a_{22} & \ldots & a_{2n_A}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m_A1} & a_{m_A2} & \ldots & a_{m_An_A}
	\end{pmatrix} \cdot \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n_B}\\
		b_{21} & b_{22} & \ldots & b_{2n_B}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m_B1} & b_{m_B2} & \ldots & b_{m_Bn_B}
	\end{pmatrix} = C,
\end{equation}
где
\begin{equation} \label{eqn:С}
	C = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n_C}\\
		c_{21} & c_{22} & \ldots & c_{2n_C}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{m_C1} & c_{m_C2} & \ldots & c_{m_Cn_C}
	\end{pmatrix}.
\end{equation}

Для каждого элемента $c_{ij}$ матрицы $C$, где $i = \overline{1,m_C}$,$j = \overline{1,n_C}$:
\begin{equation}
	\label{eq:Celem}
	c_{ij} = \sum_{k=1}^{m_B} a_{ik}b_{kj}.
\end{equation}

\section{Алгоритм Винограда для умножения матриц}
Одним из самых эффективных по времени алгоритмов умножения матриц является алгоритм Винограда, имеющий асимптотическую сложность $O(n^{3.755})$ \cite{web_item6}. Описать основные этапы алгоритма можно при помощи следующих утверждений.

Пусть дан вектор $A = (a_1,a_2,a_3,a_4)$ и дан вектор $B = (b_1,b_2,b_3,b_4)$, где $a_i, b_i$ для $i = \overline{1,4}$~---~некоторые целые числа, например. Произведение этих векторов можно записать в виде:
\begin{equation} \label{eqn:ABvec}
	A \cdot B = a_1 \cdot b_1 + a_2 \cdot b_2 + a_3 \cdot b_3 + a_4 \cdot b_4.
\end{equation}

Формулу (\ref{eqn:ABvec}) можно также представить в следующем виде:
\begin{equation} \label{eqn:ABvec2}
	A \cdot B = (a_1 + b_2)(a_2 + b_1) + (a_3 + b_4)(a_4 + b_3) - a_1 \cdot a_2 - a_3 \cdot a_4 - b_1 \cdot b_2 - b_3 \cdot b_4.
\end{equation}

В (\ref{eqn:ABvec2}) количество умножений (6 операций) и сложений (9 операций) превышает число аналогичных операций в (\ref{eqn:ABvec}), где 4 умножения и 3 сложения, но вычисление результата по (\ref{eqn:ABvec2}) допускает предварительную обработку.

Наибольшей эффективности по времени можно достичь, исключая наиболее трудоёмкие для ЭВМ операции, в данном случае~---~умножение, поэтому коэффициенты $a_1 \cdot a_2$, $a_3 \cdot a_4$, $b_1 \cdot b_2$, $b_3 \cdot b_4$ из (\ref{eqn:ABvec2}) можно вычислять заранее, перед основным циклом, и использовать повторно для вычисления соответствующих значений.

Таким образом, количество операций в формуле на каждой итерации основного цикла сокращается до 2 для умножения и до 5 для сложения, без учёта двух дополнительных сложений с произведениями соседних элементов соответствующих строк и столбцов.

Для случая, когда совпадающая размерность для изначальных матриц~---~нечётная, требуется на каждой итерации производить дополнительное сложение с произведением последних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда для умножения матриц} \label{better}
Для алгоритма Винограда существует множество модификаций, позволивших увеличить его эффективность, например:
\begin{itemize}
	\item в 2010 Эндрю Стотерс усовершенствовал алгоритм до $O(n^{2.374})$ \cite{web_item7};
	\item в 2011 году Вирджиния Вильямс (англ.) усовершенствовала алгоритм до $O(n^{2.3728642})$ \cite{web_item8};
	\item 5 октября 2022 компанией $DeepMind$ при помощи нейросетевого алгоритма $AlphaZero$ были найдены несколько новых алгоритмов перемножения матриц различных размерностей: при размере $9\times9$ число операций уменьшилось с 511 до 498, а при $11\times11$ — с 919 до 896, а в ряде других случаев $AlphaTensor$ повторил лучшие из известных алгоритмов \cite{web_item9}.
\end{itemize}

В данной лабораторной работе были реализованы следующие улучшения:
\begin{itemize}
	\item операция $x = x + k$, где $x,k$~---~некоторые числа, была заменена на $x\ += k$;
	\item умножение на 2 было заменено на побитовый сдвиг операнда влево на 1 бит;
	\item вычисления горизонтального индекса предпоследнего элемента строки матрицы и элемента в середине строки, булевого значения кратности длины строки матрицы двум были вынесены из основного цикла;
	\item цикл, вход в который осуществляется программой в случае нечётности размерности исходной матрицы, был внесён внутрь основного, для чего введена булевая переменная-флаг.
\end{itemize}

\newpage
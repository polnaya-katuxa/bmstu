\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение} 
Для каждого алгоритма были выявлены лучший и худший случаи (данные, при которых алгоритмы работают быстрее всего и медленнее всего, соответственно). 

Для блинной сортировки худшим случаем является массив с чередованием больших и маленьких значений элементов, так как на таких данных приходится делать более трудоёмкие перевороты. Лучший случай для этого алгоритма~---~уже отсортированный по возрастанию массив, в этом случае нет необходимости осуществлять перевороты.

Для быстрой сортировки худшим случаем является массив заполненный, например, одинаковыми значениями, так как на таких данных размеры частей, на которые алгоритм делит исходный массив, будут неравномерны, и трудоёмкость резко возрастёт. Лучший случай для этого алгоритма~---~уже отсортированный по возрастанию массив, в этом случае размеры частей, на которые алгоритм делит исходный массив, будут более равномерны, а глубина рекурсии~---~меньше.

Для сортировки бусинами худшим случаем является массив заполненный большими значениями, так как на таких данных размер выделяемой матрицы (в частности, количество столбцов) увеличивается. Соответственно лучший случай для этого алгоритма~---~массив заполненный небольшими значениями. Изменение порядка элементов в исходном массиве влияет на время выполнения незначительно.

В результате проведения замеров с учётом разных случаев были сформулированы нижеперечисленные выводы.

В произвольных случаях (когда массив заполнялся случайными числами) до размера массива в 100 элементов блинная сортировка работает быстрее всего, примерно в 1.25 раз опережая быструю сортировку. Медленнее всего работает сортировка бусинами, уступая блинной почти в 5 раз. Начиная с размера массива в 200 элементов быстрее остальных начинает работать быстрая сортировка. На 600 элементах она быстрее блинной в 5 раз, а сортировки бусинами в 38 раз.

В лучших случаях на размерах массивов начиная со 100 сортировка бусинами работает быстрее остальных. На 300 элементах она работает меньше блинной в 5 раз и меньше быстрой в 3 раза. На небольших длинах массивов (до 50) остальные сортировки уступают блинной, но уже на 600 элементах быстрая сортировка работает быстрее блинной в 3 раза.

В худших случаях алгоритм сортировки бусинами работает дольше остальных алгоритмов на любых длинах строк. Также на всех рассматриваемых длинах в худших случаях быстрее остальных работает блинная сортировка. На длине массива в 500 символов она быстрее быстрой в 2 раза и гравитационной в 15 раз.

Если говорить об объёме занимаемой памяти, то алгоритм сортировки бусинами практически на всех длинах массива (начиная от 500-100) потребляет сильно больше памяти, чем остальные. Это объясняется необходимостью хранить матрицу значений. Уже на длине в 100 элементов этот алгоритм потребляет в 507 раз больше памяти, чем блинная сортировка, и в 13 раз, чем сортировка бусинами. Меньше всех памяти (одинаковый объём при любых длинах, так как это независимый параметр) потребляет блинная сортировка, так как не хранит большие массивы данных, как гравитационная, и не потребляет память за счёт выделения собственной области стека под рекурсивные вызовы, в отличие от быстрой сортировки.

В ходе выполнения лабораторной работы была достигнута поставленная цель: были получены навыки программирования, тестирования полученного программного продукта и проведения замеров времени выполнения и потребляемой памяти по результатам работы программы на примере реализации алгоритмов сортировки.

В процессе выполнения лабораторной работы были также реализованы все поставленные задачи, а именно:
\begin{itemize}
	\item были изучены алгоритмы блинной, быстрой и бусинной сортировки;
	\item были разработаны схемы данных алгоритмов и проведён анализ их трудоёмкости;
	\item была выполнена программная реализация данных алгоритмов;
	\item были проведены замеры потребления памяти (в байтах) и времени работы (в нс) для данных алгоритмов;
	\item была получена графическая зависимость измеренных величин от длины последовательности символов, предоставляемой на вход алгоритмам;
	\item был проведен сравнительный анализ данных алгоритмов на основе полученных зависимостей.
\end{itemize}

\newpage
\chapter{Аналитическая часть}
В данном разделе будут рассмотрены теоретические основы алгоритмов поиска редакционного расстояния и общие сведения по этой задаче.

За редакционное расстояние принимают минимальное количество операций над строкой, с помощью которых она может быть преобразована в другую. Поэтому для каждой операции над строкой вводится условная цена. Суммарная стоимость всех произведённых операций и будет являться редакционным расстоянием между данными строками.

Цены за редакционные операции можно обозначить  и определить следующим образом:
\begin{itemize}
	\item $\omega(\alpha,\beta)~=~1$~---~цена замены при $\alpha \neq \beta$;
	\item $\omega(\alpha,\alpha)~=~0$~---~цена эквивалентной замены;
	\item $\omega(\varnothing,\beta)~=~1$~---~цена вставки;
	\item $\omega(\alpha,\varnothing)~=~1$~---~цена удаления.
\end{itemize}

Для описания алгоритма вычисления расстояния Левенштейна поиска редакционного расстояния применяется рекуррентное (т.е. использующее результаты предшествующих вычислений на следующем шаге) соотношение

\begin{equation}
\label{eqn:lev_formula}
	D(s_1[1..i], s_2[1..j]) = \begin{cases}
      	0,& \text{если}\ i = 0, j = 0, \\ 
        i,& \text{если}\ i > 0, j = 0, \\ 
        j,& \text{если}\ i = 0, j > 0, \\
     
      \min ( & D(s_1[1..i], s_2[1..j - 1]) + 1, \\
      & D(s_1[1..i - 1], s_2[1..j]) + 1, \\
      & D(s_1[1..i - 1], s_2[1..j - 1]) + \begin{cases}
      0, & \text{если}\ s_1[i] = s_2[j], \\
      1, & \text{иначе}. \\
      \end{cases} \\
      ).
      \end{cases}
\end{equation}

\newpage

Для алгоритма вычисления расстояния Дамерау~--~Левенштейна (\ref{eqn:lev_formula}) примет вид

\begin{equation}
\label{eqn:dam_lev_formula}
	D(s_1[1..i], s_2[1..j]) = \begin{cases}
      	0,& \text{если}\ i = 0, j = 0, \\ 
        i,& \text{если}\ i > 0, j = 0, \\ 
        j,& \text{если}\ i = 0, j > 0, \\
     
      \min ( & D(s_1[1..i], s_2[1..j - 1]) + 1, \\
      & D(s_1[1..i - 1], s_2[1..j]) + 1, \\
      & D(s_1[1..i - 1], s_2[1..j - 1]) + m, \\
      & D(s_1[1..i - 2], s_2[1..j - 2]) + n,\qquad \text{если}\ i > 1, j > 1 \\
      ).
      \end{cases} \\
\end{equation}

При этом \begin{equation}
	m = \begin{cases}
      0, & \text{если}\ s_1[i] = s_2[j], \\
      1, & \text{иначе}, \\
      \end{cases} \\
\end{equation}
\begin{equation}
	n = \begin{cases}
      0, & \text{если}\ s_1[i] = s_2[j], s_1[i - 1] = s_2[j - 1], \\
      1, & \text{если}\ s_1[i] = s_2[j - 1], s_1[i - 1] = s_2[j]. \\
      \end{cases} \\
\end{equation} \\

Из этого следует, что для реализации алгоритмов могут быть использованы два подхода: матричный и рекурсивный.

Под рекурсивным подходом понимается реализация, при которой значения предыдущих членов, необходимых для вычисления редакционного расстояния, высчитываются на каждом вызове. 

Под матричным подходом понимается реализация, при которой значения предыдущих членов хранятся в матрице. 

\section{Матричный алгоритм нахождения расстояния Левенштейна}
\label{section:lev_matr}
Если реализовывать вычисления по формуле \ref{eqn:lev_formula} рекурсивно напрямую, то при больших размерах строк эффективность работы программы будет ниже. Это связано с тем, что в определённых местах вычисления, которые уже производились на предыдущих шагах, будут производиться повторно.

Матричный алгоритм подразумевает, что в памяти хранится вся матрица результатов ($M$), что позволит при совпадении начальных значений для вычислений на текущем шаге не выполнять их заново, а найти готовый результат в соответствующей ячейке матрицы. В матрице текущему значению $D(s_1[1..i], s_2[1..j])$ будет соответствовать ячейка $M[i][j]$.

\section{Матричный алгоритм нахождения расстояния \\Дамерау~--~Левенштейна}
\label{section:dam_lev_matr}
Рассуждения аналогичны пункту~\ref{section:lev_matr}, но используется (\ref{eqn:dam_lev_formula}). Это связано с тем, что в данном алгоритме предусмотрена ещё одна редакционная операция~---~транспозиция двух соседних символов.

\section{Рекурсивный алгоритм нахождения расстояния \\Дамерау~--~Левенштейна}
Рекурсивный алгоритм поиска редакционного расстояния Дамерау~--~Левенштейна реализует (\ref{eqn:dam_lev_formula}). 

Пусть $s_1^{'}$~---~строка $s_1$ без последнего символа, а $s_2^{'}$~---~строка $s_2$ без последнего символа. Цену преобразования из строки $s_1$ в строку $s_2$ обозначим как $\omega(s_1, s_2)$.

За известные принимаются и используются для составления формулы следующие утверждения: \begin{itemize}
	\item цена преобразования между двумя пустыми строками равняется 0;
	\item цена преобразования между непустой строкой и пустой строкой равняется длине непустой строки (вне зависимости от порядка операндов);
	\item цена преобразования строки $s_1$ в строку $s_2$ может быть выражена как $\omega(s_1, s_2^{'})$ + $\omega(s_2^{'}, s_2)$, где второе слагаемое равняется $\omega(\varnothing,\beta)~=~1$~---~цена вставки, где $\beta$~---~любой символ;
	\item цена преобразования строки $s_1$ в строку $s_2$ может быть выражена как $\omega(s_1^{'}, s_2)$ + $\omega(s_1, s_1^{'})$, где второе слагаемое равняется $\omega(\alpha,\varnothing)~=~1$~---~цена удаления, где $\alpha$~---~любой символ;
	\item цена преобразования строки $s_1$ в строку $s_2$ может быть выражена как $\omega(s_1^{'}, s_2^{'})$ + $\omega(\alpha, \beta)$, где $\alpha, \beta$~---~последние символы строк $s_1$, $s_2$ соответственно, а второе слагаемое равняется 1 при $\alpha \neq \beta$ и равняется 0 иначе;
	\item цена преобразования строки $s_1$ в строку $s_2$, если их длина превышает 2, может быть выражена как $\omega((s_1^{'})^{'}, (s_2^{'})^{'})$ + $\omega(\alpha\beta, \delta\gamma)$, где комбинации ($\alpha\beta$), $(\delta\gamma)$~---~последние два символа строк $s_1$, $s_2$ соответственно, а второе слагаемое равняется 1 при $\alpha = \gamma$ и $\beta = \delta$ и равняется 0 при $\alpha = \delta$ и $\beta = \gamma$.
\end{itemize}

За редакционное расстояние на текущем шаге принимается минимальное из перечисленных значений.

Такой подход является невыгодным с точки зрения потребляемой памяти при рекурсивных вызовах и из-за роста числа повторных вычислений.

\section{Рекурсивный алгоритм нахождения расстояния \\ Дамерау~--~Левенштейна с кэшированием}
\label{section:dam_lev_cache}

Рекурсивную реализацию алгоритма нахождения редакционного расстояния можно оптимизировать по времени выполнения с использованием кэша вычисленных значений в виде матрицы, заполняемой по правилам из матричной реализации в пункте \ref{section:dam_lev_matr}

Перед началом выполнения алгоритма все значения матрицы заполняются $\infty$. Элемент матрицы будет рассматриваться как ранее вычисленный, если в нём будет находиться значение, отличное от $\infty$, и не вычисленным ранее, иначе.

Таким образом, при вызове рекурсии вычисленные ранее значения не будут пересчитываться, а будут взяты из кэша, что значительно сократит время работы алгоритма. 

\newpage
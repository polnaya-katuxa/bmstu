/*
 * API for ppo project
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"
	"sort"
	"time"

	mycontext "git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/context"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/google/uuid"
)

// PostApiService is a service that implements the logic for the PostApiServicer
// This service should implement the business logic for every endpoint for the PostApi API.
// Include any external packages or services that will be required by this service.
type PostApiService struct {
	postLogic    interfaces.IPostLogic
	feedLogic    interfaces.IFeedLogic
	profileLogic interfaces.IProfileLogic
	subLogic     interfaces.ISubscriptionLogic
}

// NewPostApiService creates a default api service
func NewPostApiService(postLogic interfaces.IPostLogic, feedLogic interfaces.IFeedLogic,
	profileLogic interfaces.IProfileLogic, subLogic interfaces.ISubscriptionLogic,
) PostApiServicer {
	return &PostApiService{postLogic: postLogic, feedLogic: feedLogic, profileLogic: profileLogic, subLogic: subLogic}
}

func makePost(p *models.Post, types []*models.ReactionType, u *models.User) Post {
	r := make(map[string]Reaction, len(types))
	for _, t := range types {
		r[t.UUID.String()] = Reaction{
			Icon:   t.Icon,
			TypeID: t.UUID.String(),
		}
	}

	for _, re := range p.Reactions {
		r[re.TypeID.String()] = Reaction{
			Icon:   re.Icon,
			Num:    r[re.TypeID.String()].Num + 1,
			TypeID: re.TypeID.String(),
			Yours:  r[re.TypeID.String()].Yours || (re.ReactorID == u.UUID),
		}
	}

	reacts := make([]Reaction, 0, len(r))
	for _, v := range r {
		reacts = append(reacts, v)
	}

	sort.Slice(reacts, func(i, j int) bool {
		return reacts[i].Num > reacts[j].Num
	})

	return Post{
		Id:      p.UUID.String(),
		Content: p.Content,
		PubTime: p.PublicTime.Format(time.RFC3339),
		Author: User{
			Id:          p.Author.UUID.String(),
			Login:       p.Author.Login,
			Picture:     p.Author.Picture,
			Description: p.Author.Description,
			Balance:     int32(p.Author.Balance),
			Mail:        p.Author.Mail,
			IsAdmin:     p.Author.IsAdmin,
		},
		CommentsNum: int32(p.CommentNum),
		Reactions:   reacts,
		Perms:       p.Perms == models.Paid,
	}
}

// ChangePostPerms - change perms for post by id
func (s *PostApiService) ChangePostPerms(ctx context.Context, id string) (ImplResponse, error) {
	postID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	err = s.postLogic.ChangePerms(ctx, postID)
	if err != nil {
		return toErrorResponse(err, "Cannot change perms.")
	}

	post, err := s.postLogic.Get(ctx, postID)
	if err != nil {
		return toErrorResponse(err, "Cannot get post.")
	}

	p := ""
	if post.Perms == models.Free {
		p = "free"
	} else {
		p = "paid"
	}

	return Response(http.StatusOK, ChangePermsResponse{Changed: p}), nil
}

// DeletePost - delete post by id
func (s *PostApiService) DeletePost(ctx context.Context, id string) (ImplResponse, error) {
	postID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	err = s.postLogic.Delete(ctx, postID)
	if err != nil {
		return toErrorResponse(err, "Cannot delete post.")
	}

	return Response(http.StatusOK, DeletePostResponse{Deleted: true}), nil
}

// GetPost - get post by id
func (s *PostApiService) GetPost(ctx context.Context, id string) (ImplResponse, error) {
	postID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	post, err := s.postLogic.Get(ctx, postID)
	if err != nil {
		return toErrorResponse(err, "Cannot get post.")
	}

	user, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	types, err := s.postLogic.GetReactionTypes(ctx)
	if err != nil {
		return toErrorResponse(err, "Cannot react to posts.")
	}

	postOA := makePost(post, types, user)

	return Response(http.StatusOK, GetPostResponse{Post: postOA}), nil
}

// GetPosts - get posts (feed or profile)
func (s *PostApiService) GetPosts(ctx context.Context, user string, feedFor string, page int32, num int32) (ImplResponse, error) {
	if (user != "" && feedFor != "") || (user == "" && feedFor == "") {
		return toErrorResponse(ErrParams, "Cannot view feed.")
	}

	if page < 0 || num < 0 || (page == 0 && num > 0) || (page > 0 && num == 0) {
		return toErrorResponse(ErrParams, "Cannot view feed.")
	}

	var pg *models.Paginator

	if page > 0 && num > 0 {
		pg = &models.Paginator{
			Page: int(page),
			Num:  int(num),
		}
	}

	cur, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	if feedFor != "" {
		posts, err := s.feedLogic.View(ctx, pg)
		if err != nil {
			return toErrorResponse(err, "Cannot view feed.")
		}

		postsOA := make([]Post, len(posts))

		types, err := s.postLogic.GetReactionTypes(ctx)
		if err != nil {
			return toErrorResponse(err, "Cannot react to posts.")
		}

		for i, p := range posts {
			postsOA[i] = makePost(p, types, cur)
		}

		n, err := s.feedLogic.GetTotalByIDAndSpan(ctx)
		if err != nil {
			return toErrorResponse(err, "Cannot get total number of posts by id and span.")
		}

		return Response(http.StatusOK, GetPostsResponse{Posts: postsOA, Total: int32(n)}), nil
	} else {
		u, err := s.profileLogic.Get(ctx, user)
		if err != nil {
			return toErrorResponse(err, "Cannot view profile.")
		}

		posts, err := s.postLogic.GetAll(ctx, u.UUID, pg)

		types, err := s.postLogic.GetReactionTypes(ctx)
		if err != nil {
			return toErrorResponse(err, "Cannot react to posts.")
		}

		postsOA := make([]Post, len(posts))
		for i, p := range posts {
			postsOA[i] = makePost(p, types, cur)
		}

		n, err := s.postLogic.GetTotalByUserID(ctx, u.UUID)
		if err != nil {
			return toErrorResponse(err, "Cannot get number of posts by user id.")
		}

		return Response(http.StatusOK, GetPostsResponse{Posts: postsOA, Total: int32(n)}), nil
	}
}

// PublishPost - publish post
func (s *PostApiService) PublishPost(ctx context.Context, publishRequest PublishRequest) (ImplResponse, error) {
	post := &models.Post{
		Content: publishRequest.Content,
	}

	if publishRequest.Perms {
		post.Perms = models.Paid
	} else {
		post.Perms = models.Free
	}

	p, err := s.postLogic.Publish(ctx, post)
	if err != nil {
		return toErrorResponse(err, "Cannot publish post.")
	}

	user, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	types, err := s.postLogic.GetReactionTypes(ctx)
	if err != nil {
		return toErrorResponse(err, "Cannot react to posts.")
	}

	pOA := makePost(p, types, user)

	return Response(http.StatusCreated, PublishResponse{
		Post:      pOA,
		Published: true,
	}), nil
}

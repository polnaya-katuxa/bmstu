/*
 * API for ppo project
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"
	"time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/google/uuid"
)

// CommentApiService is a service that implements the logic for the CommentApiServicer
// This service should implement the business logic for every endpoint for the CommentApi API.
// Include any external packages or services that will be required by this service.
type CommentApiService struct {
	postLogic interfaces.IPostLogic
}

// NewCommentApiService creates a default api service
func NewCommentApiService(postLogic interfaces.IPostLogic) CommentApiServicer {
	return &CommentApiService{postLogic: postLogic}
}

func makeComm(comm *models.Comment) Comment {
	commOA := Comment{
		Id:      comm.UUID.String(),
		Content: comm.Content,
		PubTime: comm.PublicTime.Format(time.RFC3339),
		Commentator: User{
			Id:          comm.Commentator.UUID.String(),
			Login:       comm.Commentator.Login,
			Picture:     comm.Commentator.Picture,
			Description: comm.Commentator.Description,
			Balance:     int32(comm.Commentator.Balance),
			Mail:        comm.Commentator.Mail,
			IsAdmin:     comm.Commentator.IsAdmin,
		},
		PostID: comm.PostID.String(),
	}

	return commOA
}

// Comment - comment post by id
func (s *CommentApiService) Comment(ctx context.Context, id string, commentRequest CommentRequest) (ImplResponse, error) {
	postID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	comm := &models.Comment{
		Content: commentRequest.Content,
		PostID:  postID,
	}

	comm, err = s.postLogic.Comment(ctx, comm)
	if err != nil {
		return toErrorResponse(err, "Cannot comment.")
	}

	commOA := makeComm(comm)

	return Response(http.StatusCreated, CommentResponse{Comment: commOA}), nil
}

// GetComments - get comments for post by id
func (s *CommentApiService) GetComments(ctx context.Context, id string, page int32, num int32) (ImplResponse, error) {
	if page < 0 || num < 0 || (page == 0 && num > 0) || (page > 0 && num == 0) {
		return toErrorResponse(ErrParams, "Cannot view feed.")
	}

	var pg *models.Paginator

	if page > 0 && num > 0 {
		pg = &models.Paginator{
			Page: int(page),
			Num:  int(num),
		}
	}

	postID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	comms, err := s.postLogic.GetAllComments(ctx, postID, pg)
	if err != nil {
		return toErrorResponse(err, "Cannot view post comments.")
	}

	commsOA := make([]Comment, 0, len(comms))
	for _, v := range comms {
		commsOA = append(commsOA, makeComm(v))
	}

	n, err := s.postLogic.GetTotalCommentsByPostID(ctx, postID)
	if err != nil {
		return toErrorResponse(err, "Cannot get total number of comments by post id.")
	}

	return Response(http.StatusOK, GetCommentsResponse{Comments: commsOA, Total: int32(n)}), nil
}

// Uncomment - uncomment post by id
func (s *CommentApiService) Uncomment(ctx context.Context, _ string, commentId string) (ImplResponse, error) {
	commID, err := uuid.Parse(commentId)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	err = s.postLogic.Uncomment(ctx, commID)
	if err != nil {
		return toErrorResponse(err, "Cannot uncomment.")
	}

	return Response(http.StatusOK, UncommentResponse{Uncommented: true}), nil
}

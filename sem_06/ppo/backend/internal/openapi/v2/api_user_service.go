/*
 * API for ppo project
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"

	mycontext "git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/context"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
)

// UserApiService is a service that implements the logic for the UserApiServicer
// This service should implement the business logic for every endpoint for the UserApi API.
// Include any external packages or services that will be required by this service.
type UserApiService struct {
	profileLogic interfaces.IProfileLogic
	subLogic     interfaces.ISubscriptionLogic
}

// NewUserApiService creates a default api service
func NewUserApiService(profileLogic interfaces.IProfileLogic, subLogic interfaces.ISubscriptionLogic) UserApiServicer {
	return &UserApiService{profileLogic: profileLogic, subLogic: subLogic}
}

// DeleteUser - delete user by login
func (s *UserApiService) DeleteUser(ctx context.Context, login string) (ImplResponse, error) {
	err := s.profileLogic.Delete(ctx, login)
	if err != nil {
		return toErrorResponse(err, "Cannot delete user.")
	}

	return Response(http.StatusOK, DeleteUserResponse{Deleted: true}), nil
}

// GetCurrentUser - get current user
func (s *UserApiService) GetCurrentUser(ctx context.Context) (ImplResponse, error) {
	user, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	u := User{
		Id:          user.UUID.String(),
		Login:       user.Login,
		Picture:     user.Picture,
		Description: user.Description,
		Balance:     int32(user.Balance),
		Mail:        user.Mail,
		IsAdmin:     user.IsAdmin,
	}

	return Response(http.StatusOK, UserInfoResponse{
		User: u,
	}), nil
}

// GetUser - get user by login
func (s *UserApiService) GetUser(ctx context.Context, login string) (ImplResponse, error) {
	user, err := s.profileLogic.Get(ctx, login)
	if err != nil {
		return toErrorResponse(err, "Cannot view profile.")
	}

	userReader, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	self, subscribed := false, false
	if userReader.UUID == user.UUID {
		self = true
	} else {
		subscribed, err = s.subLogic.IsSubscribed(ctx, userReader.UUID, user.UUID)
		if err != nil {
			return toErrorResponse(err, "Cannot check subscription.")
		}
	}

	u := User{
		Id:          user.UUID.String(),
		Login:       user.Login,
		Picture:     user.Picture,
		Description: user.Description,
		Balance:     int32(user.Balance),
		Mail:        user.Mail,
		IsAdmin:     user.IsAdmin,
	}

	return Response(http.StatusOK, GetUserResponse{
		User:       u,
		Subscribed: subscribed,
		Self:       self,
	}), nil
}

// GetUsers - get all users
func (s *UserApiService) GetUsers(ctx context.Context, page int32, num int32) (ImplResponse, error) {
	if page < 0 || num < 0 || (page == 0 && num > 0) || (page > 0 && num == 0) {
		return toErrorResponse(ErrParams, "Cannot view feed.")
	}

	var pg *models.Paginator

	if page > 0 && num > 0 {
		pg = &models.Paginator{
			Page: int(page),
			Num:  int(num),
		}
	}

	users, err := s.profileLogic.GetAll(ctx, pg)
	if err != nil {
		return toErrorResponse(err, "Cannot view users.")
	}

	usersOA := make([]User, len(users))

	for i, u := range users {
		usersOA[i] = User{
			Id:          u.UUID.String(),
			Login:       u.Login,
			Picture:     u.Picture,
			Description: u.Description,
			Balance:     int32(u.Balance),
			Mail:        u.Mail,
			IsAdmin:     u.IsAdmin,
		}
	}

	n, err := s.profileLogic.GetTotal(ctx)
	if err != nil {
		return toErrorResponse(err, "Cannot get number of users.")
	}

	return Response(http.StatusOK, GetUsersResponse{
		Total: int32(n),
		Users: usersOA,
	}), nil
}

// Login - login
func (s *UserApiService) Login(ctx context.Context, loginRequest LoginRequest) (ImplResponse, error) {
	token, err := s.profileLogic.Login(ctx, loginRequest.Login, loginRequest.Password)
	if err != nil {
		return toErrorResponse(err, "Cannot login.")
	}

	return Response(http.StatusOK, AuthResponse{Token: token}), nil
}

// Logout - logout
func (s *UserApiService) Logout(_ context.Context) (ImplResponse, error) {
	return Response(http.StatusNoContent, nil), nil
}

// Register - register
func (s *UserApiService) Register(ctx context.Context, registerRequest RegisterRequest) (ImplResponse, error) {
	token, err := s.profileLogic.Register(ctx, &models.User{
		Login:       registerRequest.Login,
		Mail:        registerRequest.Mail,
		Picture:     registerRequest.Picture,
		Description: registerRequest.Description,
	}, registerRequest.Password)
	if err != nil {
		return toErrorResponse(err, "Cannot register.")
	}

	return Response(http.StatusCreated, AuthResponse{Token: token}), nil
}

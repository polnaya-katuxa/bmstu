/*
 * API for ppo project
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"

	mycontext "git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/context"
	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces"
	"github.com/google/uuid"
)

// SubscriberApiService is a service that implements the logic for the SubscriberApiServicer
// This service should implement the business logic for every endpoint for the SubscriberApi API.
// Include any external packages or services that will be required by this service.
type SubscriberApiService struct {
	subLogic interfaces.ISubscriptionLogic
}

// NewSubscriberApiService creates a default api service
func NewSubscriberApiService(subLogic interfaces.ISubscriptionLogic) SubscriberApiServicer {
	return &SubscriberApiService{subLogic: subLogic}
}

// Subscribe - subscribe by id
func (s *SubscriberApiService) Subscribe(ctx context.Context, id string) (ImplResponse, error) {
	writerID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	err = s.subLogic.Subscribe(ctx, writerID)
	if err != nil {
		return toErrorResponse(err, "Cannot subscribe.")
	}

	user, err := mycontext.UserFromContext(ctx)
	if err != nil {
		return toErrorResponse(err, "User is not authorized.")
	}

	subscribed, err := s.subLogic.IsSubscribed(ctx, user.UUID, writerID)
	if err != nil {
		return toErrorResponse(err, "Cannot check subscription.")
	}

	return Response(http.StatusOK, SubscribeResponse{Subscribed: subscribed}), nil
}

// Unsubscribe - unsubscribe by id
func (s *SubscriberApiService) Unsubscribe(ctx context.Context, id string, subscriberId string) (ImplResponse, error) {
	writerID, err := uuid.Parse(id)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	err = s.subLogic.Subscribe(ctx, writerID)
	if err != nil {
		return toErrorResponse(err, "Cannot unsubscribe.")
	}

	readerID, err := uuid.Parse(subscriberId)
	if err != nil {
		return toErrorResponse(err, "Invalid data.")
	}

	subscribed, err := s.subLogic.IsSubscribed(ctx, readerID, writerID)
	if err != nil {
		return toErrorResponse(err, "Cannot check subscription.")
	}

	return Response(http.StatusOK, SubscribeResponse{Subscribed: subscribed}), nil
}

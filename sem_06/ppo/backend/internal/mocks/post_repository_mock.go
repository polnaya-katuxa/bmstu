package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IPostRepository -o ./internal/mocks/i_post_repository_mock_test.go -n IPostRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IPostRepositoryMock implements interfaces.IPostRepository
type IPostRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error)
	inspectFuncCreate   func(ctx context.Context, pp1 *models.Post)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mIPostRepositoryMockCreate

	funcDelete          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIPostRepositoryMockDelete

	funcGet          func(ctx context.Context, u1 uuid.UUID) (pp1 *models.Post, err error)
	inspectFuncGet   func(ctx context.Context, u1 uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mIPostRepositoryMockGet

	funcGetAll          func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mIPostRepositoryMockGetAll

	funcGetByIDAndSpan          func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (ppa1 []*models.Post, err error)
	inspectFuncGetByIDAndSpan   func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool)
	afterGetByIDAndSpanCounter  uint64
	beforeGetByIDAndSpanCounter uint64
	GetByIDAndSpanMock          mIPostRepositoryMockGetByIDAndSpan

	funcGetReactionTypes          func(ctx context.Context) (rpa1 []*models.ReactionType, err error)
	inspectFuncGetReactionTypes   func(ctx context.Context)
	afterGetReactionTypesCounter  uint64
	beforeGetReactionTypesCounter uint64
	GetReactionTypesMock          mIPostRepositoryMockGetReactionTypes

	funcGetSortedLimits          func(ctx context.Context) (lpa1 []*models.Limit, err error)
	inspectFuncGetSortedLimits   func(ctx context.Context)
	afterGetSortedLimitsCounter  uint64
	beforeGetSortedLimitsCounter uint64
	GetSortedLimitsMock          mIPostRepositoryMockGetSortedLimits

	funcGetTotalByIDAndSpan          func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (i1 int, err error)
	inspectFuncGetTotalByIDAndSpan   func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool)
	afterGetTotalByIDAndSpanCounter  uint64
	beforeGetTotalByIDAndSpanCounter uint64
	GetTotalByIDAndSpanMock          mIPostRepositoryMockGetTotalByIDAndSpan

	funcGetTotalByUserID          func(ctx context.Context, userID uuid.UUID) (i1 int, err error)
	inspectFuncGetTotalByUserID   func(ctx context.Context, userID uuid.UUID)
	afterGetTotalByUserIDCounter  uint64
	beforeGetTotalByUserIDCounter uint64
	GetTotalByUserIDMock          mIPostRepositoryMockGetTotalByUserID

	funcUpdate          func(ctx context.Context, pp1 *models.Post) (err error)
	inspectFuncUpdate   func(ctx context.Context, pp1 *models.Post)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mIPostRepositoryMockUpdate
}

// NewIPostRepositoryMock returns a mock for interfaces.IPostRepository
func NewIPostRepositoryMock(t minimock.Tester) *IPostRepositoryMock {
	m := &IPostRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mIPostRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*IPostRepositoryMockCreateParams{}

	m.DeleteMock = mIPostRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IPostRepositoryMockDeleteParams{}

	m.GetMock = mIPostRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*IPostRepositoryMockGetParams{}

	m.GetAllMock = mIPostRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*IPostRepositoryMockGetAllParams{}

	m.GetByIDAndSpanMock = mIPostRepositoryMockGetByIDAndSpan{mock: m}
	m.GetByIDAndSpanMock.callArgs = []*IPostRepositoryMockGetByIDAndSpanParams{}

	m.GetReactionTypesMock = mIPostRepositoryMockGetReactionTypes{mock: m}
	m.GetReactionTypesMock.callArgs = []*IPostRepositoryMockGetReactionTypesParams{}

	m.GetSortedLimitsMock = mIPostRepositoryMockGetSortedLimits{mock: m}
	m.GetSortedLimitsMock.callArgs = []*IPostRepositoryMockGetSortedLimitsParams{}

	m.GetTotalByIDAndSpanMock = mIPostRepositoryMockGetTotalByIDAndSpan{mock: m}
	m.GetTotalByIDAndSpanMock.callArgs = []*IPostRepositoryMockGetTotalByIDAndSpanParams{}

	m.GetTotalByUserIDMock = mIPostRepositoryMockGetTotalByUserID{mock: m}
	m.GetTotalByUserIDMock.callArgs = []*IPostRepositoryMockGetTotalByUserIDParams{}

	m.UpdateMock = mIPostRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*IPostRepositoryMockUpdateParams{}

	return m
}

type mIPostRepositoryMockCreate struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockCreateExpectation
	expectations       []*IPostRepositoryMockCreateExpectation

	callArgs []*IPostRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockCreateExpectation specifies expectation struct of the IPostRepository.Create
type IPostRepositoryMockCreateExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockCreateParams
	results *IPostRepositoryMockCreateResults
	Counter uint64
}

// IPostRepositoryMockCreateParams contains parameters of the IPostRepository.Create
type IPostRepositoryMockCreateParams struct {
	ctx context.Context
	pp1 *models.Post
}

// IPostRepositoryMockCreateResults contains results of the IPostRepository.Create
type IPostRepositoryMockCreateResults struct {
	pp2 *models.Post
	err error
}

// Expect sets up expected params for IPostRepository.Create
func (mmCreate *mIPostRepositoryMockCreate) Expect(ctx context.Context, pp1 *models.Post) *mIPostRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IPostRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IPostRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &IPostRepositoryMockCreateParams{ctx, pp1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.Create
func (mmCreate *mIPostRepositoryMockCreate) Inspect(f func(ctx context.Context, pp1 *models.Post)) *mIPostRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by IPostRepository.Create
func (mmCreate *mIPostRepositoryMockCreate) Return(pp2 *models.Post, err error) *IPostRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IPostRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IPostRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &IPostRepositoryMockCreateResults{pp2, err}
	return mmCreate.mock
}

// Set uses given function f to mock the IPostRepository.Create method
func (mmCreate *mIPostRepositoryMockCreate) Set(f func(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error)) *IPostRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the IPostRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the IPostRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the IPostRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mIPostRepositoryMockCreate) When(ctx context.Context, pp1 *models.Post) *IPostRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IPostRepositoryMock.Create mock is already set by Set")
	}

	expectation := &IPostRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &IPostRepositoryMockCreateParams{ctx, pp1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.Create return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockCreateExpectation) Then(pp2 *models.Post, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockCreateResults{pp2, err}
	return e.mock
}

// Create implements interfaces.IPostRepository
func (mmCreate *IPostRepositoryMock) Create(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, pp1)
	}

	mm_params := &IPostRepositoryMockCreateParams{ctx, pp1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := IPostRepositoryMockCreateParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("IPostRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the IPostRepositoryMock.Create")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, pp1)
	}
	mmCreate.t.Fatalf("Unexpected call to IPostRepositoryMock.Create. %v %v", ctx, pp1)
	return
}

// CreateAfterCounter returns a count of finished IPostRepositoryMock.Create invocations
func (mmCreate *IPostRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of IPostRepositoryMock.Create invocations
func (mmCreate *IPostRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mIPostRepositoryMockCreate) Calls() []*IPostRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.Create")
	}
}

type mIPostRepositoryMockDelete struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockDeleteExpectation
	expectations       []*IPostRepositoryMockDeleteExpectation

	callArgs []*IPostRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockDeleteExpectation specifies expectation struct of the IPostRepository.Delete
type IPostRepositoryMockDeleteExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockDeleteParams
	results *IPostRepositoryMockDeleteResults
	Counter uint64
}

// IPostRepositoryMockDeleteParams contains parameters of the IPostRepository.Delete
type IPostRepositoryMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IPostRepositoryMockDeleteResults contains results of the IPostRepository.Delete
type IPostRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IPostRepository.Delete
func (mmDelete *mIPostRepositoryMockDelete) Expect(ctx context.Context, u1 uuid.UUID) *mIPostRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IPostRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IPostRepositoryMockDeleteParams{ctx, u1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.Delete
func (mmDelete *mIPostRepositoryMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIPostRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IPostRepository.Delete
func (mmDelete *mIPostRepositoryMockDelete) Return(err error) *IPostRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IPostRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IPostRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IPostRepository.Delete method
func (mmDelete *mIPostRepositoryMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *IPostRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IPostRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IPostRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IPostRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIPostRepositoryMockDelete) When(ctx context.Context, u1 uuid.UUID) *IPostRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &IPostRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IPostRepositoryMockDeleteParams{ctx, u1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.Delete return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockDeleteExpectation) Then(err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IPostRepository
func (mmDelete *IPostRepositoryMock) Delete(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1)
	}

	mm_params := &IPostRepositoryMockDeleteParams{ctx, u1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IPostRepositoryMockDeleteParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IPostRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IPostRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1)
	}
	mmDelete.t.Fatalf("Unexpected call to IPostRepositoryMock.Delete. %v %v", ctx, u1)
	return
}

// DeleteAfterCounter returns a count of finished IPostRepositoryMock.Delete invocations
func (mmDelete *IPostRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IPostRepositoryMock.Delete invocations
func (mmDelete *IPostRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIPostRepositoryMockDelete) Calls() []*IPostRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.Delete")
	}
}

type mIPostRepositoryMockGet struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetExpectation
	expectations       []*IPostRepositoryMockGetExpectation

	callArgs []*IPostRepositoryMockGetParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetExpectation specifies expectation struct of the IPostRepository.Get
type IPostRepositoryMockGetExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetParams
	results *IPostRepositoryMockGetResults
	Counter uint64
}

// IPostRepositoryMockGetParams contains parameters of the IPostRepository.Get
type IPostRepositoryMockGetParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IPostRepositoryMockGetResults contains results of the IPostRepository.Get
type IPostRepositoryMockGetResults struct {
	pp1 *models.Post
	err error
}

// Expect sets up expected params for IPostRepository.Get
func (mmGet *mIPostRepositoryMockGet) Expect(ctx context.Context, u1 uuid.UUID) *mIPostRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IPostRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &IPostRepositoryMockGetParams{ctx, u1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.Get
func (mmGet *mIPostRepositoryMockGet) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIPostRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by IPostRepository.Get
func (mmGet *mIPostRepositoryMockGet) Return(pp1 *models.Post, err error) *IPostRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IPostRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &IPostRepositoryMockGetResults{pp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the IPostRepository.Get method
func (mmGet *mIPostRepositoryMockGet) Set(f func(ctx context.Context, u1 uuid.UUID) (pp1 *models.Post, err error)) *IPostRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the IPostRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the IPostRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the IPostRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mIPostRepositoryMockGet) When(ctx context.Context, u1 uuid.UUID) *IPostRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostRepositoryMock.Get mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &IPostRepositoryMockGetParams{ctx, u1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.Get return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetExpectation) Then(pp1 *models.Post, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetResults{pp1, err}
	return e.mock
}

// Get implements interfaces.IPostRepository
func (mmGet *IPostRepositoryMock) Get(ctx context.Context, u1 uuid.UUID) (pp1 *models.Post, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, u1)
	}

	mm_params := &IPostRepositoryMockGetParams{ctx, u1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("IPostRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the IPostRepositoryMock.Get")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, u1)
	}
	mmGet.t.Fatalf("Unexpected call to IPostRepositoryMock.Get. %v %v", ctx, u1)
	return
}

// GetAfterCounter returns a count of finished IPostRepositoryMock.Get invocations
func (mmGet *IPostRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of IPostRepositoryMock.Get invocations
func (mmGet *IPostRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mIPostRepositoryMockGet) Calls() []*IPostRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.Get")
	}
}

type mIPostRepositoryMockGetAll struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetAllExpectation
	expectations       []*IPostRepositoryMockGetAllExpectation

	callArgs []*IPostRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetAllExpectation specifies expectation struct of the IPostRepository.GetAll
type IPostRepositoryMockGetAllExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetAllParams
	results *IPostRepositoryMockGetAllResults
	Counter uint64
}

// IPostRepositoryMockGetAllParams contains parameters of the IPostRepository.GetAll
type IPostRepositoryMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
	pp1 *models.Paginator
}

// IPostRepositoryMockGetAllResults contains results of the IPostRepository.GetAll
type IPostRepositoryMockGetAllResults struct {
	ppa1 []*models.Post
	err  error
}

// Expect sets up expected params for IPostRepository.GetAll
func (mmGetAll *mIPostRepositoryMockGetAll) Expect(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *mIPostRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IPostRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &IPostRepositoryMockGetAllParams{ctx, u1, pp1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetAll
func (mmGetAll *mIPostRepositoryMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)) *mIPostRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by IPostRepository.GetAll
func (mmGetAll *mIPostRepositoryMockGetAll) Return(ppa1 []*models.Post, err error) *IPostRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IPostRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &IPostRepositoryMockGetAllResults{ppa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the IPostRepository.GetAll method
func (mmGetAll *mIPostRepositoryMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error)) *IPostRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the IPostRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mIPostRepositoryMockGetAll) When(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *IPostRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &IPostRepositoryMockGetAllParams{ctx, u1, pp1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetAllExpectation) Then(ppa1 []*models.Post, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetAllResults{ppa1, err}
	return e.mock
}

// GetAll implements interfaces.IPostRepository
func (mmGetAll *IPostRepositoryMock) GetAll(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1, pp1)
	}

	mm_params := &IPostRepositoryMockGetAllParams{ctx, u1, pp1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetAllParams{ctx, u1, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("IPostRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the IPostRepositoryMock.GetAll")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1, pp1)
	}
	mmGetAll.t.Fatalf("Unexpected call to IPostRepositoryMock.GetAll. %v %v %v", ctx, u1, pp1)
	return
}

// GetAllAfterCounter returns a count of finished IPostRepositoryMock.GetAll invocations
func (mmGetAll *IPostRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of IPostRepositoryMock.GetAll invocations
func (mmGetAll *IPostRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mIPostRepositoryMockGetAll) Calls() []*IPostRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetAll")
	}
}

type mIPostRepositoryMockGetByIDAndSpan struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetByIDAndSpanExpectation
	expectations       []*IPostRepositoryMockGetByIDAndSpanExpectation

	callArgs []*IPostRepositoryMockGetByIDAndSpanParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetByIDAndSpanExpectation specifies expectation struct of the IPostRepository.GetByIDAndSpan
type IPostRepositoryMockGetByIDAndSpanExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetByIDAndSpanParams
	results *IPostRepositoryMockGetByIDAndSpanResults
	Counter uint64
}

// IPostRepositoryMockGetByIDAndSpanParams contains parameters of the IPostRepository.GetByIDAndSpan
type IPostRepositoryMockGetByIDAndSpanParams struct {
	ctx context.Context
	ua1 []uuid.UUID
	t1  time.Time
	t2  time.Time
	b1  bool
}

// IPostRepositoryMockGetByIDAndSpanResults contains results of the IPostRepository.GetByIDAndSpan
type IPostRepositoryMockGetByIDAndSpanResults struct {
	ppa1 []*models.Post
	err  error
}

// Expect sets up expected params for IPostRepository.GetByIDAndSpan
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) Expect(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) *mIPostRepositoryMockGetByIDAndSpan {
	if mmGetByIDAndSpan.mock.funcGetByIDAndSpan != nil {
		mmGetByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetByIDAndSpan mock is already set by Set")
	}

	if mmGetByIDAndSpan.defaultExpectation == nil {
		mmGetByIDAndSpan.defaultExpectation = &IPostRepositoryMockGetByIDAndSpanExpectation{}
	}

	mmGetByIDAndSpan.defaultExpectation.params = &IPostRepositoryMockGetByIDAndSpanParams{ctx, ua1, t1, t2, b1}
	for _, e := range mmGetByIDAndSpan.expectations {
		if minimock.Equal(e.params, mmGetByIDAndSpan.defaultExpectation.params) {
			mmGetByIDAndSpan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByIDAndSpan.defaultExpectation.params)
		}
	}

	return mmGetByIDAndSpan
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetByIDAndSpan
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) Inspect(f func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool)) *mIPostRepositoryMockGetByIDAndSpan {
	if mmGetByIDAndSpan.mock.inspectFuncGetByIDAndSpan != nil {
		mmGetByIDAndSpan.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetByIDAndSpan")
	}

	mmGetByIDAndSpan.mock.inspectFuncGetByIDAndSpan = f

	return mmGetByIDAndSpan
}

// Return sets up results that will be returned by IPostRepository.GetByIDAndSpan
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) Return(ppa1 []*models.Post, err error) *IPostRepositoryMock {
	if mmGetByIDAndSpan.mock.funcGetByIDAndSpan != nil {
		mmGetByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetByIDAndSpan mock is already set by Set")
	}

	if mmGetByIDAndSpan.defaultExpectation == nil {
		mmGetByIDAndSpan.defaultExpectation = &IPostRepositoryMockGetByIDAndSpanExpectation{mock: mmGetByIDAndSpan.mock}
	}
	mmGetByIDAndSpan.defaultExpectation.results = &IPostRepositoryMockGetByIDAndSpanResults{ppa1, err}
	return mmGetByIDAndSpan.mock
}

// Set uses given function f to mock the IPostRepository.GetByIDAndSpan method
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) Set(f func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (ppa1 []*models.Post, err error)) *IPostRepositoryMock {
	if mmGetByIDAndSpan.defaultExpectation != nil {
		mmGetByIDAndSpan.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetByIDAndSpan method")
	}

	if len(mmGetByIDAndSpan.expectations) > 0 {
		mmGetByIDAndSpan.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetByIDAndSpan method")
	}

	mmGetByIDAndSpan.mock.funcGetByIDAndSpan = f
	return mmGetByIDAndSpan.mock
}

// When sets expectation for the IPostRepository.GetByIDAndSpan which will trigger the result defined by the following
// Then helper
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) When(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) *IPostRepositoryMockGetByIDAndSpanExpectation {
	if mmGetByIDAndSpan.mock.funcGetByIDAndSpan != nil {
		mmGetByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetByIDAndSpan mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetByIDAndSpanExpectation{
		mock:   mmGetByIDAndSpan.mock,
		params: &IPostRepositoryMockGetByIDAndSpanParams{ctx, ua1, t1, t2, b1},
	}
	mmGetByIDAndSpan.expectations = append(mmGetByIDAndSpan.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetByIDAndSpan return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetByIDAndSpanExpectation) Then(ppa1 []*models.Post, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetByIDAndSpanResults{ppa1, err}
	return e.mock
}

// GetByIDAndSpan implements interfaces.IPostRepository
func (mmGetByIDAndSpan *IPostRepositoryMock) GetByIDAndSpan(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (ppa1 []*models.Post, err error) {
	mm_atomic.AddUint64(&mmGetByIDAndSpan.beforeGetByIDAndSpanCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByIDAndSpan.afterGetByIDAndSpanCounter, 1)

	if mmGetByIDAndSpan.inspectFuncGetByIDAndSpan != nil {
		mmGetByIDAndSpan.inspectFuncGetByIDAndSpan(ctx, ua1, t1, t2, b1)
	}

	mm_params := &IPostRepositoryMockGetByIDAndSpanParams{ctx, ua1, t1, t2, b1}

	// Record call args
	mmGetByIDAndSpan.GetByIDAndSpanMock.mutex.Lock()
	mmGetByIDAndSpan.GetByIDAndSpanMock.callArgs = append(mmGetByIDAndSpan.GetByIDAndSpanMock.callArgs, mm_params)
	mmGetByIDAndSpan.GetByIDAndSpanMock.mutex.Unlock()

	for _, e := range mmGetByIDAndSpan.GetByIDAndSpanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetByIDAndSpan.GetByIDAndSpanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByIDAndSpan.GetByIDAndSpanMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByIDAndSpan.GetByIDAndSpanMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetByIDAndSpanParams{ctx, ua1, t1, t2, b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByIDAndSpan.t.Errorf("IPostRepositoryMock.GetByIDAndSpan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByIDAndSpan.GetByIDAndSpanMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByIDAndSpan.t.Fatal("No results are set for the IPostRepositoryMock.GetByIDAndSpan")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetByIDAndSpan.funcGetByIDAndSpan != nil {
		return mmGetByIDAndSpan.funcGetByIDAndSpan(ctx, ua1, t1, t2, b1)
	}
	mmGetByIDAndSpan.t.Fatalf("Unexpected call to IPostRepositoryMock.GetByIDAndSpan. %v %v %v %v %v", ctx, ua1, t1, t2, b1)
	return
}

// GetByIDAndSpanAfterCounter returns a count of finished IPostRepositoryMock.GetByIDAndSpan invocations
func (mmGetByIDAndSpan *IPostRepositoryMock) GetByIDAndSpanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDAndSpan.afterGetByIDAndSpanCounter)
}

// GetByIDAndSpanBeforeCounter returns a count of IPostRepositoryMock.GetByIDAndSpan invocations
func (mmGetByIDAndSpan *IPostRepositoryMock) GetByIDAndSpanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDAndSpan.beforeGetByIDAndSpanCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetByIDAndSpan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByIDAndSpan *mIPostRepositoryMockGetByIDAndSpan) Calls() []*IPostRepositoryMockGetByIDAndSpanParams {
	mmGetByIDAndSpan.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetByIDAndSpanParams, len(mmGetByIDAndSpan.callArgs))
	copy(argCopy, mmGetByIDAndSpan.callArgs)

	mmGetByIDAndSpan.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDAndSpanDone returns true if the count of the GetByIDAndSpan invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetByIDAndSpanDone() bool {
	for _, e := range m.GetByIDAndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDAndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDAndSpanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByIDAndSpan != nil && mm_atomic.LoadUint64(&m.afterGetByIDAndSpanCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDAndSpanInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetByIDAndSpanInspect() {
	for _, e := range m.GetByIDAndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetByIDAndSpan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDAndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDAndSpanCounter) < 1 {
		if m.GetByIDAndSpanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetByIDAndSpan")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetByIDAndSpan with params: %#v", *m.GetByIDAndSpanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByIDAndSpan != nil && mm_atomic.LoadUint64(&m.afterGetByIDAndSpanCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetByIDAndSpan")
	}
}

type mIPostRepositoryMockGetReactionTypes struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetReactionTypesExpectation
	expectations       []*IPostRepositoryMockGetReactionTypesExpectation

	callArgs []*IPostRepositoryMockGetReactionTypesParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetReactionTypesExpectation specifies expectation struct of the IPostRepository.GetReactionTypes
type IPostRepositoryMockGetReactionTypesExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetReactionTypesParams
	results *IPostRepositoryMockGetReactionTypesResults
	Counter uint64
}

// IPostRepositoryMockGetReactionTypesParams contains parameters of the IPostRepository.GetReactionTypes
type IPostRepositoryMockGetReactionTypesParams struct {
	ctx context.Context
}

// IPostRepositoryMockGetReactionTypesResults contains results of the IPostRepository.GetReactionTypes
type IPostRepositoryMockGetReactionTypesResults struct {
	rpa1 []*models.ReactionType
	err  error
}

// Expect sets up expected params for IPostRepository.GetReactionTypes
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) Expect(ctx context.Context) *mIPostRepositoryMockGetReactionTypes {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostRepositoryMock.GetReactionTypes mock is already set by Set")
	}

	if mmGetReactionTypes.defaultExpectation == nil {
		mmGetReactionTypes.defaultExpectation = &IPostRepositoryMockGetReactionTypesExpectation{}
	}

	mmGetReactionTypes.defaultExpectation.params = &IPostRepositoryMockGetReactionTypesParams{ctx}
	for _, e := range mmGetReactionTypes.expectations {
		if minimock.Equal(e.params, mmGetReactionTypes.defaultExpectation.params) {
			mmGetReactionTypes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReactionTypes.defaultExpectation.params)
		}
	}

	return mmGetReactionTypes
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetReactionTypes
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) Inspect(f func(ctx context.Context)) *mIPostRepositoryMockGetReactionTypes {
	if mmGetReactionTypes.mock.inspectFuncGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetReactionTypes")
	}

	mmGetReactionTypes.mock.inspectFuncGetReactionTypes = f

	return mmGetReactionTypes
}

// Return sets up results that will be returned by IPostRepository.GetReactionTypes
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) Return(rpa1 []*models.ReactionType, err error) *IPostRepositoryMock {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostRepositoryMock.GetReactionTypes mock is already set by Set")
	}

	if mmGetReactionTypes.defaultExpectation == nil {
		mmGetReactionTypes.defaultExpectation = &IPostRepositoryMockGetReactionTypesExpectation{mock: mmGetReactionTypes.mock}
	}
	mmGetReactionTypes.defaultExpectation.results = &IPostRepositoryMockGetReactionTypesResults{rpa1, err}
	return mmGetReactionTypes.mock
}

// Set uses given function f to mock the IPostRepository.GetReactionTypes method
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) Set(f func(ctx context.Context) (rpa1 []*models.ReactionType, err error)) *IPostRepositoryMock {
	if mmGetReactionTypes.defaultExpectation != nil {
		mmGetReactionTypes.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetReactionTypes method")
	}

	if len(mmGetReactionTypes.expectations) > 0 {
		mmGetReactionTypes.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetReactionTypes method")
	}

	mmGetReactionTypes.mock.funcGetReactionTypes = f
	return mmGetReactionTypes.mock
}

// When sets expectation for the IPostRepository.GetReactionTypes which will trigger the result defined by the following
// Then helper
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) When(ctx context.Context) *IPostRepositoryMockGetReactionTypesExpectation {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostRepositoryMock.GetReactionTypes mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetReactionTypesExpectation{
		mock:   mmGetReactionTypes.mock,
		params: &IPostRepositoryMockGetReactionTypesParams{ctx},
	}
	mmGetReactionTypes.expectations = append(mmGetReactionTypes.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetReactionTypes return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetReactionTypesExpectation) Then(rpa1 []*models.ReactionType, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetReactionTypesResults{rpa1, err}
	return e.mock
}

// GetReactionTypes implements interfaces.IPostRepository
func (mmGetReactionTypes *IPostRepositoryMock) GetReactionTypes(ctx context.Context) (rpa1 []*models.ReactionType, err error) {
	mm_atomic.AddUint64(&mmGetReactionTypes.beforeGetReactionTypesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReactionTypes.afterGetReactionTypesCounter, 1)

	if mmGetReactionTypes.inspectFuncGetReactionTypes != nil {
		mmGetReactionTypes.inspectFuncGetReactionTypes(ctx)
	}

	mm_params := &IPostRepositoryMockGetReactionTypesParams{ctx}

	// Record call args
	mmGetReactionTypes.GetReactionTypesMock.mutex.Lock()
	mmGetReactionTypes.GetReactionTypesMock.callArgs = append(mmGetReactionTypes.GetReactionTypesMock.callArgs, mm_params)
	mmGetReactionTypes.GetReactionTypesMock.mutex.Unlock()

	for _, e := range mmGetReactionTypes.GetReactionTypesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmGetReactionTypes.GetReactionTypesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetReactionTypesParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReactionTypes.t.Errorf("IPostRepositoryMock.GetReactionTypes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReactionTypes.t.Fatal("No results are set for the IPostRepositoryMock.GetReactionTypes")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmGetReactionTypes.funcGetReactionTypes != nil {
		return mmGetReactionTypes.funcGetReactionTypes(ctx)
	}
	mmGetReactionTypes.t.Fatalf("Unexpected call to IPostRepositoryMock.GetReactionTypes. %v", ctx)
	return
}

// GetReactionTypesAfterCounter returns a count of finished IPostRepositoryMock.GetReactionTypes invocations
func (mmGetReactionTypes *IPostRepositoryMock) GetReactionTypesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReactionTypes.afterGetReactionTypesCounter)
}

// GetReactionTypesBeforeCounter returns a count of IPostRepositoryMock.GetReactionTypes invocations
func (mmGetReactionTypes *IPostRepositoryMock) GetReactionTypesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReactionTypes.beforeGetReactionTypesCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetReactionTypes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReactionTypes *mIPostRepositoryMockGetReactionTypes) Calls() []*IPostRepositoryMockGetReactionTypesParams {
	mmGetReactionTypes.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetReactionTypesParams, len(mmGetReactionTypes.callArgs))
	copy(argCopy, mmGetReactionTypes.callArgs)

	mmGetReactionTypes.mutex.RUnlock()

	return argCopy
}

// MinimockGetReactionTypesDone returns true if the count of the GetReactionTypes invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetReactionTypesDone() bool {
	for _, e := range m.GetReactionTypesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReactionTypesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReactionTypes != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetReactionTypesInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetReactionTypesInspect() {
	for _, e := range m.GetReactionTypesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetReactionTypes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReactionTypesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		if m.GetReactionTypesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetReactionTypes")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetReactionTypes with params: %#v", *m.GetReactionTypesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReactionTypes != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetReactionTypes")
	}
}

type mIPostRepositoryMockGetSortedLimits struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetSortedLimitsExpectation
	expectations       []*IPostRepositoryMockGetSortedLimitsExpectation

	callArgs []*IPostRepositoryMockGetSortedLimitsParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetSortedLimitsExpectation specifies expectation struct of the IPostRepository.GetSortedLimits
type IPostRepositoryMockGetSortedLimitsExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetSortedLimitsParams
	results *IPostRepositoryMockGetSortedLimitsResults
	Counter uint64
}

// IPostRepositoryMockGetSortedLimitsParams contains parameters of the IPostRepository.GetSortedLimits
type IPostRepositoryMockGetSortedLimitsParams struct {
	ctx context.Context
}

// IPostRepositoryMockGetSortedLimitsResults contains results of the IPostRepository.GetSortedLimits
type IPostRepositoryMockGetSortedLimitsResults struct {
	lpa1 []*models.Limit
	err  error
}

// Expect sets up expected params for IPostRepository.GetSortedLimits
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) Expect(ctx context.Context) *mIPostRepositoryMockGetSortedLimits {
	if mmGetSortedLimits.mock.funcGetSortedLimits != nil {
		mmGetSortedLimits.mock.t.Fatalf("IPostRepositoryMock.GetSortedLimits mock is already set by Set")
	}

	if mmGetSortedLimits.defaultExpectation == nil {
		mmGetSortedLimits.defaultExpectation = &IPostRepositoryMockGetSortedLimitsExpectation{}
	}

	mmGetSortedLimits.defaultExpectation.params = &IPostRepositoryMockGetSortedLimitsParams{ctx}
	for _, e := range mmGetSortedLimits.expectations {
		if minimock.Equal(e.params, mmGetSortedLimits.defaultExpectation.params) {
			mmGetSortedLimits.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSortedLimits.defaultExpectation.params)
		}
	}

	return mmGetSortedLimits
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetSortedLimits
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) Inspect(f func(ctx context.Context)) *mIPostRepositoryMockGetSortedLimits {
	if mmGetSortedLimits.mock.inspectFuncGetSortedLimits != nil {
		mmGetSortedLimits.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetSortedLimits")
	}

	mmGetSortedLimits.mock.inspectFuncGetSortedLimits = f

	return mmGetSortedLimits
}

// Return sets up results that will be returned by IPostRepository.GetSortedLimits
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) Return(lpa1 []*models.Limit, err error) *IPostRepositoryMock {
	if mmGetSortedLimits.mock.funcGetSortedLimits != nil {
		mmGetSortedLimits.mock.t.Fatalf("IPostRepositoryMock.GetSortedLimits mock is already set by Set")
	}

	if mmGetSortedLimits.defaultExpectation == nil {
		mmGetSortedLimits.defaultExpectation = &IPostRepositoryMockGetSortedLimitsExpectation{mock: mmGetSortedLimits.mock}
	}
	mmGetSortedLimits.defaultExpectation.results = &IPostRepositoryMockGetSortedLimitsResults{lpa1, err}
	return mmGetSortedLimits.mock
}

// Set uses given function f to mock the IPostRepository.GetSortedLimits method
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) Set(f func(ctx context.Context) (lpa1 []*models.Limit, err error)) *IPostRepositoryMock {
	if mmGetSortedLimits.defaultExpectation != nil {
		mmGetSortedLimits.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetSortedLimits method")
	}

	if len(mmGetSortedLimits.expectations) > 0 {
		mmGetSortedLimits.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetSortedLimits method")
	}

	mmGetSortedLimits.mock.funcGetSortedLimits = f
	return mmGetSortedLimits.mock
}

// When sets expectation for the IPostRepository.GetSortedLimits which will trigger the result defined by the following
// Then helper
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) When(ctx context.Context) *IPostRepositoryMockGetSortedLimitsExpectation {
	if mmGetSortedLimits.mock.funcGetSortedLimits != nil {
		mmGetSortedLimits.mock.t.Fatalf("IPostRepositoryMock.GetSortedLimits mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetSortedLimitsExpectation{
		mock:   mmGetSortedLimits.mock,
		params: &IPostRepositoryMockGetSortedLimitsParams{ctx},
	}
	mmGetSortedLimits.expectations = append(mmGetSortedLimits.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetSortedLimits return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetSortedLimitsExpectation) Then(lpa1 []*models.Limit, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetSortedLimitsResults{lpa1, err}
	return e.mock
}

// GetSortedLimits implements interfaces.IPostRepository
func (mmGetSortedLimits *IPostRepositoryMock) GetSortedLimits(ctx context.Context) (lpa1 []*models.Limit, err error) {
	mm_atomic.AddUint64(&mmGetSortedLimits.beforeGetSortedLimitsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSortedLimits.afterGetSortedLimitsCounter, 1)

	if mmGetSortedLimits.inspectFuncGetSortedLimits != nil {
		mmGetSortedLimits.inspectFuncGetSortedLimits(ctx)
	}

	mm_params := &IPostRepositoryMockGetSortedLimitsParams{ctx}

	// Record call args
	mmGetSortedLimits.GetSortedLimitsMock.mutex.Lock()
	mmGetSortedLimits.GetSortedLimitsMock.callArgs = append(mmGetSortedLimits.GetSortedLimitsMock.callArgs, mm_params)
	mmGetSortedLimits.GetSortedLimitsMock.mutex.Unlock()

	for _, e := range mmGetSortedLimits.GetSortedLimitsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.err
		}
	}

	if mmGetSortedLimits.GetSortedLimitsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSortedLimits.GetSortedLimitsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSortedLimits.GetSortedLimitsMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetSortedLimitsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSortedLimits.t.Errorf("IPostRepositoryMock.GetSortedLimits got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSortedLimits.GetSortedLimitsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSortedLimits.t.Fatal("No results are set for the IPostRepositoryMock.GetSortedLimits")
		}
		return (*mm_results).lpa1, (*mm_results).err
	}
	if mmGetSortedLimits.funcGetSortedLimits != nil {
		return mmGetSortedLimits.funcGetSortedLimits(ctx)
	}
	mmGetSortedLimits.t.Fatalf("Unexpected call to IPostRepositoryMock.GetSortedLimits. %v", ctx)
	return
}

// GetSortedLimitsAfterCounter returns a count of finished IPostRepositoryMock.GetSortedLimits invocations
func (mmGetSortedLimits *IPostRepositoryMock) GetSortedLimitsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSortedLimits.afterGetSortedLimitsCounter)
}

// GetSortedLimitsBeforeCounter returns a count of IPostRepositoryMock.GetSortedLimits invocations
func (mmGetSortedLimits *IPostRepositoryMock) GetSortedLimitsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSortedLimits.beforeGetSortedLimitsCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetSortedLimits.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSortedLimits *mIPostRepositoryMockGetSortedLimits) Calls() []*IPostRepositoryMockGetSortedLimitsParams {
	mmGetSortedLimits.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetSortedLimitsParams, len(mmGetSortedLimits.callArgs))
	copy(argCopy, mmGetSortedLimits.callArgs)

	mmGetSortedLimits.mutex.RUnlock()

	return argCopy
}

// MinimockGetSortedLimitsDone returns true if the count of the GetSortedLimits invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetSortedLimitsDone() bool {
	for _, e := range m.GetSortedLimitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSortedLimitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSortedLimitsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSortedLimits != nil && mm_atomic.LoadUint64(&m.afterGetSortedLimitsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSortedLimitsInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetSortedLimitsInspect() {
	for _, e := range m.GetSortedLimitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetSortedLimits with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSortedLimitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSortedLimitsCounter) < 1 {
		if m.GetSortedLimitsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetSortedLimits")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetSortedLimits with params: %#v", *m.GetSortedLimitsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSortedLimits != nil && mm_atomic.LoadUint64(&m.afterGetSortedLimitsCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetSortedLimits")
	}
}

type mIPostRepositoryMockGetTotalByIDAndSpan struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetTotalByIDAndSpanExpectation
	expectations       []*IPostRepositoryMockGetTotalByIDAndSpanExpectation

	callArgs []*IPostRepositoryMockGetTotalByIDAndSpanParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetTotalByIDAndSpanExpectation specifies expectation struct of the IPostRepository.GetTotalByIDAndSpan
type IPostRepositoryMockGetTotalByIDAndSpanExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetTotalByIDAndSpanParams
	results *IPostRepositoryMockGetTotalByIDAndSpanResults
	Counter uint64
}

// IPostRepositoryMockGetTotalByIDAndSpanParams contains parameters of the IPostRepository.GetTotalByIDAndSpan
type IPostRepositoryMockGetTotalByIDAndSpanParams struct {
	ctx context.Context
	ua1 []uuid.UUID
	t1  time.Time
	t2  time.Time
	b1  bool
}

// IPostRepositoryMockGetTotalByIDAndSpanResults contains results of the IPostRepository.GetTotalByIDAndSpan
type IPostRepositoryMockGetTotalByIDAndSpanResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IPostRepository.GetTotalByIDAndSpan
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) Expect(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) *mIPostRepositoryMockGetTotalByIDAndSpan {
	if mmGetTotalByIDAndSpan.mock.funcGetTotalByIDAndSpan != nil {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetTotalByIDAndSpan mock is already set by Set")
	}

	if mmGetTotalByIDAndSpan.defaultExpectation == nil {
		mmGetTotalByIDAndSpan.defaultExpectation = &IPostRepositoryMockGetTotalByIDAndSpanExpectation{}
	}

	mmGetTotalByIDAndSpan.defaultExpectation.params = &IPostRepositoryMockGetTotalByIDAndSpanParams{ctx, ua1, t1, t2, b1}
	for _, e := range mmGetTotalByIDAndSpan.expectations {
		if minimock.Equal(e.params, mmGetTotalByIDAndSpan.defaultExpectation.params) {
			mmGetTotalByIDAndSpan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalByIDAndSpan.defaultExpectation.params)
		}
	}

	return mmGetTotalByIDAndSpan
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetTotalByIDAndSpan
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) Inspect(f func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool)) *mIPostRepositoryMockGetTotalByIDAndSpan {
	if mmGetTotalByIDAndSpan.mock.inspectFuncGetTotalByIDAndSpan != nil {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetTotalByIDAndSpan")
	}

	mmGetTotalByIDAndSpan.mock.inspectFuncGetTotalByIDAndSpan = f

	return mmGetTotalByIDAndSpan
}

// Return sets up results that will be returned by IPostRepository.GetTotalByIDAndSpan
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) Return(i1 int, err error) *IPostRepositoryMock {
	if mmGetTotalByIDAndSpan.mock.funcGetTotalByIDAndSpan != nil {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetTotalByIDAndSpan mock is already set by Set")
	}

	if mmGetTotalByIDAndSpan.defaultExpectation == nil {
		mmGetTotalByIDAndSpan.defaultExpectation = &IPostRepositoryMockGetTotalByIDAndSpanExpectation{mock: mmGetTotalByIDAndSpan.mock}
	}
	mmGetTotalByIDAndSpan.defaultExpectation.results = &IPostRepositoryMockGetTotalByIDAndSpanResults{i1, err}
	return mmGetTotalByIDAndSpan.mock
}

// Set uses given function f to mock the IPostRepository.GetTotalByIDAndSpan method
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) Set(f func(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (i1 int, err error)) *IPostRepositoryMock {
	if mmGetTotalByIDAndSpan.defaultExpectation != nil {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetTotalByIDAndSpan method")
	}

	if len(mmGetTotalByIDAndSpan.expectations) > 0 {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetTotalByIDAndSpan method")
	}

	mmGetTotalByIDAndSpan.mock.funcGetTotalByIDAndSpan = f
	return mmGetTotalByIDAndSpan.mock
}

// When sets expectation for the IPostRepository.GetTotalByIDAndSpan which will trigger the result defined by the following
// Then helper
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) When(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) *IPostRepositoryMockGetTotalByIDAndSpanExpectation {
	if mmGetTotalByIDAndSpan.mock.funcGetTotalByIDAndSpan != nil {
		mmGetTotalByIDAndSpan.mock.t.Fatalf("IPostRepositoryMock.GetTotalByIDAndSpan mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetTotalByIDAndSpanExpectation{
		mock:   mmGetTotalByIDAndSpan.mock,
		params: &IPostRepositoryMockGetTotalByIDAndSpanParams{ctx, ua1, t1, t2, b1},
	}
	mmGetTotalByIDAndSpan.expectations = append(mmGetTotalByIDAndSpan.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetTotalByIDAndSpan return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetTotalByIDAndSpanExpectation) Then(i1 int, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetTotalByIDAndSpanResults{i1, err}
	return e.mock
}

// GetTotalByIDAndSpan implements interfaces.IPostRepository
func (mmGetTotalByIDAndSpan *IPostRepositoryMock) GetTotalByIDAndSpan(ctx context.Context, ua1 []uuid.UUID, t1 time.Time, t2 time.Time, b1 bool) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotalByIDAndSpan.beforeGetTotalByIDAndSpanCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalByIDAndSpan.afterGetTotalByIDAndSpanCounter, 1)

	if mmGetTotalByIDAndSpan.inspectFuncGetTotalByIDAndSpan != nil {
		mmGetTotalByIDAndSpan.inspectFuncGetTotalByIDAndSpan(ctx, ua1, t1, t2, b1)
	}

	mm_params := &IPostRepositoryMockGetTotalByIDAndSpanParams{ctx, ua1, t1, t2, b1}

	// Record call args
	mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.mutex.Lock()
	mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.callArgs = append(mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.callArgs, mm_params)
	mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.mutex.Unlock()

	for _, e := range mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetTotalByIDAndSpanParams{ctx, ua1, t1, t2, b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalByIDAndSpan.t.Errorf("IPostRepositoryMock.GetTotalByIDAndSpan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalByIDAndSpan.GetTotalByIDAndSpanMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalByIDAndSpan.t.Fatal("No results are set for the IPostRepositoryMock.GetTotalByIDAndSpan")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotalByIDAndSpan.funcGetTotalByIDAndSpan != nil {
		return mmGetTotalByIDAndSpan.funcGetTotalByIDAndSpan(ctx, ua1, t1, t2, b1)
	}
	mmGetTotalByIDAndSpan.t.Fatalf("Unexpected call to IPostRepositoryMock.GetTotalByIDAndSpan. %v %v %v %v %v", ctx, ua1, t1, t2, b1)
	return
}

// GetTotalByIDAndSpanAfterCounter returns a count of finished IPostRepositoryMock.GetTotalByIDAndSpan invocations
func (mmGetTotalByIDAndSpan *IPostRepositoryMock) GetTotalByIDAndSpanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByIDAndSpan.afterGetTotalByIDAndSpanCounter)
}

// GetTotalByIDAndSpanBeforeCounter returns a count of IPostRepositoryMock.GetTotalByIDAndSpan invocations
func (mmGetTotalByIDAndSpan *IPostRepositoryMock) GetTotalByIDAndSpanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByIDAndSpan.beforeGetTotalByIDAndSpanCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetTotalByIDAndSpan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalByIDAndSpan *mIPostRepositoryMockGetTotalByIDAndSpan) Calls() []*IPostRepositoryMockGetTotalByIDAndSpanParams {
	mmGetTotalByIDAndSpan.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetTotalByIDAndSpanParams, len(mmGetTotalByIDAndSpan.callArgs))
	copy(argCopy, mmGetTotalByIDAndSpan.callArgs)

	mmGetTotalByIDAndSpan.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalByIDAndSpanDone returns true if the count of the GetTotalByIDAndSpan invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetTotalByIDAndSpanDone() bool {
	for _, e := range m.GetTotalByIDAndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByIDAndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByIDAndSpanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByIDAndSpan != nil && mm_atomic.LoadUint64(&m.afterGetTotalByIDAndSpanCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalByIDAndSpanInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetTotalByIDAndSpanInspect() {
	for _, e := range m.GetTotalByIDAndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetTotalByIDAndSpan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByIDAndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByIDAndSpanCounter) < 1 {
		if m.GetTotalByIDAndSpanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetTotalByIDAndSpan")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetTotalByIDAndSpan with params: %#v", *m.GetTotalByIDAndSpanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByIDAndSpan != nil && mm_atomic.LoadUint64(&m.afterGetTotalByIDAndSpanCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetTotalByIDAndSpan")
	}
}

type mIPostRepositoryMockGetTotalByUserID struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockGetTotalByUserIDExpectation
	expectations       []*IPostRepositoryMockGetTotalByUserIDExpectation

	callArgs []*IPostRepositoryMockGetTotalByUserIDParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockGetTotalByUserIDExpectation specifies expectation struct of the IPostRepository.GetTotalByUserID
type IPostRepositoryMockGetTotalByUserIDExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockGetTotalByUserIDParams
	results *IPostRepositoryMockGetTotalByUserIDResults
	Counter uint64
}

// IPostRepositoryMockGetTotalByUserIDParams contains parameters of the IPostRepository.GetTotalByUserID
type IPostRepositoryMockGetTotalByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// IPostRepositoryMockGetTotalByUserIDResults contains results of the IPostRepository.GetTotalByUserID
type IPostRepositoryMockGetTotalByUserIDResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IPostRepository.GetTotalByUserID
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) Expect(ctx context.Context, userID uuid.UUID) *mIPostRepositoryMockGetTotalByUserID {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostRepositoryMock.GetTotalByUserID mock is already set by Set")
	}

	if mmGetTotalByUserID.defaultExpectation == nil {
		mmGetTotalByUserID.defaultExpectation = &IPostRepositoryMockGetTotalByUserIDExpectation{}
	}

	mmGetTotalByUserID.defaultExpectation.params = &IPostRepositoryMockGetTotalByUserIDParams{ctx, userID}
	for _, e := range mmGetTotalByUserID.expectations {
		if minimock.Equal(e.params, mmGetTotalByUserID.defaultExpectation.params) {
			mmGetTotalByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalByUserID.defaultExpectation.params)
		}
	}

	return mmGetTotalByUserID
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.GetTotalByUserID
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mIPostRepositoryMockGetTotalByUserID {
	if mmGetTotalByUserID.mock.inspectFuncGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.GetTotalByUserID")
	}

	mmGetTotalByUserID.mock.inspectFuncGetTotalByUserID = f

	return mmGetTotalByUserID
}

// Return sets up results that will be returned by IPostRepository.GetTotalByUserID
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) Return(i1 int, err error) *IPostRepositoryMock {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostRepositoryMock.GetTotalByUserID mock is already set by Set")
	}

	if mmGetTotalByUserID.defaultExpectation == nil {
		mmGetTotalByUserID.defaultExpectation = &IPostRepositoryMockGetTotalByUserIDExpectation{mock: mmGetTotalByUserID.mock}
	}
	mmGetTotalByUserID.defaultExpectation.results = &IPostRepositoryMockGetTotalByUserIDResults{i1, err}
	return mmGetTotalByUserID.mock
}

// Set uses given function f to mock the IPostRepository.GetTotalByUserID method
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (i1 int, err error)) *IPostRepositoryMock {
	if mmGetTotalByUserID.defaultExpectation != nil {
		mmGetTotalByUserID.mock.t.Fatalf("Default expectation is already set for the IPostRepository.GetTotalByUserID method")
	}

	if len(mmGetTotalByUserID.expectations) > 0 {
		mmGetTotalByUserID.mock.t.Fatalf("Some expectations are already set for the IPostRepository.GetTotalByUserID method")
	}

	mmGetTotalByUserID.mock.funcGetTotalByUserID = f
	return mmGetTotalByUserID.mock
}

// When sets expectation for the IPostRepository.GetTotalByUserID which will trigger the result defined by the following
// Then helper
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) When(ctx context.Context, userID uuid.UUID) *IPostRepositoryMockGetTotalByUserIDExpectation {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostRepositoryMock.GetTotalByUserID mock is already set by Set")
	}

	expectation := &IPostRepositoryMockGetTotalByUserIDExpectation{
		mock:   mmGetTotalByUserID.mock,
		params: &IPostRepositoryMockGetTotalByUserIDParams{ctx, userID},
	}
	mmGetTotalByUserID.expectations = append(mmGetTotalByUserID.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.GetTotalByUserID return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockGetTotalByUserIDExpectation) Then(i1 int, err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockGetTotalByUserIDResults{i1, err}
	return e.mock
}

// GetTotalByUserID implements interfaces.IPostRepository
func (mmGetTotalByUserID *IPostRepositoryMock) GetTotalByUserID(ctx context.Context, userID uuid.UUID) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotalByUserID.beforeGetTotalByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalByUserID.afterGetTotalByUserIDCounter, 1)

	if mmGetTotalByUserID.inspectFuncGetTotalByUserID != nil {
		mmGetTotalByUserID.inspectFuncGetTotalByUserID(ctx, userID)
	}

	mm_params := &IPostRepositoryMockGetTotalByUserIDParams{ctx, userID}

	// Record call args
	mmGetTotalByUserID.GetTotalByUserIDMock.mutex.Lock()
	mmGetTotalByUserID.GetTotalByUserIDMock.callArgs = append(mmGetTotalByUserID.GetTotalByUserIDMock.callArgs, mm_params)
	mmGetTotalByUserID.GetTotalByUserIDMock.mutex.Unlock()

	for _, e := range mmGetTotalByUserID.GetTotalByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.params
		mm_got := IPostRepositoryMockGetTotalByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalByUserID.t.Errorf("IPostRepositoryMock.GetTotalByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalByUserID.t.Fatal("No results are set for the IPostRepositoryMock.GetTotalByUserID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotalByUserID.funcGetTotalByUserID != nil {
		return mmGetTotalByUserID.funcGetTotalByUserID(ctx, userID)
	}
	mmGetTotalByUserID.t.Fatalf("Unexpected call to IPostRepositoryMock.GetTotalByUserID. %v %v", ctx, userID)
	return
}

// GetTotalByUserIDAfterCounter returns a count of finished IPostRepositoryMock.GetTotalByUserID invocations
func (mmGetTotalByUserID *IPostRepositoryMock) GetTotalByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByUserID.afterGetTotalByUserIDCounter)
}

// GetTotalByUserIDBeforeCounter returns a count of IPostRepositoryMock.GetTotalByUserID invocations
func (mmGetTotalByUserID *IPostRepositoryMock) GetTotalByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByUserID.beforeGetTotalByUserIDCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.GetTotalByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalByUserID *mIPostRepositoryMockGetTotalByUserID) Calls() []*IPostRepositoryMockGetTotalByUserIDParams {
	mmGetTotalByUserID.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockGetTotalByUserIDParams, len(mmGetTotalByUserID.callArgs))
	copy(argCopy, mmGetTotalByUserID.callArgs)

	mmGetTotalByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalByUserIDDone returns true if the count of the GetTotalByUserID invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockGetTotalByUserIDDone() bool {
	for _, e := range m.GetTotalByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByUserID != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalByUserIDInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockGetTotalByUserIDInspect() {
	for _, e := range m.GetTotalByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetTotalByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		if m.GetTotalByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.GetTotalByUserID")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.GetTotalByUserID with params: %#v", *m.GetTotalByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByUserID != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.GetTotalByUserID")
	}
}

type mIPostRepositoryMockUpdate struct {
	mock               *IPostRepositoryMock
	defaultExpectation *IPostRepositoryMockUpdateExpectation
	expectations       []*IPostRepositoryMockUpdateExpectation

	callArgs []*IPostRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// IPostRepositoryMockUpdateExpectation specifies expectation struct of the IPostRepository.Update
type IPostRepositoryMockUpdateExpectation struct {
	mock    *IPostRepositoryMock
	params  *IPostRepositoryMockUpdateParams
	results *IPostRepositoryMockUpdateResults
	Counter uint64
}

// IPostRepositoryMockUpdateParams contains parameters of the IPostRepository.Update
type IPostRepositoryMockUpdateParams struct {
	ctx context.Context
	pp1 *models.Post
}

// IPostRepositoryMockUpdateResults contains results of the IPostRepository.Update
type IPostRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for IPostRepository.Update
func (mmUpdate *mIPostRepositoryMockUpdate) Expect(ctx context.Context, pp1 *models.Post) *mIPostRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IPostRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IPostRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &IPostRepositoryMockUpdateParams{ctx, pp1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the IPostRepository.Update
func (mmUpdate *mIPostRepositoryMockUpdate) Inspect(f func(ctx context.Context, pp1 *models.Post)) *mIPostRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for IPostRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by IPostRepository.Update
func (mmUpdate *mIPostRepositoryMockUpdate) Return(err error) *IPostRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IPostRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IPostRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &IPostRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the IPostRepository.Update method
func (mmUpdate *mIPostRepositoryMockUpdate) Set(f func(ctx context.Context, pp1 *models.Post) (err error)) *IPostRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the IPostRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the IPostRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the IPostRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mIPostRepositoryMockUpdate) When(ctx context.Context, pp1 *models.Post) *IPostRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IPostRepositoryMock.Update mock is already set by Set")
	}

	expectation := &IPostRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &IPostRepositoryMockUpdateParams{ctx, pp1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up IPostRepository.Update return parameters for the expectation previously defined by the When method
func (e *IPostRepositoryMockUpdateExpectation) Then(err error) *IPostRepositoryMock {
	e.results = &IPostRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements interfaces.IPostRepository
func (mmUpdate *IPostRepositoryMock) Update(ctx context.Context, pp1 *models.Post) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, pp1)
	}

	mm_params := &IPostRepositoryMockUpdateParams{ctx, pp1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := IPostRepositoryMockUpdateParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("IPostRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the IPostRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, pp1)
	}
	mmUpdate.t.Fatalf("Unexpected call to IPostRepositoryMock.Update. %v %v", ctx, pp1)
	return
}

// UpdateAfterCounter returns a count of finished IPostRepositoryMock.Update invocations
func (mmUpdate *IPostRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of IPostRepositoryMock.Update invocations
func (mmUpdate *IPostRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to IPostRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mIPostRepositoryMockUpdate) Calls() []*IPostRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*IPostRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *IPostRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *IPostRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to IPostRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to IPostRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPostRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()

		m.MinimockGetByIDAndSpanInspect()

		m.MinimockGetReactionTypesInspect()

		m.MinimockGetSortedLimitsInspect()

		m.MinimockGetTotalByIDAndSpanInspect()

		m.MinimockGetTotalByUserIDInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPostRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPostRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByIDAndSpanDone() &&
		m.MinimockGetReactionTypesDone() &&
		m.MinimockGetSortedLimitsDone() &&
		m.MinimockGetTotalByIDAndSpanDone() &&
		m.MinimockGetTotalByUserIDDone() &&
		m.MinimockUpdateDone()
}

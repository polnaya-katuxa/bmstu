package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IBalanceTransactionLogic -o ./internal/mocks/i_balance_transaction_logic_mock_test.go -n IBalanceTransactionLogicMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IBalanceTransactionLogicMock implements interfaces.IBalanceTransactionLogic
type IBalanceTransactionLogicMock struct {
	t minimock.Tester

	funcDecrease          func(ctx context.Context, i1 int, s1 string) (err error)
	inspectFuncDecrease   func(ctx context.Context, i1 int, s1 string)
	afterDecreaseCounter  uint64
	beforeDecreaseCounter uint64
	DecreaseMock          mIBalanceTransactionLogicMockDecrease

	funcIncrease          func(ctx context.Context, i1 int, s1 string) (err error)
	inspectFuncIncrease   func(ctx context.Context, i1 int, s1 string)
	afterIncreaseCounter  uint64
	beforeIncreaseCounter uint64
	IncreaseMock          mIBalanceTransactionLogicMockIncrease

	funcIncreaseSub          func(ctx context.Context, value int, userID uuid.UUID) (err error)
	inspectFuncIncreaseSub   func(ctx context.Context, value int, userID uuid.UUID)
	afterIncreaseSubCounter  uint64
	beforeIncreaseSubCounter uint64
	IncreaseSubMock          mIBalanceTransactionLogicMockIncreaseSub
}

// NewIBalanceTransactionLogicMock returns a mock for interfaces.IBalanceTransactionLogic
func NewIBalanceTransactionLogicMock(t minimock.Tester) *IBalanceTransactionLogicMock {
	m := &IBalanceTransactionLogicMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DecreaseMock = mIBalanceTransactionLogicMockDecrease{mock: m}
	m.DecreaseMock.callArgs = []*IBalanceTransactionLogicMockDecreaseParams{}

	m.IncreaseMock = mIBalanceTransactionLogicMockIncrease{mock: m}
	m.IncreaseMock.callArgs = []*IBalanceTransactionLogicMockIncreaseParams{}

	m.IncreaseSubMock = mIBalanceTransactionLogicMockIncreaseSub{mock: m}
	m.IncreaseSubMock.callArgs = []*IBalanceTransactionLogicMockIncreaseSubParams{}

	return m
}

type mIBalanceTransactionLogicMockDecrease struct {
	mock               *IBalanceTransactionLogicMock
	defaultExpectation *IBalanceTransactionLogicMockDecreaseExpectation
	expectations       []*IBalanceTransactionLogicMockDecreaseExpectation

	callArgs []*IBalanceTransactionLogicMockDecreaseParams
	mutex    sync.RWMutex
}

// IBalanceTransactionLogicMockDecreaseExpectation specifies expectation struct of the IBalanceTransactionLogic.Decrease
type IBalanceTransactionLogicMockDecreaseExpectation struct {
	mock    *IBalanceTransactionLogicMock
	params  *IBalanceTransactionLogicMockDecreaseParams
	results *IBalanceTransactionLogicMockDecreaseResults
	Counter uint64
}

// IBalanceTransactionLogicMockDecreaseParams contains parameters of the IBalanceTransactionLogic.Decrease
type IBalanceTransactionLogicMockDecreaseParams struct {
	ctx context.Context
	i1  int
	s1  string
}

// IBalanceTransactionLogicMockDecreaseResults contains results of the IBalanceTransactionLogic.Decrease
type IBalanceTransactionLogicMockDecreaseResults struct {
	err error
}

// Expect sets up expected params for IBalanceTransactionLogic.Decrease
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) Expect(ctx context.Context, i1 int, s1 string) *mIBalanceTransactionLogicMockDecrease {
	if mmDecrease.mock.funcDecrease != nil {
		mmDecrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Decrease mock is already set by Set")
	}

	if mmDecrease.defaultExpectation == nil {
		mmDecrease.defaultExpectation = &IBalanceTransactionLogicMockDecreaseExpectation{}
	}

	mmDecrease.defaultExpectation.params = &IBalanceTransactionLogicMockDecreaseParams{ctx, i1, s1}
	for _, e := range mmDecrease.expectations {
		if minimock.Equal(e.params, mmDecrease.defaultExpectation.params) {
			mmDecrease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecrease.defaultExpectation.params)
		}
	}

	return mmDecrease
}

// Inspect accepts an inspector function that has same arguments as the IBalanceTransactionLogic.Decrease
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) Inspect(f func(ctx context.Context, i1 int, s1 string)) *mIBalanceTransactionLogicMockDecrease {
	if mmDecrease.mock.inspectFuncDecrease != nil {
		mmDecrease.mock.t.Fatalf("Inspect function is already set for IBalanceTransactionLogicMock.Decrease")
	}

	mmDecrease.mock.inspectFuncDecrease = f

	return mmDecrease
}

// Return sets up results that will be returned by IBalanceTransactionLogic.Decrease
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) Return(err error) *IBalanceTransactionLogicMock {
	if mmDecrease.mock.funcDecrease != nil {
		mmDecrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Decrease mock is already set by Set")
	}

	if mmDecrease.defaultExpectation == nil {
		mmDecrease.defaultExpectation = &IBalanceTransactionLogicMockDecreaseExpectation{mock: mmDecrease.mock}
	}
	mmDecrease.defaultExpectation.results = &IBalanceTransactionLogicMockDecreaseResults{err}
	return mmDecrease.mock
}

// Set uses given function f to mock the IBalanceTransactionLogic.Decrease method
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) Set(f func(ctx context.Context, i1 int, s1 string) (err error)) *IBalanceTransactionLogicMock {
	if mmDecrease.defaultExpectation != nil {
		mmDecrease.mock.t.Fatalf("Default expectation is already set for the IBalanceTransactionLogic.Decrease method")
	}

	if len(mmDecrease.expectations) > 0 {
		mmDecrease.mock.t.Fatalf("Some expectations are already set for the IBalanceTransactionLogic.Decrease method")
	}

	mmDecrease.mock.funcDecrease = f
	return mmDecrease.mock
}

// When sets expectation for the IBalanceTransactionLogic.Decrease which will trigger the result defined by the following
// Then helper
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) When(ctx context.Context, i1 int, s1 string) *IBalanceTransactionLogicMockDecreaseExpectation {
	if mmDecrease.mock.funcDecrease != nil {
		mmDecrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Decrease mock is already set by Set")
	}

	expectation := &IBalanceTransactionLogicMockDecreaseExpectation{
		mock:   mmDecrease.mock,
		params: &IBalanceTransactionLogicMockDecreaseParams{ctx, i1, s1},
	}
	mmDecrease.expectations = append(mmDecrease.expectations, expectation)
	return expectation
}

// Then sets up IBalanceTransactionLogic.Decrease return parameters for the expectation previously defined by the When method
func (e *IBalanceTransactionLogicMockDecreaseExpectation) Then(err error) *IBalanceTransactionLogicMock {
	e.results = &IBalanceTransactionLogicMockDecreaseResults{err}
	return e.mock
}

// Decrease implements interfaces.IBalanceTransactionLogic
func (mmDecrease *IBalanceTransactionLogicMock) Decrease(ctx context.Context, i1 int, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDecrease.beforeDecreaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDecrease.afterDecreaseCounter, 1)

	if mmDecrease.inspectFuncDecrease != nil {
		mmDecrease.inspectFuncDecrease(ctx, i1, s1)
	}

	mm_params := &IBalanceTransactionLogicMockDecreaseParams{ctx, i1, s1}

	// Record call args
	mmDecrease.DecreaseMock.mutex.Lock()
	mmDecrease.DecreaseMock.callArgs = append(mmDecrease.DecreaseMock.callArgs, mm_params)
	mmDecrease.DecreaseMock.mutex.Unlock()

	for _, e := range mmDecrease.DecreaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecrease.DecreaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecrease.DecreaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDecrease.DecreaseMock.defaultExpectation.params
		mm_got := IBalanceTransactionLogicMockDecreaseParams{ctx, i1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecrease.t.Errorf("IBalanceTransactionLogicMock.Decrease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecrease.DecreaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDecrease.t.Fatal("No results are set for the IBalanceTransactionLogicMock.Decrease")
		}
		return (*mm_results).err
	}
	if mmDecrease.funcDecrease != nil {
		return mmDecrease.funcDecrease(ctx, i1, s1)
	}
	mmDecrease.t.Fatalf("Unexpected call to IBalanceTransactionLogicMock.Decrease. %v %v %v", ctx, i1, s1)
	return
}

// DecreaseAfterCounter returns a count of finished IBalanceTransactionLogicMock.Decrease invocations
func (mmDecrease *IBalanceTransactionLogicMock) DecreaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrease.afterDecreaseCounter)
}

// DecreaseBeforeCounter returns a count of IBalanceTransactionLogicMock.Decrease invocations
func (mmDecrease *IBalanceTransactionLogicMock) DecreaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrease.beforeDecreaseCounter)
}

// Calls returns a list of arguments used in each call to IBalanceTransactionLogicMock.Decrease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecrease *mIBalanceTransactionLogicMockDecrease) Calls() []*IBalanceTransactionLogicMockDecreaseParams {
	mmDecrease.mutex.RLock()

	argCopy := make([]*IBalanceTransactionLogicMockDecreaseParams, len(mmDecrease.callArgs))
	copy(argCopy, mmDecrease.callArgs)

	mmDecrease.mutex.RUnlock()

	return argCopy
}

// MinimockDecreaseDone returns true if the count of the Decrease invocations corresponds
// the number of defined expectations
func (m *IBalanceTransactionLogicMock) MinimockDecreaseDone() bool {
	for _, e := range m.DecreaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecrease != nil && mm_atomic.LoadUint64(&m.afterDecreaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecreaseInspect logs each unmet expectation
func (m *IBalanceTransactionLogicMock) MinimockDecreaseInspect() {
	for _, e := range m.DecreaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.Decrease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseCounter) < 1 {
		if m.DecreaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBalanceTransactionLogicMock.Decrease")
		} else {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.Decrease with params: %#v", *m.DecreaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecrease != nil && mm_atomic.LoadUint64(&m.afterDecreaseCounter) < 1 {
		m.t.Error("Expected call to IBalanceTransactionLogicMock.Decrease")
	}
}

type mIBalanceTransactionLogicMockIncrease struct {
	mock               *IBalanceTransactionLogicMock
	defaultExpectation *IBalanceTransactionLogicMockIncreaseExpectation
	expectations       []*IBalanceTransactionLogicMockIncreaseExpectation

	callArgs []*IBalanceTransactionLogicMockIncreaseParams
	mutex    sync.RWMutex
}

// IBalanceTransactionLogicMockIncreaseExpectation specifies expectation struct of the IBalanceTransactionLogic.Increase
type IBalanceTransactionLogicMockIncreaseExpectation struct {
	mock    *IBalanceTransactionLogicMock
	params  *IBalanceTransactionLogicMockIncreaseParams
	results *IBalanceTransactionLogicMockIncreaseResults
	Counter uint64
}

// IBalanceTransactionLogicMockIncreaseParams contains parameters of the IBalanceTransactionLogic.Increase
type IBalanceTransactionLogicMockIncreaseParams struct {
	ctx context.Context
	i1  int
	s1  string
}

// IBalanceTransactionLogicMockIncreaseResults contains results of the IBalanceTransactionLogic.Increase
type IBalanceTransactionLogicMockIncreaseResults struct {
	err error
}

// Expect sets up expected params for IBalanceTransactionLogic.Increase
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) Expect(ctx context.Context, i1 int, s1 string) *mIBalanceTransactionLogicMockIncrease {
	if mmIncrease.mock.funcIncrease != nil {
		mmIncrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Increase mock is already set by Set")
	}

	if mmIncrease.defaultExpectation == nil {
		mmIncrease.defaultExpectation = &IBalanceTransactionLogicMockIncreaseExpectation{}
	}

	mmIncrease.defaultExpectation.params = &IBalanceTransactionLogicMockIncreaseParams{ctx, i1, s1}
	for _, e := range mmIncrease.expectations {
		if minimock.Equal(e.params, mmIncrease.defaultExpectation.params) {
			mmIncrease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncrease.defaultExpectation.params)
		}
	}

	return mmIncrease
}

// Inspect accepts an inspector function that has same arguments as the IBalanceTransactionLogic.Increase
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) Inspect(f func(ctx context.Context, i1 int, s1 string)) *mIBalanceTransactionLogicMockIncrease {
	if mmIncrease.mock.inspectFuncIncrease != nil {
		mmIncrease.mock.t.Fatalf("Inspect function is already set for IBalanceTransactionLogicMock.Increase")
	}

	mmIncrease.mock.inspectFuncIncrease = f

	return mmIncrease
}

// Return sets up results that will be returned by IBalanceTransactionLogic.Increase
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) Return(err error) *IBalanceTransactionLogicMock {
	if mmIncrease.mock.funcIncrease != nil {
		mmIncrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Increase mock is already set by Set")
	}

	if mmIncrease.defaultExpectation == nil {
		mmIncrease.defaultExpectation = &IBalanceTransactionLogicMockIncreaseExpectation{mock: mmIncrease.mock}
	}
	mmIncrease.defaultExpectation.results = &IBalanceTransactionLogicMockIncreaseResults{err}
	return mmIncrease.mock
}

// Set uses given function f to mock the IBalanceTransactionLogic.Increase method
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) Set(f func(ctx context.Context, i1 int, s1 string) (err error)) *IBalanceTransactionLogicMock {
	if mmIncrease.defaultExpectation != nil {
		mmIncrease.mock.t.Fatalf("Default expectation is already set for the IBalanceTransactionLogic.Increase method")
	}

	if len(mmIncrease.expectations) > 0 {
		mmIncrease.mock.t.Fatalf("Some expectations are already set for the IBalanceTransactionLogic.Increase method")
	}

	mmIncrease.mock.funcIncrease = f
	return mmIncrease.mock
}

// When sets expectation for the IBalanceTransactionLogic.Increase which will trigger the result defined by the following
// Then helper
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) When(ctx context.Context, i1 int, s1 string) *IBalanceTransactionLogicMockIncreaseExpectation {
	if mmIncrease.mock.funcIncrease != nil {
		mmIncrease.mock.t.Fatalf("IBalanceTransactionLogicMock.Increase mock is already set by Set")
	}

	expectation := &IBalanceTransactionLogicMockIncreaseExpectation{
		mock:   mmIncrease.mock,
		params: &IBalanceTransactionLogicMockIncreaseParams{ctx, i1, s1},
	}
	mmIncrease.expectations = append(mmIncrease.expectations, expectation)
	return expectation
}

// Then sets up IBalanceTransactionLogic.Increase return parameters for the expectation previously defined by the When method
func (e *IBalanceTransactionLogicMockIncreaseExpectation) Then(err error) *IBalanceTransactionLogicMock {
	e.results = &IBalanceTransactionLogicMockIncreaseResults{err}
	return e.mock
}

// Increase implements interfaces.IBalanceTransactionLogic
func (mmIncrease *IBalanceTransactionLogicMock) Increase(ctx context.Context, i1 int, s1 string) (err error) {
	mm_atomic.AddUint64(&mmIncrease.beforeIncreaseCounter, 1)
	defer mm_atomic.AddUint64(&mmIncrease.afterIncreaseCounter, 1)

	if mmIncrease.inspectFuncIncrease != nil {
		mmIncrease.inspectFuncIncrease(ctx, i1, s1)
	}

	mm_params := &IBalanceTransactionLogicMockIncreaseParams{ctx, i1, s1}

	// Record call args
	mmIncrease.IncreaseMock.mutex.Lock()
	mmIncrease.IncreaseMock.callArgs = append(mmIncrease.IncreaseMock.callArgs, mm_params)
	mmIncrease.IncreaseMock.mutex.Unlock()

	for _, e := range mmIncrease.IncreaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncrease.IncreaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncrease.IncreaseMock.defaultExpectation.Counter, 1)
		mm_want := mmIncrease.IncreaseMock.defaultExpectation.params
		mm_got := IBalanceTransactionLogicMockIncreaseParams{ctx, i1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncrease.t.Errorf("IBalanceTransactionLogicMock.Increase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncrease.IncreaseMock.defaultExpectation.results
		if mm_results == nil {
			mmIncrease.t.Fatal("No results are set for the IBalanceTransactionLogicMock.Increase")
		}
		return (*mm_results).err
	}
	if mmIncrease.funcIncrease != nil {
		return mmIncrease.funcIncrease(ctx, i1, s1)
	}
	mmIncrease.t.Fatalf("Unexpected call to IBalanceTransactionLogicMock.Increase. %v %v %v", ctx, i1, s1)
	return
}

// IncreaseAfterCounter returns a count of finished IBalanceTransactionLogicMock.Increase invocations
func (mmIncrease *IBalanceTransactionLogicMock) IncreaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncrease.afterIncreaseCounter)
}

// IncreaseBeforeCounter returns a count of IBalanceTransactionLogicMock.Increase invocations
func (mmIncrease *IBalanceTransactionLogicMock) IncreaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncrease.beforeIncreaseCounter)
}

// Calls returns a list of arguments used in each call to IBalanceTransactionLogicMock.Increase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncrease *mIBalanceTransactionLogicMockIncrease) Calls() []*IBalanceTransactionLogicMockIncreaseParams {
	mmIncrease.mutex.RLock()

	argCopy := make([]*IBalanceTransactionLogicMockIncreaseParams, len(mmIncrease.callArgs))
	copy(argCopy, mmIncrease.callArgs)

	mmIncrease.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseDone returns true if the count of the Increase invocations corresponds
// the number of defined expectations
func (m *IBalanceTransactionLogicMock) MinimockIncreaseDone() bool {
	for _, e := range m.IncreaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncrease != nil && mm_atomic.LoadUint64(&m.afterIncreaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockIncreaseInspect logs each unmet expectation
func (m *IBalanceTransactionLogicMock) MinimockIncreaseInspect() {
	for _, e := range m.IncreaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.Increase with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseCounter) < 1 {
		if m.IncreaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBalanceTransactionLogicMock.Increase")
		} else {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.Increase with params: %#v", *m.IncreaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncrease != nil && mm_atomic.LoadUint64(&m.afterIncreaseCounter) < 1 {
		m.t.Error("Expected call to IBalanceTransactionLogicMock.Increase")
	}
}

type mIBalanceTransactionLogicMockIncreaseSub struct {
	mock               *IBalanceTransactionLogicMock
	defaultExpectation *IBalanceTransactionLogicMockIncreaseSubExpectation
	expectations       []*IBalanceTransactionLogicMockIncreaseSubExpectation

	callArgs []*IBalanceTransactionLogicMockIncreaseSubParams
	mutex    sync.RWMutex
}

// IBalanceTransactionLogicMockIncreaseSubExpectation specifies expectation struct of the IBalanceTransactionLogic.IncreaseSub
type IBalanceTransactionLogicMockIncreaseSubExpectation struct {
	mock    *IBalanceTransactionLogicMock
	params  *IBalanceTransactionLogicMockIncreaseSubParams
	results *IBalanceTransactionLogicMockIncreaseSubResults
	Counter uint64
}

// IBalanceTransactionLogicMockIncreaseSubParams contains parameters of the IBalanceTransactionLogic.IncreaseSub
type IBalanceTransactionLogicMockIncreaseSubParams struct {
	ctx    context.Context
	value  int
	userID uuid.UUID
}

// IBalanceTransactionLogicMockIncreaseSubResults contains results of the IBalanceTransactionLogic.IncreaseSub
type IBalanceTransactionLogicMockIncreaseSubResults struct {
	err error
}

// Expect sets up expected params for IBalanceTransactionLogic.IncreaseSub
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) Expect(ctx context.Context, value int, userID uuid.UUID) *mIBalanceTransactionLogicMockIncreaseSub {
	if mmIncreaseSub.mock.funcIncreaseSub != nil {
		mmIncreaseSub.mock.t.Fatalf("IBalanceTransactionLogicMock.IncreaseSub mock is already set by Set")
	}

	if mmIncreaseSub.defaultExpectation == nil {
		mmIncreaseSub.defaultExpectation = &IBalanceTransactionLogicMockIncreaseSubExpectation{}
	}

	mmIncreaseSub.defaultExpectation.params = &IBalanceTransactionLogicMockIncreaseSubParams{ctx, value, userID}
	for _, e := range mmIncreaseSub.expectations {
		if minimock.Equal(e.params, mmIncreaseSub.defaultExpectation.params) {
			mmIncreaseSub.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseSub.defaultExpectation.params)
		}
	}

	return mmIncreaseSub
}

// Inspect accepts an inspector function that has same arguments as the IBalanceTransactionLogic.IncreaseSub
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) Inspect(f func(ctx context.Context, value int, userID uuid.UUID)) *mIBalanceTransactionLogicMockIncreaseSub {
	if mmIncreaseSub.mock.inspectFuncIncreaseSub != nil {
		mmIncreaseSub.mock.t.Fatalf("Inspect function is already set for IBalanceTransactionLogicMock.IncreaseSub")
	}

	mmIncreaseSub.mock.inspectFuncIncreaseSub = f

	return mmIncreaseSub
}

// Return sets up results that will be returned by IBalanceTransactionLogic.IncreaseSub
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) Return(err error) *IBalanceTransactionLogicMock {
	if mmIncreaseSub.mock.funcIncreaseSub != nil {
		mmIncreaseSub.mock.t.Fatalf("IBalanceTransactionLogicMock.IncreaseSub mock is already set by Set")
	}

	if mmIncreaseSub.defaultExpectation == nil {
		mmIncreaseSub.defaultExpectation = &IBalanceTransactionLogicMockIncreaseSubExpectation{mock: mmIncreaseSub.mock}
	}
	mmIncreaseSub.defaultExpectation.results = &IBalanceTransactionLogicMockIncreaseSubResults{err}
	return mmIncreaseSub.mock
}

// Set uses given function f to mock the IBalanceTransactionLogic.IncreaseSub method
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) Set(f func(ctx context.Context, value int, userID uuid.UUID) (err error)) *IBalanceTransactionLogicMock {
	if mmIncreaseSub.defaultExpectation != nil {
		mmIncreaseSub.mock.t.Fatalf("Default expectation is already set for the IBalanceTransactionLogic.IncreaseSub method")
	}

	if len(mmIncreaseSub.expectations) > 0 {
		mmIncreaseSub.mock.t.Fatalf("Some expectations are already set for the IBalanceTransactionLogic.IncreaseSub method")
	}

	mmIncreaseSub.mock.funcIncreaseSub = f
	return mmIncreaseSub.mock
}

// When sets expectation for the IBalanceTransactionLogic.IncreaseSub which will trigger the result defined by the following
// Then helper
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) When(ctx context.Context, value int, userID uuid.UUID) *IBalanceTransactionLogicMockIncreaseSubExpectation {
	if mmIncreaseSub.mock.funcIncreaseSub != nil {
		mmIncreaseSub.mock.t.Fatalf("IBalanceTransactionLogicMock.IncreaseSub mock is already set by Set")
	}

	expectation := &IBalanceTransactionLogicMockIncreaseSubExpectation{
		mock:   mmIncreaseSub.mock,
		params: &IBalanceTransactionLogicMockIncreaseSubParams{ctx, value, userID},
	}
	mmIncreaseSub.expectations = append(mmIncreaseSub.expectations, expectation)
	return expectation
}

// Then sets up IBalanceTransactionLogic.IncreaseSub return parameters for the expectation previously defined by the When method
func (e *IBalanceTransactionLogicMockIncreaseSubExpectation) Then(err error) *IBalanceTransactionLogicMock {
	e.results = &IBalanceTransactionLogicMockIncreaseSubResults{err}
	return e.mock
}

// IncreaseSub implements interfaces.IBalanceTransactionLogic
func (mmIncreaseSub *IBalanceTransactionLogicMock) IncreaseSub(ctx context.Context, value int, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmIncreaseSub.beforeIncreaseSubCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseSub.afterIncreaseSubCounter, 1)

	if mmIncreaseSub.inspectFuncIncreaseSub != nil {
		mmIncreaseSub.inspectFuncIncreaseSub(ctx, value, userID)
	}

	mm_params := &IBalanceTransactionLogicMockIncreaseSubParams{ctx, value, userID}

	// Record call args
	mmIncreaseSub.IncreaseSubMock.mutex.Lock()
	mmIncreaseSub.IncreaseSubMock.callArgs = append(mmIncreaseSub.IncreaseSubMock.callArgs, mm_params)
	mmIncreaseSub.IncreaseSubMock.mutex.Unlock()

	for _, e := range mmIncreaseSub.IncreaseSubMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseSub.IncreaseSubMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseSub.IncreaseSubMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseSub.IncreaseSubMock.defaultExpectation.params
		mm_got := IBalanceTransactionLogicMockIncreaseSubParams{ctx, value, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseSub.t.Errorf("IBalanceTransactionLogicMock.IncreaseSub got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseSub.IncreaseSubMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseSub.t.Fatal("No results are set for the IBalanceTransactionLogicMock.IncreaseSub")
		}
		return (*mm_results).err
	}
	if mmIncreaseSub.funcIncreaseSub != nil {
		return mmIncreaseSub.funcIncreaseSub(ctx, value, userID)
	}
	mmIncreaseSub.t.Fatalf("Unexpected call to IBalanceTransactionLogicMock.IncreaseSub. %v %v %v", ctx, value, userID)
	return
}

// IncreaseSubAfterCounter returns a count of finished IBalanceTransactionLogicMock.IncreaseSub invocations
func (mmIncreaseSub *IBalanceTransactionLogicMock) IncreaseSubAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseSub.afterIncreaseSubCounter)
}

// IncreaseSubBeforeCounter returns a count of IBalanceTransactionLogicMock.IncreaseSub invocations
func (mmIncreaseSub *IBalanceTransactionLogicMock) IncreaseSubBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseSub.beforeIncreaseSubCounter)
}

// Calls returns a list of arguments used in each call to IBalanceTransactionLogicMock.IncreaseSub.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseSub *mIBalanceTransactionLogicMockIncreaseSub) Calls() []*IBalanceTransactionLogicMockIncreaseSubParams {
	mmIncreaseSub.mutex.RLock()

	argCopy := make([]*IBalanceTransactionLogicMockIncreaseSubParams, len(mmIncreaseSub.callArgs))
	copy(argCopy, mmIncreaseSub.callArgs)

	mmIncreaseSub.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseSubDone returns true if the count of the IncreaseSub invocations corresponds
// the number of defined expectations
func (m *IBalanceTransactionLogicMock) MinimockIncreaseSubDone() bool {
	for _, e := range m.IncreaseSubMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseSubMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseSubCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseSub != nil && mm_atomic.LoadUint64(&m.afterIncreaseSubCounter) < 1 {
		return false
	}
	return true
}

// MinimockIncreaseSubInspect logs each unmet expectation
func (m *IBalanceTransactionLogicMock) MinimockIncreaseSubInspect() {
	for _, e := range m.IncreaseSubMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.IncreaseSub with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseSubMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseSubCounter) < 1 {
		if m.IncreaseSubMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBalanceTransactionLogicMock.IncreaseSub")
		} else {
			m.t.Errorf("Expected call to IBalanceTransactionLogicMock.IncreaseSub with params: %#v", *m.IncreaseSubMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseSub != nil && mm_atomic.LoadUint64(&m.afterIncreaseSubCounter) < 1 {
		m.t.Error("Expected call to IBalanceTransactionLogicMock.IncreaseSub")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IBalanceTransactionLogicMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDecreaseInspect()

		m.MinimockIncreaseInspect()

		m.MinimockIncreaseSubInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IBalanceTransactionLogicMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IBalanceTransactionLogicMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDecreaseDone() &&
		m.MinimockIncreaseDone() &&
		m.MinimockIncreaseSubDone()
}

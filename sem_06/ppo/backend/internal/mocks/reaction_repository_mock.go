package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IReactionRepository -o ./internal/mocks/i_reaction_repository_mock_test.go -n IReactionRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IReactionRepositoryMock implements interfaces.IReactionRepository
type IReactionRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error)
	inspectFuncCreate   func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mIReactionRepositoryMockCreate

	funcDelete          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIReactionRepositoryMockDelete

	funcGetAll          func(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mIReactionRepositoryMockGetAll

	funcReacted          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (b1 bool, err error)
	inspectFuncReacted   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID)
	afterReactedCounter  uint64
	beforeReactedCounter uint64
	ReactedMock          mIReactionRepositoryMockReacted
}

// NewIReactionRepositoryMock returns a mock for interfaces.IReactionRepository
func NewIReactionRepositoryMock(t minimock.Tester) *IReactionRepositoryMock {
	m := &IReactionRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mIReactionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*IReactionRepositoryMockCreateParams{}

	m.DeleteMock = mIReactionRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IReactionRepositoryMockDeleteParams{}

	m.GetAllMock = mIReactionRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*IReactionRepositoryMockGetAllParams{}

	m.ReactedMock = mIReactionRepositoryMockReacted{mock: m}
	m.ReactedMock.callArgs = []*IReactionRepositoryMockReactedParams{}

	return m
}

type mIReactionRepositoryMockCreate struct {
	mock               *IReactionRepositoryMock
	defaultExpectation *IReactionRepositoryMockCreateExpectation
	expectations       []*IReactionRepositoryMockCreateExpectation

	callArgs []*IReactionRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// IReactionRepositoryMockCreateExpectation specifies expectation struct of the IReactionRepository.Create
type IReactionRepositoryMockCreateExpectation struct {
	mock    *IReactionRepositoryMock
	params  *IReactionRepositoryMockCreateParams
	results *IReactionRepositoryMockCreateResults
	Counter uint64
}

// IReactionRepositoryMockCreateParams contains parameters of the IReactionRepository.Create
type IReactionRepositoryMockCreateParams struct {
	ctx context.Context
	rp1 *models.Reaction
	u1  uuid.UUID
}

// IReactionRepositoryMockCreateResults contains results of the IReactionRepository.Create
type IReactionRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for IReactionRepository.Create
func (mmCreate *mIReactionRepositoryMockCreate) Expect(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) *mIReactionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IReactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IReactionRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &IReactionRepositoryMockCreateParams{ctx, rp1, u1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the IReactionRepository.Create
func (mmCreate *mIReactionRepositoryMockCreate) Inspect(f func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID)) *mIReactionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for IReactionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by IReactionRepository.Create
func (mmCreate *mIReactionRepositoryMockCreate) Return(err error) *IReactionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IReactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IReactionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &IReactionRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the IReactionRepository.Create method
func (mmCreate *mIReactionRepositoryMockCreate) Set(f func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error)) *IReactionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the IReactionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the IReactionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the IReactionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mIReactionRepositoryMockCreate) When(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) *IReactionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IReactionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &IReactionRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &IReactionRepositoryMockCreateParams{ctx, rp1, u1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up IReactionRepository.Create return parameters for the expectation previously defined by the When method
func (e *IReactionRepositoryMockCreateExpectation) Then(err error) *IReactionRepositoryMock {
	e.results = &IReactionRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements interfaces.IReactionRepository
func (mmCreate *IReactionRepositoryMock) Create(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, rp1, u1)
	}

	mm_params := &IReactionRepositoryMockCreateParams{ctx, rp1, u1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := IReactionRepositoryMockCreateParams{ctx, rp1, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("IReactionRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the IReactionRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, rp1, u1)
	}
	mmCreate.t.Fatalf("Unexpected call to IReactionRepositoryMock.Create. %v %v %v", ctx, rp1, u1)
	return
}

// CreateAfterCounter returns a count of finished IReactionRepositoryMock.Create invocations
func (mmCreate *IReactionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of IReactionRepositoryMock.Create invocations
func (mmCreate *IReactionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to IReactionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mIReactionRepositoryMockCreate) Calls() []*IReactionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*IReactionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *IReactionRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *IReactionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IReactionRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to IReactionRepositoryMock.Create")
	}
}

type mIReactionRepositoryMockDelete struct {
	mock               *IReactionRepositoryMock
	defaultExpectation *IReactionRepositoryMockDeleteExpectation
	expectations       []*IReactionRepositoryMockDeleteExpectation

	callArgs []*IReactionRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// IReactionRepositoryMockDeleteExpectation specifies expectation struct of the IReactionRepository.Delete
type IReactionRepositoryMockDeleteExpectation struct {
	mock    *IReactionRepositoryMock
	params  *IReactionRepositoryMockDeleteParams
	results *IReactionRepositoryMockDeleteResults
	Counter uint64
}

// IReactionRepositoryMockDeleteParams contains parameters of the IReactionRepository.Delete
type IReactionRepositoryMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
	u3  uuid.UUID
}

// IReactionRepositoryMockDeleteResults contains results of the IReactionRepository.Delete
type IReactionRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IReactionRepository.Delete
func (mmDelete *mIReactionRepositoryMockDelete) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) *mIReactionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IReactionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IReactionRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IReactionRepositoryMockDeleteParams{ctx, u1, u2, u3}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IReactionRepository.Delete
func (mmDelete *mIReactionRepositoryMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID)) *mIReactionRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IReactionRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IReactionRepository.Delete
func (mmDelete *mIReactionRepositoryMockDelete) Return(err error) *IReactionRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IReactionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IReactionRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IReactionRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IReactionRepository.Delete method
func (mmDelete *mIReactionRepositoryMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (err error)) *IReactionRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IReactionRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IReactionRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IReactionRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIReactionRepositoryMockDelete) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) *IReactionRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IReactionRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &IReactionRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IReactionRepositoryMockDeleteParams{ctx, u1, u2, u3},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IReactionRepository.Delete return parameters for the expectation previously defined by the When method
func (e *IReactionRepositoryMockDeleteExpectation) Then(err error) *IReactionRepositoryMock {
	e.results = &IReactionRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IReactionRepository
func (mmDelete *IReactionRepositoryMock) Delete(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1, u2, u3)
	}

	mm_params := &IReactionRepositoryMockDeleteParams{ctx, u1, u2, u3}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IReactionRepositoryMockDeleteParams{ctx, u1, u2, u3}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IReactionRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IReactionRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1, u2, u3)
	}
	mmDelete.t.Fatalf("Unexpected call to IReactionRepositoryMock.Delete. %v %v %v %v", ctx, u1, u2, u3)
	return
}

// DeleteAfterCounter returns a count of finished IReactionRepositoryMock.Delete invocations
func (mmDelete *IReactionRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IReactionRepositoryMock.Delete invocations
func (mmDelete *IReactionRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IReactionRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIReactionRepositoryMockDelete) Calls() []*IReactionRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IReactionRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IReactionRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IReactionRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IReactionRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IReactionRepositoryMock.Delete")
	}
}

type mIReactionRepositoryMockGetAll struct {
	mock               *IReactionRepositoryMock
	defaultExpectation *IReactionRepositoryMockGetAllExpectation
	expectations       []*IReactionRepositoryMockGetAllExpectation

	callArgs []*IReactionRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// IReactionRepositoryMockGetAllExpectation specifies expectation struct of the IReactionRepository.GetAll
type IReactionRepositoryMockGetAllExpectation struct {
	mock    *IReactionRepositoryMock
	params  *IReactionRepositoryMockGetAllParams
	results *IReactionRepositoryMockGetAllResults
	Counter uint64
}

// IReactionRepositoryMockGetAllParams contains parameters of the IReactionRepository.GetAll
type IReactionRepositoryMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IReactionRepositoryMockGetAllResults contains results of the IReactionRepository.GetAll
type IReactionRepositoryMockGetAllResults struct {
	rpa1 []*models.Reaction
	err  error
}

// Expect sets up expected params for IReactionRepository.GetAll
func (mmGetAll *mIReactionRepositoryMockGetAll) Expect(ctx context.Context, u1 uuid.UUID) *mIReactionRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IReactionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IReactionRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &IReactionRepositoryMockGetAllParams{ctx, u1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the IReactionRepository.GetAll
func (mmGetAll *mIReactionRepositoryMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIReactionRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for IReactionRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by IReactionRepository.GetAll
func (mmGetAll *mIReactionRepositoryMockGetAll) Return(rpa1 []*models.Reaction, err error) *IReactionRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IReactionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IReactionRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &IReactionRepositoryMockGetAllResults{rpa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the IReactionRepository.GetAll method
func (mmGetAll *mIReactionRepositoryMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error)) *IReactionRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the IReactionRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the IReactionRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the IReactionRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mIReactionRepositoryMockGetAll) When(ctx context.Context, u1 uuid.UUID) *IReactionRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IReactionRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &IReactionRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &IReactionRepositoryMockGetAllParams{ctx, u1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up IReactionRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *IReactionRepositoryMockGetAllExpectation) Then(rpa1 []*models.Reaction, err error) *IReactionRepositoryMock {
	e.results = &IReactionRepositoryMockGetAllResults{rpa1, err}
	return e.mock
}

// GetAll implements interfaces.IReactionRepository
func (mmGetAll *IReactionRepositoryMock) GetAll(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1)
	}

	mm_params := &IReactionRepositoryMockGetAllParams{ctx, u1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := IReactionRepositoryMockGetAllParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("IReactionRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the IReactionRepositoryMock.GetAll")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1)
	}
	mmGetAll.t.Fatalf("Unexpected call to IReactionRepositoryMock.GetAll. %v %v", ctx, u1)
	return
}

// GetAllAfterCounter returns a count of finished IReactionRepositoryMock.GetAll invocations
func (mmGetAll *IReactionRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of IReactionRepositoryMock.GetAll invocations
func (mmGetAll *IReactionRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to IReactionRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mIReactionRepositoryMockGetAll) Calls() []*IReactionRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*IReactionRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *IReactionRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *IReactionRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IReactionRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IReactionRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to IReactionRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to IReactionRepositoryMock.GetAll")
	}
}

type mIReactionRepositoryMockReacted struct {
	mock               *IReactionRepositoryMock
	defaultExpectation *IReactionRepositoryMockReactedExpectation
	expectations       []*IReactionRepositoryMockReactedExpectation

	callArgs []*IReactionRepositoryMockReactedParams
	mutex    sync.RWMutex
}

// IReactionRepositoryMockReactedExpectation specifies expectation struct of the IReactionRepository.Reacted
type IReactionRepositoryMockReactedExpectation struct {
	mock    *IReactionRepositoryMock
	params  *IReactionRepositoryMockReactedParams
	results *IReactionRepositoryMockReactedResults
	Counter uint64
}

// IReactionRepositoryMockReactedParams contains parameters of the IReactionRepository.Reacted
type IReactionRepositoryMockReactedParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
	u3  uuid.UUID
}

// IReactionRepositoryMockReactedResults contains results of the IReactionRepository.Reacted
type IReactionRepositoryMockReactedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for IReactionRepository.Reacted
func (mmReacted *mIReactionRepositoryMockReacted) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) *mIReactionRepositoryMockReacted {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("IReactionRepositoryMock.Reacted mock is already set by Set")
	}

	if mmReacted.defaultExpectation == nil {
		mmReacted.defaultExpectation = &IReactionRepositoryMockReactedExpectation{}
	}

	mmReacted.defaultExpectation.params = &IReactionRepositoryMockReactedParams{ctx, u1, u2, u3}
	for _, e := range mmReacted.expectations {
		if minimock.Equal(e.params, mmReacted.defaultExpectation.params) {
			mmReacted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReacted.defaultExpectation.params)
		}
	}

	return mmReacted
}

// Inspect accepts an inspector function that has same arguments as the IReactionRepository.Reacted
func (mmReacted *mIReactionRepositoryMockReacted) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID)) *mIReactionRepositoryMockReacted {
	if mmReacted.mock.inspectFuncReacted != nil {
		mmReacted.mock.t.Fatalf("Inspect function is already set for IReactionRepositoryMock.Reacted")
	}

	mmReacted.mock.inspectFuncReacted = f

	return mmReacted
}

// Return sets up results that will be returned by IReactionRepository.Reacted
func (mmReacted *mIReactionRepositoryMockReacted) Return(b1 bool, err error) *IReactionRepositoryMock {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("IReactionRepositoryMock.Reacted mock is already set by Set")
	}

	if mmReacted.defaultExpectation == nil {
		mmReacted.defaultExpectation = &IReactionRepositoryMockReactedExpectation{mock: mmReacted.mock}
	}
	mmReacted.defaultExpectation.results = &IReactionRepositoryMockReactedResults{b1, err}
	return mmReacted.mock
}

// Set uses given function f to mock the IReactionRepository.Reacted method
func (mmReacted *mIReactionRepositoryMockReacted) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (b1 bool, err error)) *IReactionRepositoryMock {
	if mmReacted.defaultExpectation != nil {
		mmReacted.mock.t.Fatalf("Default expectation is already set for the IReactionRepository.Reacted method")
	}

	if len(mmReacted.expectations) > 0 {
		mmReacted.mock.t.Fatalf("Some expectations are already set for the IReactionRepository.Reacted method")
	}

	mmReacted.mock.funcReacted = f
	return mmReacted.mock
}

// When sets expectation for the IReactionRepository.Reacted which will trigger the result defined by the following
// Then helper
func (mmReacted *mIReactionRepositoryMockReacted) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) *IReactionRepositoryMockReactedExpectation {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("IReactionRepositoryMock.Reacted mock is already set by Set")
	}

	expectation := &IReactionRepositoryMockReactedExpectation{
		mock:   mmReacted.mock,
		params: &IReactionRepositoryMockReactedParams{ctx, u1, u2, u3},
	}
	mmReacted.expectations = append(mmReacted.expectations, expectation)
	return expectation
}

// Then sets up IReactionRepository.Reacted return parameters for the expectation previously defined by the When method
func (e *IReactionRepositoryMockReactedExpectation) Then(b1 bool, err error) *IReactionRepositoryMock {
	e.results = &IReactionRepositoryMockReactedResults{b1, err}
	return e.mock
}

// Reacted implements interfaces.IReactionRepository
func (mmReacted *IReactionRepositoryMock) Reacted(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID, u3 uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmReacted.beforeReactedCounter, 1)
	defer mm_atomic.AddUint64(&mmReacted.afterReactedCounter, 1)

	if mmReacted.inspectFuncReacted != nil {
		mmReacted.inspectFuncReacted(ctx, u1, u2, u3)
	}

	mm_params := &IReactionRepositoryMockReactedParams{ctx, u1, u2, u3}

	// Record call args
	mmReacted.ReactedMock.mutex.Lock()
	mmReacted.ReactedMock.callArgs = append(mmReacted.ReactedMock.callArgs, mm_params)
	mmReacted.ReactedMock.mutex.Unlock()

	for _, e := range mmReacted.ReactedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmReacted.ReactedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReacted.ReactedMock.defaultExpectation.Counter, 1)
		mm_want := mmReacted.ReactedMock.defaultExpectation.params
		mm_got := IReactionRepositoryMockReactedParams{ctx, u1, u2, u3}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReacted.t.Errorf("IReactionRepositoryMock.Reacted got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReacted.ReactedMock.defaultExpectation.results
		if mm_results == nil {
			mmReacted.t.Fatal("No results are set for the IReactionRepositoryMock.Reacted")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmReacted.funcReacted != nil {
		return mmReacted.funcReacted(ctx, u1, u2, u3)
	}
	mmReacted.t.Fatalf("Unexpected call to IReactionRepositoryMock.Reacted. %v %v %v %v", ctx, u1, u2, u3)
	return
}

// ReactedAfterCounter returns a count of finished IReactionRepositoryMock.Reacted invocations
func (mmReacted *IReactionRepositoryMock) ReactedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReacted.afterReactedCounter)
}

// ReactedBeforeCounter returns a count of IReactionRepositoryMock.Reacted invocations
func (mmReacted *IReactionRepositoryMock) ReactedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReacted.beforeReactedCounter)
}

// Calls returns a list of arguments used in each call to IReactionRepositoryMock.Reacted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReacted *mIReactionRepositoryMockReacted) Calls() []*IReactionRepositoryMockReactedParams {
	mmReacted.mutex.RLock()

	argCopy := make([]*IReactionRepositoryMockReactedParams, len(mmReacted.callArgs))
	copy(argCopy, mmReacted.callArgs)

	mmReacted.mutex.RUnlock()

	return argCopy
}

// MinimockReactedDone returns true if the count of the Reacted invocations corresponds
// the number of defined expectations
func (m *IReactionRepositoryMock) MinimockReactedDone() bool {
	for _, e := range m.ReactedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReacted != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		return false
	}
	return true
}

// MinimockReactedInspect logs each unmet expectation
func (m *IReactionRepositoryMock) MinimockReactedInspect() {
	for _, e := range m.ReactedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Reacted with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		if m.ReactedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IReactionRepositoryMock.Reacted")
		} else {
			m.t.Errorf("Expected call to IReactionRepositoryMock.Reacted with params: %#v", *m.ReactedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReacted != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		m.t.Error("Expected call to IReactionRepositoryMock.Reacted")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IReactionRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetAllInspect()

		m.MinimockReactedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IReactionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IReactionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockReactedDone()
}

package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IProfileLogic -o ./internal/mocks/i_profile_logic_mock_test.go -n IProfileLogicMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
)

// IProfileLogicMock implements interfaces.IProfileLogic
type IProfileLogicMock struct {
	t minimock.Tester

	funcAuthByToken          func(ctx context.Context, s1 string) (up1 *models.User, err error)
	inspectFuncAuthByToken   func(ctx context.Context, s1 string)
	afterAuthByTokenCounter  uint64
	beforeAuthByTokenCounter uint64
	AuthByTokenMock          mIProfileLogicMockAuthByToken

	funcDelete          func(ctx context.Context, s1 string) (err error)
	inspectFuncDelete   func(ctx context.Context, s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIProfileLogicMockDelete

	funcGet          func(ctx context.Context, s1 string) (up1 *models.User, err error)
	inspectFuncGet   func(ctx context.Context, s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mIProfileLogicMockGet

	funcGetAll          func(ctx context.Context) (upa1 []*models.User, err error)
	inspectFuncGetAll   func(ctx context.Context)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mIProfileLogicMockGetAll

	funcLogin          func(ctx context.Context, s1 string, s2 string) (s3 string, err error)
	inspectFuncLogin   func(ctx context.Context, s1 string, s2 string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mIProfileLogicMockLogin

	funcRegister          func(ctx context.Context, up1 *models.User, s1 string) (s2 string, err error)
	inspectFuncRegister   func(ctx context.Context, up1 *models.User, s1 string)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mIProfileLogicMockRegister
}

// NewIProfileLogicMock returns a mock for interfaces.IProfileLogic
func NewIProfileLogicMock(t minimock.Tester) *IProfileLogicMock {
	m := &IProfileLogicMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AuthByTokenMock = mIProfileLogicMockAuthByToken{mock: m}
	m.AuthByTokenMock.callArgs = []*IProfileLogicMockAuthByTokenParams{}

	m.DeleteMock = mIProfileLogicMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IProfileLogicMockDeleteParams{}

	m.GetMock = mIProfileLogicMockGet{mock: m}
	m.GetMock.callArgs = []*IProfileLogicMockGetParams{}

	m.GetAllMock = mIProfileLogicMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*IProfileLogicMockGetAllParams{}

	m.LoginMock = mIProfileLogicMockLogin{mock: m}
	m.LoginMock.callArgs = []*IProfileLogicMockLoginParams{}

	m.RegisterMock = mIProfileLogicMockRegister{mock: m}
	m.RegisterMock.callArgs = []*IProfileLogicMockRegisterParams{}

	return m
}

type mIProfileLogicMockAuthByToken struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockAuthByTokenExpectation
	expectations       []*IProfileLogicMockAuthByTokenExpectation

	callArgs []*IProfileLogicMockAuthByTokenParams
	mutex    sync.RWMutex
}

// IProfileLogicMockAuthByTokenExpectation specifies expectation struct of the IProfileLogic.AuthByToken
type IProfileLogicMockAuthByTokenExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockAuthByTokenParams
	results *IProfileLogicMockAuthByTokenResults
	Counter uint64
}

// IProfileLogicMockAuthByTokenParams contains parameters of the IProfileLogic.AuthByToken
type IProfileLogicMockAuthByTokenParams struct {
	ctx context.Context
	s1  string
}

// IProfileLogicMockAuthByTokenResults contains results of the IProfileLogic.AuthByToken
type IProfileLogicMockAuthByTokenResults struct {
	up1 *models.User
	err error
}

// Expect sets up expected params for IProfileLogic.AuthByToken
func (mmAuthByToken *mIProfileLogicMockAuthByToken) Expect(ctx context.Context, s1 string) *mIProfileLogicMockAuthByToken {
	if mmAuthByToken.mock.funcAuthByToken != nil {
		mmAuthByToken.mock.t.Fatalf("IProfileLogicMock.AuthByToken mock is already set by Set")
	}

	if mmAuthByToken.defaultExpectation == nil {
		mmAuthByToken.defaultExpectation = &IProfileLogicMockAuthByTokenExpectation{}
	}

	mmAuthByToken.defaultExpectation.params = &IProfileLogicMockAuthByTokenParams{ctx, s1}
	for _, e := range mmAuthByToken.expectations {
		if minimock.Equal(e.params, mmAuthByToken.defaultExpectation.params) {
			mmAuthByToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuthByToken.defaultExpectation.params)
		}
	}

	return mmAuthByToken
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.AuthByToken
func (mmAuthByToken *mIProfileLogicMockAuthByToken) Inspect(f func(ctx context.Context, s1 string)) *mIProfileLogicMockAuthByToken {
	if mmAuthByToken.mock.inspectFuncAuthByToken != nil {
		mmAuthByToken.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.AuthByToken")
	}

	mmAuthByToken.mock.inspectFuncAuthByToken = f

	return mmAuthByToken
}

// Return sets up results that will be returned by IProfileLogic.AuthByToken
func (mmAuthByToken *mIProfileLogicMockAuthByToken) Return(up1 *models.User, err error) *IProfileLogicMock {
	if mmAuthByToken.mock.funcAuthByToken != nil {
		mmAuthByToken.mock.t.Fatalf("IProfileLogicMock.AuthByToken mock is already set by Set")
	}

	if mmAuthByToken.defaultExpectation == nil {
		mmAuthByToken.defaultExpectation = &IProfileLogicMockAuthByTokenExpectation{mock: mmAuthByToken.mock}
	}
	mmAuthByToken.defaultExpectation.results = &IProfileLogicMockAuthByTokenResults{up1, err}
	return mmAuthByToken.mock
}

// Set uses given function f to mock the IProfileLogic.AuthByToken method
func (mmAuthByToken *mIProfileLogicMockAuthByToken) Set(f func(ctx context.Context, s1 string) (up1 *models.User, err error)) *IProfileLogicMock {
	if mmAuthByToken.defaultExpectation != nil {
		mmAuthByToken.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.AuthByToken method")
	}

	if len(mmAuthByToken.expectations) > 0 {
		mmAuthByToken.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.AuthByToken method")
	}

	mmAuthByToken.mock.funcAuthByToken = f
	return mmAuthByToken.mock
}

// When sets expectation for the IProfileLogic.AuthByToken which will trigger the result defined by the following
// Then helper
func (mmAuthByToken *mIProfileLogicMockAuthByToken) When(ctx context.Context, s1 string) *IProfileLogicMockAuthByTokenExpectation {
	if mmAuthByToken.mock.funcAuthByToken != nil {
		mmAuthByToken.mock.t.Fatalf("IProfileLogicMock.AuthByToken mock is already set by Set")
	}

	expectation := &IProfileLogicMockAuthByTokenExpectation{
		mock:   mmAuthByToken.mock,
		params: &IProfileLogicMockAuthByTokenParams{ctx, s1},
	}
	mmAuthByToken.expectations = append(mmAuthByToken.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.AuthByToken return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockAuthByTokenExpectation) Then(up1 *models.User, err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockAuthByTokenResults{up1, err}
	return e.mock
}

// AuthByToken implements interfaces.IProfileLogic
func (mmAuthByToken *IProfileLogicMock) AuthByToken(ctx context.Context, s1 string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmAuthByToken.beforeAuthByTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmAuthByToken.afterAuthByTokenCounter, 1)

	if mmAuthByToken.inspectFuncAuthByToken != nil {
		mmAuthByToken.inspectFuncAuthByToken(ctx, s1)
	}

	mm_params := &IProfileLogicMockAuthByTokenParams{ctx, s1}

	// Record call args
	mmAuthByToken.AuthByTokenMock.mutex.Lock()
	mmAuthByToken.AuthByTokenMock.callArgs = append(mmAuthByToken.AuthByTokenMock.callArgs, mm_params)
	mmAuthByToken.AuthByTokenMock.mutex.Unlock()

	for _, e := range mmAuthByToken.AuthByTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmAuthByToken.AuthByTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuthByToken.AuthByTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmAuthByToken.AuthByTokenMock.defaultExpectation.params
		mm_got := IProfileLogicMockAuthByTokenParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuthByToken.t.Errorf("IProfileLogicMock.AuthByToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAuthByToken.AuthByTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmAuthByToken.t.Fatal("No results are set for the IProfileLogicMock.AuthByToken")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmAuthByToken.funcAuthByToken != nil {
		return mmAuthByToken.funcAuthByToken(ctx, s1)
	}
	mmAuthByToken.t.Fatalf("Unexpected call to IProfileLogicMock.AuthByToken. %v %v", ctx, s1)
	return
}

// AuthByTokenAfterCounter returns a count of finished IProfileLogicMock.AuthByToken invocations
func (mmAuthByToken *IProfileLogicMock) AuthByTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthByToken.afterAuthByTokenCounter)
}

// AuthByTokenBeforeCounter returns a count of IProfileLogicMock.AuthByToken invocations
func (mmAuthByToken *IProfileLogicMock) AuthByTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthByToken.beforeAuthByTokenCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.AuthByToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuthByToken *mIProfileLogicMockAuthByToken) Calls() []*IProfileLogicMockAuthByTokenParams {
	mmAuthByToken.mutex.RLock()

	argCopy := make([]*IProfileLogicMockAuthByTokenParams, len(mmAuthByToken.callArgs))
	copy(argCopy, mmAuthByToken.callArgs)

	mmAuthByToken.mutex.RUnlock()

	return argCopy
}

// MinimockAuthByTokenDone returns true if the count of the AuthByToken invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockAuthByTokenDone() bool {
	for _, e := range m.AuthByTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthByTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthByTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthByToken != nil && mm_atomic.LoadUint64(&m.afterAuthByTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockAuthByTokenInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockAuthByTokenInspect() {
	for _, e := range m.AuthByTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.AuthByToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthByTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthByTokenCounter) < 1 {
		if m.AuthByTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.AuthByToken")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.AuthByToken with params: %#v", *m.AuthByTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthByToken != nil && mm_atomic.LoadUint64(&m.afterAuthByTokenCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.AuthByToken")
	}
}

type mIProfileLogicMockDelete struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockDeleteExpectation
	expectations       []*IProfileLogicMockDeleteExpectation

	callArgs []*IProfileLogicMockDeleteParams
	mutex    sync.RWMutex
}

// IProfileLogicMockDeleteExpectation specifies expectation struct of the IProfileLogic.Delete
type IProfileLogicMockDeleteExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockDeleteParams
	results *IProfileLogicMockDeleteResults
	Counter uint64
}

// IProfileLogicMockDeleteParams contains parameters of the IProfileLogic.Delete
type IProfileLogicMockDeleteParams struct {
	ctx context.Context
	s1  string
}

// IProfileLogicMockDeleteResults contains results of the IProfileLogic.Delete
type IProfileLogicMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IProfileLogic.Delete
func (mmDelete *mIProfileLogicMockDelete) Expect(ctx context.Context, s1 string) *mIProfileLogicMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IProfileLogicMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IProfileLogicMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IProfileLogicMockDeleteParams{ctx, s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.Delete
func (mmDelete *mIProfileLogicMockDelete) Inspect(f func(ctx context.Context, s1 string)) *mIProfileLogicMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IProfileLogic.Delete
func (mmDelete *mIProfileLogicMockDelete) Return(err error) *IProfileLogicMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IProfileLogicMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IProfileLogicMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IProfileLogicMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IProfileLogic.Delete method
func (mmDelete *mIProfileLogicMockDelete) Set(f func(ctx context.Context, s1 string) (err error)) *IProfileLogicMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IProfileLogic.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIProfileLogicMockDelete) When(ctx context.Context, s1 string) *IProfileLogicMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IProfileLogicMock.Delete mock is already set by Set")
	}

	expectation := &IProfileLogicMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IProfileLogicMockDeleteParams{ctx, s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.Delete return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockDeleteExpectation) Then(err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IProfileLogic
func (mmDelete *IProfileLogicMock) Delete(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, s1)
	}

	mm_params := &IProfileLogicMockDeleteParams{ctx, s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IProfileLogicMockDeleteParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IProfileLogicMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IProfileLogicMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, s1)
	}
	mmDelete.t.Fatalf("Unexpected call to IProfileLogicMock.Delete. %v %v", ctx, s1)
	return
}

// DeleteAfterCounter returns a count of finished IProfileLogicMock.Delete invocations
func (mmDelete *IProfileLogicMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IProfileLogicMock.Delete invocations
func (mmDelete *IProfileLogicMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIProfileLogicMockDelete) Calls() []*IProfileLogicMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IProfileLogicMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.Delete")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.Delete")
	}
}

type mIProfileLogicMockGet struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockGetExpectation
	expectations       []*IProfileLogicMockGetExpectation

	callArgs []*IProfileLogicMockGetParams
	mutex    sync.RWMutex
}

// IProfileLogicMockGetExpectation specifies expectation struct of the IProfileLogic.Get
type IProfileLogicMockGetExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockGetParams
	results *IProfileLogicMockGetResults
	Counter uint64
}

// IProfileLogicMockGetParams contains parameters of the IProfileLogic.Get
type IProfileLogicMockGetParams struct {
	ctx context.Context
	s1  string
}

// IProfileLogicMockGetResults contains results of the IProfileLogic.Get
type IProfileLogicMockGetResults struct {
	up1 *models.User
	err error
}

// Expect sets up expected params for IProfileLogic.Get
func (mmGet *mIProfileLogicMockGet) Expect(ctx context.Context, s1 string) *mIProfileLogicMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IProfileLogicMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IProfileLogicMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &IProfileLogicMockGetParams{ctx, s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.Get
func (mmGet *mIProfileLogicMockGet) Inspect(f func(ctx context.Context, s1 string)) *mIProfileLogicMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by IProfileLogic.Get
func (mmGet *mIProfileLogicMockGet) Return(up1 *models.User, err error) *IProfileLogicMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IProfileLogicMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IProfileLogicMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &IProfileLogicMockGetResults{up1, err}
	return mmGet.mock
}

// Set uses given function f to mock the IProfileLogic.Get method
func (mmGet *mIProfileLogicMockGet) Set(f func(ctx context.Context, s1 string) (up1 *models.User, err error)) *IProfileLogicMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the IProfileLogic.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mIProfileLogicMockGet) When(ctx context.Context, s1 string) *IProfileLogicMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IProfileLogicMock.Get mock is already set by Set")
	}

	expectation := &IProfileLogicMockGetExpectation{
		mock:   mmGet.mock,
		params: &IProfileLogicMockGetParams{ctx, s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.Get return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockGetExpectation) Then(up1 *models.User, err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockGetResults{up1, err}
	return e.mock
}

// Get implements interfaces.IProfileLogic
func (mmGet *IProfileLogicMock) Get(ctx context.Context, s1 string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, s1)
	}

	mm_params := &IProfileLogicMockGetParams{ctx, s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := IProfileLogicMockGetParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("IProfileLogicMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the IProfileLogicMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, s1)
	}
	mmGet.t.Fatalf("Unexpected call to IProfileLogicMock.Get. %v %v", ctx, s1)
	return
}

// GetAfterCounter returns a count of finished IProfileLogicMock.Get invocations
func (mmGet *IProfileLogicMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of IProfileLogicMock.Get invocations
func (mmGet *IProfileLogicMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mIProfileLogicMockGet) Calls() []*IProfileLogicMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*IProfileLogicMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.Get")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.Get")
	}
}

type mIProfileLogicMockGetAll struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockGetAllExpectation
	expectations       []*IProfileLogicMockGetAllExpectation

	callArgs []*IProfileLogicMockGetAllParams
	mutex    sync.RWMutex
}

// IProfileLogicMockGetAllExpectation specifies expectation struct of the IProfileLogic.GetAll
type IProfileLogicMockGetAllExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockGetAllParams
	results *IProfileLogicMockGetAllResults
	Counter uint64
}

// IProfileLogicMockGetAllParams contains parameters of the IProfileLogic.GetAll
type IProfileLogicMockGetAllParams struct {
	ctx context.Context
}

// IProfileLogicMockGetAllResults contains results of the IProfileLogic.GetAll
type IProfileLogicMockGetAllResults struct {
	upa1 []*models.User
	err  error
}

// Expect sets up expected params for IProfileLogic.GetAll
func (mmGetAll *mIProfileLogicMockGetAll) Expect(ctx context.Context) *mIProfileLogicMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IProfileLogicMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IProfileLogicMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &IProfileLogicMockGetAllParams{ctx}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.GetAll
func (mmGetAll *mIProfileLogicMockGetAll) Inspect(f func(ctx context.Context)) *mIProfileLogicMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by IProfileLogic.GetAll
func (mmGetAll *mIProfileLogicMockGetAll) Return(upa1 []*models.User, err error) *IProfileLogicMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IProfileLogicMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IProfileLogicMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &IProfileLogicMockGetAllResults{upa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the IProfileLogic.GetAll method
func (mmGetAll *mIProfileLogicMockGetAll) Set(f func(ctx context.Context) (upa1 []*models.User, err error)) *IProfileLogicMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the IProfileLogic.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mIProfileLogicMockGetAll) When(ctx context.Context) *IProfileLogicMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IProfileLogicMock.GetAll mock is already set by Set")
	}

	expectation := &IProfileLogicMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &IProfileLogicMockGetAllParams{ctx},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.GetAll return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockGetAllExpectation) Then(upa1 []*models.User, err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockGetAllResults{upa1, err}
	return e.mock
}

// GetAll implements interfaces.IProfileLogic
func (mmGetAll *IProfileLogicMock) GetAll(ctx context.Context) (upa1 []*models.User, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx)
	}

	mm_params := &IProfileLogicMockGetAllParams{ctx}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.upa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := IProfileLogicMockGetAllParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("IProfileLogicMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the IProfileLogicMock.GetAll")
		}
		return (*mm_results).upa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx)
	}
	mmGetAll.t.Fatalf("Unexpected call to IProfileLogicMock.GetAll. %v", ctx)
	return
}

// GetAllAfterCounter returns a count of finished IProfileLogicMock.GetAll invocations
func (mmGetAll *IProfileLogicMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of IProfileLogicMock.GetAll invocations
func (mmGetAll *IProfileLogicMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mIProfileLogicMockGetAll) Calls() []*IProfileLogicMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*IProfileLogicMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.GetAll")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.GetAll")
	}
}

type mIProfileLogicMockLogin struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockLoginExpectation
	expectations       []*IProfileLogicMockLoginExpectation

	callArgs []*IProfileLogicMockLoginParams
	mutex    sync.RWMutex
}

// IProfileLogicMockLoginExpectation specifies expectation struct of the IProfileLogic.Login
type IProfileLogicMockLoginExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockLoginParams
	results *IProfileLogicMockLoginResults
	Counter uint64
}

// IProfileLogicMockLoginParams contains parameters of the IProfileLogic.Login
type IProfileLogicMockLoginParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// IProfileLogicMockLoginResults contains results of the IProfileLogic.Login
type IProfileLogicMockLoginResults struct {
	s3  string
	err error
}

// Expect sets up expected params for IProfileLogic.Login
func (mmLogin *mIProfileLogicMockLogin) Expect(ctx context.Context, s1 string, s2 string) *mIProfileLogicMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("IProfileLogicMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &IProfileLogicMockLoginExpectation{}
	}

	mmLogin.defaultExpectation.params = &IProfileLogicMockLoginParams{ctx, s1, s2}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.Login
func (mmLogin *mIProfileLogicMockLogin) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mIProfileLogicMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by IProfileLogic.Login
func (mmLogin *mIProfileLogicMockLogin) Return(s3 string, err error) *IProfileLogicMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("IProfileLogicMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &IProfileLogicMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &IProfileLogicMockLoginResults{s3, err}
	return mmLogin.mock
}

// Set uses given function f to mock the IProfileLogic.Login method
func (mmLogin *mIProfileLogicMockLogin) Set(f func(ctx context.Context, s1 string, s2 string) (s3 string, err error)) *IProfileLogicMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the IProfileLogic.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mIProfileLogicMockLogin) When(ctx context.Context, s1 string, s2 string) *IProfileLogicMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("IProfileLogicMock.Login mock is already set by Set")
	}

	expectation := &IProfileLogicMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &IProfileLogicMockLoginParams{ctx, s1, s2},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.Login return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockLoginExpectation) Then(s3 string, err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockLoginResults{s3, err}
	return e.mock
}

// Login implements interfaces.IProfileLogic
func (mmLogin *IProfileLogicMock) Login(ctx context.Context, s1 string, s2 string) (s3 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, s1, s2)
	}

	mm_params := &IProfileLogicMockLoginParams{ctx, s1, s2}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s3, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_got := IProfileLogicMockLoginParams{ctx, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("IProfileLogicMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the IProfileLogicMock.Login")
		}
		return (*mm_results).s3, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, s1, s2)
	}
	mmLogin.t.Fatalf("Unexpected call to IProfileLogicMock.Login. %v %v %v", ctx, s1, s2)
	return
}

// LoginAfterCounter returns a count of finished IProfileLogicMock.Login invocations
func (mmLogin *IProfileLogicMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of IProfileLogicMock.Login invocations
func (mmLogin *IProfileLogicMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mIProfileLogicMockLogin) Calls() []*IProfileLogicMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*IProfileLogicMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockLoginDone() bool {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.Login with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.Login")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.Login")
	}
}

type mIProfileLogicMockRegister struct {
	mock               *IProfileLogicMock
	defaultExpectation *IProfileLogicMockRegisterExpectation
	expectations       []*IProfileLogicMockRegisterExpectation

	callArgs []*IProfileLogicMockRegisterParams
	mutex    sync.RWMutex
}

// IProfileLogicMockRegisterExpectation specifies expectation struct of the IProfileLogic.Register
type IProfileLogicMockRegisterExpectation struct {
	mock    *IProfileLogicMock
	params  *IProfileLogicMockRegisterParams
	results *IProfileLogicMockRegisterResults
	Counter uint64
}

// IProfileLogicMockRegisterParams contains parameters of the IProfileLogic.Register
type IProfileLogicMockRegisterParams struct {
	ctx context.Context
	up1 *models.User
	s1  string
}

// IProfileLogicMockRegisterResults contains results of the IProfileLogic.Register
type IProfileLogicMockRegisterResults struct {
	s2  string
	err error
}

// Expect sets up expected params for IProfileLogic.Register
func (mmRegister *mIProfileLogicMockRegister) Expect(ctx context.Context, up1 *models.User, s1 string) *mIProfileLogicMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("IProfileLogicMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &IProfileLogicMockRegisterExpectation{}
	}

	mmRegister.defaultExpectation.params = &IProfileLogicMockRegisterParams{ctx, up1, s1}
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the IProfileLogic.Register
func (mmRegister *mIProfileLogicMockRegister) Inspect(f func(ctx context.Context, up1 *models.User, s1 string)) *mIProfileLogicMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for IProfileLogicMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by IProfileLogic.Register
func (mmRegister *mIProfileLogicMockRegister) Return(s2 string, err error) *IProfileLogicMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("IProfileLogicMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &IProfileLogicMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &IProfileLogicMockRegisterResults{s2, err}
	return mmRegister.mock
}

// Set uses given function f to mock the IProfileLogic.Register method
func (mmRegister *mIProfileLogicMockRegister) Set(f func(ctx context.Context, up1 *models.User, s1 string) (s2 string, err error)) *IProfileLogicMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the IProfileLogic.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the IProfileLogic.Register method")
	}

	mmRegister.mock.funcRegister = f
	return mmRegister.mock
}

// When sets expectation for the IProfileLogic.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mIProfileLogicMockRegister) When(ctx context.Context, up1 *models.User, s1 string) *IProfileLogicMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("IProfileLogicMock.Register mock is already set by Set")
	}

	expectation := &IProfileLogicMockRegisterExpectation{
		mock:   mmRegister.mock,
		params: &IProfileLogicMockRegisterParams{ctx, up1, s1},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up IProfileLogic.Register return parameters for the expectation previously defined by the When method
func (e *IProfileLogicMockRegisterExpectation) Then(s2 string, err error) *IProfileLogicMock {
	e.results = &IProfileLogicMockRegisterResults{s2, err}
	return e.mock
}

// Register implements interfaces.IProfileLogic
func (mmRegister *IProfileLogicMock) Register(ctx context.Context, up1 *models.User, s1 string) (s2 string, err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(ctx, up1, s1)
	}

	mm_params := &IProfileLogicMockRegisterParams{ctx, up1, s1}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_got := IProfileLogicMockRegisterParams{ctx, up1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("IProfileLogicMock.Register got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the IProfileLogicMock.Register")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(ctx, up1, s1)
	}
	mmRegister.t.Fatalf("Unexpected call to IProfileLogicMock.Register. %v %v %v", ctx, up1, s1)
	return
}

// RegisterAfterCounter returns a count of finished IProfileLogicMock.Register invocations
func (mmRegister *IProfileLogicMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of IProfileLogicMock.Register invocations
func (mmRegister *IProfileLogicMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to IProfileLogicMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mIProfileLogicMockRegister) Calls() []*IProfileLogicMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*IProfileLogicMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *IProfileLogicMock) MinimockRegisterDone() bool {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterInspect logs each unmet expectation
func (m *IProfileLogicMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProfileLogicMock.Register with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IProfileLogicMock.Register")
		} else {
			m.t.Errorf("Expected call to IProfileLogicMock.Register with params: %#v", *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		m.t.Error("Expected call to IProfileLogicMock.Register")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IProfileLogicMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAuthByTokenInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()

		m.MinimockLoginInspect()

		m.MinimockRegisterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IProfileLogicMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IProfileLogicMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAuthByTokenDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRegisterDone()
}

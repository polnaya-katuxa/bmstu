package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IUserRepository -o ./internal/mocks/i_user_repository_mock_test.go -n IUserRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IUserRepositoryMock implements interfaces.IUserRepository
type IUserRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, up1 *models.User) (up2 *models.User, err error)
	inspectFuncCreate   func(ctx context.Context, up1 *models.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mIUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, s1 string) (err error)
	inspectFuncDelete   func(ctx context.Context, s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIUserRepositoryMockDelete

	funcGetAll          func(ctx context.Context, pp1 *models.Paginator) (upa1 []*models.User, err error)
	inspectFuncGetAll   func(ctx context.Context, pp1 *models.Paginator)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mIUserRepositoryMockGetAll

	funcGetByID          func(ctx context.Context, u1 uuid.UUID) (up1 *models.User, err error)
	inspectFuncGetByID   func(ctx context.Context, u1 uuid.UUID)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mIUserRepositoryMockGetByID

	funcGetByLogin          func(ctx context.Context, s1 string) (up1 *models.User, err error)
	inspectFuncGetByLogin   func(ctx context.Context, s1 string)
	afterGetByLoginCounter  uint64
	beforeGetByLoginCounter uint64
	GetByLoginMock          mIUserRepositoryMockGetByLogin

	funcGetTotal          func(ctx context.Context) (i1 int, err error)
	inspectFuncGetTotal   func(ctx context.Context)
	afterGetTotalCounter  uint64
	beforeGetTotalCounter uint64
	GetTotalMock          mIUserRepositoryMockGetTotal

	funcUpdate          func(ctx context.Context, up1 *models.User) (err error)
	inspectFuncUpdate   func(ctx context.Context, up1 *models.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mIUserRepositoryMockUpdate
}

// NewIUserRepositoryMock returns a mock for interfaces.IUserRepository
func NewIUserRepositoryMock(t minimock.Tester) *IUserRepositoryMock {
	m := &IUserRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mIUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*IUserRepositoryMockCreateParams{}

	m.DeleteMock = mIUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IUserRepositoryMockDeleteParams{}

	m.GetAllMock = mIUserRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*IUserRepositoryMockGetAllParams{}

	m.GetByIDMock = mIUserRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*IUserRepositoryMockGetByIDParams{}

	m.GetByLoginMock = mIUserRepositoryMockGetByLogin{mock: m}
	m.GetByLoginMock.callArgs = []*IUserRepositoryMockGetByLoginParams{}

	m.GetTotalMock = mIUserRepositoryMockGetTotal{mock: m}
	m.GetTotalMock.callArgs = []*IUserRepositoryMockGetTotalParams{}

	m.UpdateMock = mIUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*IUserRepositoryMockUpdateParams{}

	return m
}

type mIUserRepositoryMockCreate struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockCreateExpectation
	expectations       []*IUserRepositoryMockCreateExpectation

	callArgs []*IUserRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockCreateExpectation specifies expectation struct of the IUserRepository.Create
type IUserRepositoryMockCreateExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockCreateParams
	results *IUserRepositoryMockCreateResults
	Counter uint64
}

// IUserRepositoryMockCreateParams contains parameters of the IUserRepository.Create
type IUserRepositoryMockCreateParams struct {
	ctx context.Context
	up1 *models.User
}

// IUserRepositoryMockCreateResults contains results of the IUserRepository.Create
type IUserRepositoryMockCreateResults struct {
	up2 *models.User
	err error
}

// Expect sets up expected params for IUserRepository.Create
func (mmCreate *mIUserRepositoryMockCreate) Expect(ctx context.Context, up1 *models.User) *mIUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IUserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IUserRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &IUserRepositoryMockCreateParams{ctx, up1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Create
func (mmCreate *mIUserRepositoryMockCreate) Inspect(f func(ctx context.Context, up1 *models.User)) *mIUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by IUserRepository.Create
func (mmCreate *mIUserRepositoryMockCreate) Return(up2 *models.User, err error) *IUserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IUserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IUserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &IUserRepositoryMockCreateResults{up2, err}
	return mmCreate.mock
}

// Set uses given function f to mock the IUserRepository.Create method
func (mmCreate *mIUserRepositoryMockCreate) Set(f func(ctx context.Context, up1 *models.User) (up2 *models.User, err error)) *IUserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the IUserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mIUserRepositoryMockCreate) When(ctx context.Context, up1 *models.User) *IUserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IUserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &IUserRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &IUserRepositoryMockCreateParams{ctx, up1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Create return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockCreateExpectation) Then(up2 *models.User, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockCreateResults{up2, err}
	return e.mock
}

// Create implements interfaces.IUserRepository
func (mmCreate *IUserRepositoryMock) Create(ctx context.Context, up1 *models.User) (up2 *models.User, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, up1)
	}

	mm_params := &IUserRepositoryMockCreateParams{ctx, up1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := IUserRepositoryMockCreateParams{ctx, up1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("IUserRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the IUserRepositoryMock.Create")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, up1)
	}
	mmCreate.t.Fatalf("Unexpected call to IUserRepositoryMock.Create. %v %v", ctx, up1)
	return
}

// CreateAfterCounter returns a count of finished IUserRepositoryMock.Create invocations
func (mmCreate *IUserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of IUserRepositoryMock.Create invocations
func (mmCreate *IUserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mIUserRepositoryMockCreate) Calls() []*IUserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.Create")
	}
}

type mIUserRepositoryMockDelete struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockDeleteExpectation
	expectations       []*IUserRepositoryMockDeleteExpectation

	callArgs []*IUserRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockDeleteExpectation specifies expectation struct of the IUserRepository.Delete
type IUserRepositoryMockDeleteExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockDeleteParams
	results *IUserRepositoryMockDeleteResults
	Counter uint64
}

// IUserRepositoryMockDeleteParams contains parameters of the IUserRepository.Delete
type IUserRepositoryMockDeleteParams struct {
	ctx context.Context
	s1  string
}

// IUserRepositoryMockDeleteResults contains results of the IUserRepository.Delete
type IUserRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IUserRepository.Delete
func (mmDelete *mIUserRepositoryMockDelete) Expect(ctx context.Context, s1 string) *mIUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IUserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IUserRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IUserRepositoryMockDeleteParams{ctx, s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Delete
func (mmDelete *mIUserRepositoryMockDelete) Inspect(f func(ctx context.Context, s1 string)) *mIUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IUserRepository.Delete
func (mmDelete *mIUserRepositoryMockDelete) Return(err error) *IUserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IUserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IUserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IUserRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IUserRepository.Delete method
func (mmDelete *mIUserRepositoryMockDelete) Set(f func(ctx context.Context, s1 string) (err error)) *IUserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IUserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIUserRepositoryMockDelete) When(ctx context.Context, s1 string) *IUserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IUserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &IUserRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IUserRepositoryMockDeleteParams{ctx, s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockDeleteExpectation) Then(err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IUserRepository
func (mmDelete *IUserRepositoryMock) Delete(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, s1)
	}

	mm_params := &IUserRepositoryMockDeleteParams{ctx, s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IUserRepositoryMockDeleteParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IUserRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IUserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, s1)
	}
	mmDelete.t.Fatalf("Unexpected call to IUserRepositoryMock.Delete. %v %v", ctx, s1)
	return
}

// DeleteAfterCounter returns a count of finished IUserRepositoryMock.Delete invocations
func (mmDelete *IUserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IUserRepositoryMock.Delete invocations
func (mmDelete *IUserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIUserRepositoryMockDelete) Calls() []*IUserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.Delete")
	}
}

type mIUserRepositoryMockGetAll struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockGetAllExpectation
	expectations       []*IUserRepositoryMockGetAllExpectation

	callArgs []*IUserRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockGetAllExpectation specifies expectation struct of the IUserRepository.GetAll
type IUserRepositoryMockGetAllExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockGetAllParams
	results *IUserRepositoryMockGetAllResults
	Counter uint64
}

// IUserRepositoryMockGetAllParams contains parameters of the IUserRepository.GetAll
type IUserRepositoryMockGetAllParams struct {
	ctx context.Context
	pp1 *models.Paginator
}

// IUserRepositoryMockGetAllResults contains results of the IUserRepository.GetAll
type IUserRepositoryMockGetAllResults struct {
	upa1 []*models.User
	err  error
}

// Expect sets up expected params for IUserRepository.GetAll
func (mmGetAll *mIUserRepositoryMockGetAll) Expect(ctx context.Context, pp1 *models.Paginator) *mIUserRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IUserRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IUserRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &IUserRepositoryMockGetAllParams{ctx, pp1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.GetAll
func (mmGetAll *mIUserRepositoryMockGetAll) Inspect(f func(ctx context.Context, pp1 *models.Paginator)) *mIUserRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by IUserRepository.GetAll
func (mmGetAll *mIUserRepositoryMockGetAll) Return(upa1 []*models.User, err error) *IUserRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IUserRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IUserRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &IUserRepositoryMockGetAllResults{upa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the IUserRepository.GetAll method
func (mmGetAll *mIUserRepositoryMockGetAll) Set(f func(ctx context.Context, pp1 *models.Paginator) (upa1 []*models.User, err error)) *IUserRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the IUserRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the IUserRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the IUserRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mIUserRepositoryMockGetAll) When(ctx context.Context, pp1 *models.Paginator) *IUserRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IUserRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &IUserRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &IUserRepositoryMockGetAllParams{ctx, pp1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockGetAllExpectation) Then(upa1 []*models.User, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockGetAllResults{upa1, err}
	return e.mock
}

// GetAll implements interfaces.IUserRepository
func (mmGetAll *IUserRepositoryMock) GetAll(ctx context.Context, pp1 *models.Paginator) (upa1 []*models.User, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, pp1)
	}

	mm_params := &IUserRepositoryMockGetAllParams{ctx, pp1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.upa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := IUserRepositoryMockGetAllParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("IUserRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the IUserRepositoryMock.GetAll")
		}
		return (*mm_results).upa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, pp1)
	}
	mmGetAll.t.Fatalf("Unexpected call to IUserRepositoryMock.GetAll. %v %v", ctx, pp1)
	return
}

// GetAllAfterCounter returns a count of finished IUserRepositoryMock.GetAll invocations
func (mmGetAll *IUserRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of IUserRepositoryMock.GetAll invocations
func (mmGetAll *IUserRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mIUserRepositoryMockGetAll) Calls() []*IUserRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.GetAll")
	}
}

type mIUserRepositoryMockGetByID struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockGetByIDExpectation
	expectations       []*IUserRepositoryMockGetByIDExpectation

	callArgs []*IUserRepositoryMockGetByIDParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockGetByIDExpectation specifies expectation struct of the IUserRepository.GetByID
type IUserRepositoryMockGetByIDExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockGetByIDParams
	results *IUserRepositoryMockGetByIDResults
	Counter uint64
}

// IUserRepositoryMockGetByIDParams contains parameters of the IUserRepository.GetByID
type IUserRepositoryMockGetByIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IUserRepositoryMockGetByIDResults contains results of the IUserRepository.GetByID
type IUserRepositoryMockGetByIDResults struct {
	up1 *models.User
	err error
}

// Expect sets up expected params for IUserRepository.GetByID
func (mmGetByID *mIUserRepositoryMockGetByID) Expect(ctx context.Context, u1 uuid.UUID) *mIUserRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IUserRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IUserRepositoryMockGetByIDExpectation{}
	}

	mmGetByID.defaultExpectation.params = &IUserRepositoryMockGetByIDParams{ctx, u1}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.GetByID
func (mmGetByID *mIUserRepositoryMockGetByID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIUserRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by IUserRepository.GetByID
func (mmGetByID *mIUserRepositoryMockGetByID) Return(up1 *models.User, err error) *IUserRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IUserRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IUserRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &IUserRepositoryMockGetByIDResults{up1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the IUserRepository.GetByID method
func (mmGetByID *mIUserRepositoryMockGetByID) Set(f func(ctx context.Context, u1 uuid.UUID) (up1 *models.User, err error)) *IUserRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the IUserRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the IUserRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the IUserRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mIUserRepositoryMockGetByID) When(ctx context.Context, u1 uuid.UUID) *IUserRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IUserRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &IUserRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &IUserRepositoryMockGetByIDParams{ctx, u1},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockGetByIDExpectation) Then(up1 *models.User, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockGetByIDResults{up1, err}
	return e.mock
}

// GetByID implements interfaces.IUserRepository
func (mmGetByID *IUserRepositoryMock) GetByID(ctx context.Context, u1 uuid.UUID) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, u1)
	}

	mm_params := &IUserRepositoryMockGetByIDParams{ctx, u1}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_got := IUserRepositoryMockGetByIDParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("IUserRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the IUserRepositoryMock.GetByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, u1)
	}
	mmGetByID.t.Fatalf("Unexpected call to IUserRepositoryMock.GetByID. %v %v", ctx, u1)
	return
}

// GetByIDAfterCounter returns a count of finished IUserRepositoryMock.GetByID invocations
func (mmGetByID *IUserRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of IUserRepositoryMock.GetByID invocations
func (mmGetByID *IUserRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mIUserRepositoryMockGetByID) Calls() []*IUserRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.GetByID")
	}
}

type mIUserRepositoryMockGetByLogin struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockGetByLoginExpectation
	expectations       []*IUserRepositoryMockGetByLoginExpectation

	callArgs []*IUserRepositoryMockGetByLoginParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockGetByLoginExpectation specifies expectation struct of the IUserRepository.GetByLogin
type IUserRepositoryMockGetByLoginExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockGetByLoginParams
	results *IUserRepositoryMockGetByLoginResults
	Counter uint64
}

// IUserRepositoryMockGetByLoginParams contains parameters of the IUserRepository.GetByLogin
type IUserRepositoryMockGetByLoginParams struct {
	ctx context.Context
	s1  string
}

// IUserRepositoryMockGetByLoginResults contains results of the IUserRepository.GetByLogin
type IUserRepositoryMockGetByLoginResults struct {
	up1 *models.User
	err error
}

// Expect sets up expected params for IUserRepository.GetByLogin
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) Expect(ctx context.Context, s1 string) *mIUserRepositoryMockGetByLogin {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("IUserRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &IUserRepositoryMockGetByLoginExpectation{}
	}

	mmGetByLogin.defaultExpectation.params = &IUserRepositoryMockGetByLoginParams{ctx, s1}
	for _, e := range mmGetByLogin.expectations {
		if minimock.Equal(e.params, mmGetByLogin.defaultExpectation.params) {
			mmGetByLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByLogin.defaultExpectation.params)
		}
	}

	return mmGetByLogin
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.GetByLogin
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) Inspect(f func(ctx context.Context, s1 string)) *mIUserRepositoryMockGetByLogin {
	if mmGetByLogin.mock.inspectFuncGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.GetByLogin")
	}

	mmGetByLogin.mock.inspectFuncGetByLogin = f

	return mmGetByLogin
}

// Return sets up results that will be returned by IUserRepository.GetByLogin
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) Return(up1 *models.User, err error) *IUserRepositoryMock {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("IUserRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &IUserRepositoryMockGetByLoginExpectation{mock: mmGetByLogin.mock}
	}
	mmGetByLogin.defaultExpectation.results = &IUserRepositoryMockGetByLoginResults{up1, err}
	return mmGetByLogin.mock
}

// Set uses given function f to mock the IUserRepository.GetByLogin method
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) Set(f func(ctx context.Context, s1 string) (up1 *models.User, err error)) *IUserRepositoryMock {
	if mmGetByLogin.defaultExpectation != nil {
		mmGetByLogin.mock.t.Fatalf("Default expectation is already set for the IUserRepository.GetByLogin method")
	}

	if len(mmGetByLogin.expectations) > 0 {
		mmGetByLogin.mock.t.Fatalf("Some expectations are already set for the IUserRepository.GetByLogin method")
	}

	mmGetByLogin.mock.funcGetByLogin = f
	return mmGetByLogin.mock
}

// When sets expectation for the IUserRepository.GetByLogin which will trigger the result defined by the following
// Then helper
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) When(ctx context.Context, s1 string) *IUserRepositoryMockGetByLoginExpectation {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("IUserRepositoryMock.GetByLogin mock is already set by Set")
	}

	expectation := &IUserRepositoryMockGetByLoginExpectation{
		mock:   mmGetByLogin.mock,
		params: &IUserRepositoryMockGetByLoginParams{ctx, s1},
	}
	mmGetByLogin.expectations = append(mmGetByLogin.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.GetByLogin return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockGetByLoginExpectation) Then(up1 *models.User, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockGetByLoginResults{up1, err}
	return e.mock
}

// GetByLogin implements interfaces.IUserRepository
func (mmGetByLogin *IUserRepositoryMock) GetByLogin(ctx context.Context, s1 string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetByLogin.beforeGetByLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByLogin.afterGetByLoginCounter, 1)

	if mmGetByLogin.inspectFuncGetByLogin != nil {
		mmGetByLogin.inspectFuncGetByLogin(ctx, s1)
	}

	mm_params := &IUserRepositoryMockGetByLoginParams{ctx, s1}

	// Record call args
	mmGetByLogin.GetByLoginMock.mutex.Lock()
	mmGetByLogin.GetByLoginMock.callArgs = append(mmGetByLogin.GetByLoginMock.callArgs, mm_params)
	mmGetByLogin.GetByLoginMock.mutex.Unlock()

	for _, e := range mmGetByLogin.GetByLoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetByLogin.GetByLoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByLogin.GetByLoginMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByLogin.GetByLoginMock.defaultExpectation.params
		mm_got := IUserRepositoryMockGetByLoginParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByLogin.t.Errorf("IUserRepositoryMock.GetByLogin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByLogin.GetByLoginMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByLogin.t.Fatal("No results are set for the IUserRepositoryMock.GetByLogin")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetByLogin.funcGetByLogin != nil {
		return mmGetByLogin.funcGetByLogin(ctx, s1)
	}
	mmGetByLogin.t.Fatalf("Unexpected call to IUserRepositoryMock.GetByLogin. %v %v", ctx, s1)
	return
}

// GetByLoginAfterCounter returns a count of finished IUserRepositoryMock.GetByLogin invocations
func (mmGetByLogin *IUserRepositoryMock) GetByLoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByLogin.afterGetByLoginCounter)
}

// GetByLoginBeforeCounter returns a count of IUserRepositoryMock.GetByLogin invocations
func (mmGetByLogin *IUserRepositoryMock) GetByLoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByLogin.beforeGetByLoginCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.GetByLogin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByLogin *mIUserRepositoryMockGetByLogin) Calls() []*IUserRepositoryMockGetByLoginParams {
	mmGetByLogin.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockGetByLoginParams, len(mmGetByLogin.callArgs))
	copy(argCopy, mmGetByLogin.callArgs)

	mmGetByLogin.mutex.RUnlock()

	return argCopy
}

// MinimockGetByLoginDone returns true if the count of the GetByLogin invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockGetByLoginDone() bool {
	for _, e := range m.GetByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByLogin != nil && mm_atomic.LoadUint64(&m.afterGetByLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByLoginInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockGetByLoginInspect() {
	for _, e := range m.GetByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByLogin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByLoginCounter) < 1 {
		if m.GetByLoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.GetByLogin")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByLogin with params: %#v", *m.GetByLoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByLogin != nil && mm_atomic.LoadUint64(&m.afterGetByLoginCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.GetByLogin")
	}
}

type mIUserRepositoryMockGetTotal struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockGetTotalExpectation
	expectations       []*IUserRepositoryMockGetTotalExpectation

	callArgs []*IUserRepositoryMockGetTotalParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockGetTotalExpectation specifies expectation struct of the IUserRepository.GetTotal
type IUserRepositoryMockGetTotalExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockGetTotalParams
	results *IUserRepositoryMockGetTotalResults
	Counter uint64
}

// IUserRepositoryMockGetTotalParams contains parameters of the IUserRepository.GetTotal
type IUserRepositoryMockGetTotalParams struct {
	ctx context.Context
}

// IUserRepositoryMockGetTotalResults contains results of the IUserRepository.GetTotal
type IUserRepositoryMockGetTotalResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IUserRepository.GetTotal
func (mmGetTotal *mIUserRepositoryMockGetTotal) Expect(ctx context.Context) *mIUserRepositoryMockGetTotal {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("IUserRepositoryMock.GetTotal mock is already set by Set")
	}

	if mmGetTotal.defaultExpectation == nil {
		mmGetTotal.defaultExpectation = &IUserRepositoryMockGetTotalExpectation{}
	}

	mmGetTotal.defaultExpectation.params = &IUserRepositoryMockGetTotalParams{ctx}
	for _, e := range mmGetTotal.expectations {
		if minimock.Equal(e.params, mmGetTotal.defaultExpectation.params) {
			mmGetTotal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotal.defaultExpectation.params)
		}
	}

	return mmGetTotal
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.GetTotal
func (mmGetTotal *mIUserRepositoryMockGetTotal) Inspect(f func(ctx context.Context)) *mIUserRepositoryMockGetTotal {
	if mmGetTotal.mock.inspectFuncGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.GetTotal")
	}

	mmGetTotal.mock.inspectFuncGetTotal = f

	return mmGetTotal
}

// Return sets up results that will be returned by IUserRepository.GetTotal
func (mmGetTotal *mIUserRepositoryMockGetTotal) Return(i1 int, err error) *IUserRepositoryMock {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("IUserRepositoryMock.GetTotal mock is already set by Set")
	}

	if mmGetTotal.defaultExpectation == nil {
		mmGetTotal.defaultExpectation = &IUserRepositoryMockGetTotalExpectation{mock: mmGetTotal.mock}
	}
	mmGetTotal.defaultExpectation.results = &IUserRepositoryMockGetTotalResults{i1, err}
	return mmGetTotal.mock
}

// Set uses given function f to mock the IUserRepository.GetTotal method
func (mmGetTotal *mIUserRepositoryMockGetTotal) Set(f func(ctx context.Context) (i1 int, err error)) *IUserRepositoryMock {
	if mmGetTotal.defaultExpectation != nil {
		mmGetTotal.mock.t.Fatalf("Default expectation is already set for the IUserRepository.GetTotal method")
	}

	if len(mmGetTotal.expectations) > 0 {
		mmGetTotal.mock.t.Fatalf("Some expectations are already set for the IUserRepository.GetTotal method")
	}

	mmGetTotal.mock.funcGetTotal = f
	return mmGetTotal.mock
}

// When sets expectation for the IUserRepository.GetTotal which will trigger the result defined by the following
// Then helper
func (mmGetTotal *mIUserRepositoryMockGetTotal) When(ctx context.Context) *IUserRepositoryMockGetTotalExpectation {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("IUserRepositoryMock.GetTotal mock is already set by Set")
	}

	expectation := &IUserRepositoryMockGetTotalExpectation{
		mock:   mmGetTotal.mock,
		params: &IUserRepositoryMockGetTotalParams{ctx},
	}
	mmGetTotal.expectations = append(mmGetTotal.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.GetTotal return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockGetTotalExpectation) Then(i1 int, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockGetTotalResults{i1, err}
	return e.mock
}

// GetTotal implements interfaces.IUserRepository
func (mmGetTotal *IUserRepositoryMock) GetTotal(ctx context.Context) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotal.beforeGetTotalCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotal.afterGetTotalCounter, 1)

	if mmGetTotal.inspectFuncGetTotal != nil {
		mmGetTotal.inspectFuncGetTotal(ctx)
	}

	mm_params := &IUserRepositoryMockGetTotalParams{ctx}

	// Record call args
	mmGetTotal.GetTotalMock.mutex.Lock()
	mmGetTotal.GetTotalMock.callArgs = append(mmGetTotal.GetTotalMock.callArgs, mm_params)
	mmGetTotal.GetTotalMock.mutex.Unlock()

	for _, e := range mmGetTotal.GetTotalMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotal.GetTotalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotal.GetTotalMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotal.GetTotalMock.defaultExpectation.params
		mm_got := IUserRepositoryMockGetTotalParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotal.t.Errorf("IUserRepositoryMock.GetTotal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotal.GetTotalMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotal.t.Fatal("No results are set for the IUserRepositoryMock.GetTotal")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotal.funcGetTotal != nil {
		return mmGetTotal.funcGetTotal(ctx)
	}
	mmGetTotal.t.Fatalf("Unexpected call to IUserRepositoryMock.GetTotal. %v", ctx)
	return
}

// GetTotalAfterCounter returns a count of finished IUserRepositoryMock.GetTotal invocations
func (mmGetTotal *IUserRepositoryMock) GetTotalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotal.afterGetTotalCounter)
}

// GetTotalBeforeCounter returns a count of IUserRepositoryMock.GetTotal invocations
func (mmGetTotal *IUserRepositoryMock) GetTotalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotal.beforeGetTotalCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.GetTotal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotal *mIUserRepositoryMockGetTotal) Calls() []*IUserRepositoryMockGetTotalParams {
	mmGetTotal.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockGetTotalParams, len(mmGetTotal.callArgs))
	copy(argCopy, mmGetTotal.callArgs)

	mmGetTotal.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalDone returns true if the count of the GetTotal invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockGetTotalDone() bool {
	for _, e := range m.GetTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotal != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockGetTotalInspect() {
	for _, e := range m.GetTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetTotal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		if m.GetTotalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.GetTotal")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetTotal with params: %#v", *m.GetTotalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotal != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.GetTotal")
	}
}

type mIUserRepositoryMockUpdate struct {
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockUpdateExpectation
	expectations       []*IUserRepositoryMockUpdateExpectation

	callArgs []*IUserRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// IUserRepositoryMockUpdateExpectation specifies expectation struct of the IUserRepository.Update
type IUserRepositoryMockUpdateExpectation struct {
	mock    *IUserRepositoryMock
	params  *IUserRepositoryMockUpdateParams
	results *IUserRepositoryMockUpdateResults
	Counter uint64
}

// IUserRepositoryMockUpdateParams contains parameters of the IUserRepository.Update
type IUserRepositoryMockUpdateParams struct {
	ctx context.Context
	up1 *models.User
}

// IUserRepositoryMockUpdateResults contains results of the IUserRepository.Update
type IUserRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Expect(ctx context.Context, up1 *models.User) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &IUserRepositoryMockUpdateParams{ctx, up1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, up1 *models.User)) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Return(err error) *IUserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &IUserRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the IUserRepository.Update method
func (mmUpdate *mIUserRepositoryMockUpdate) Set(f func(ctx context.Context, up1 *models.User) (err error)) *IUserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the IUserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mIUserRepositoryMockUpdate) When(ctx context.Context, up1 *models.User) *IUserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &IUserRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &IUserRepositoryMockUpdateParams{ctx, up1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Update return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockUpdateExpectation) Then(err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements interfaces.IUserRepository
func (mmUpdate *IUserRepositoryMock) Update(ctx context.Context, up1 *models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, up1)
	}

	mm_params := &IUserRepositoryMockUpdateParams{ctx, up1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := IUserRepositoryMockUpdateParams{ctx, up1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("IUserRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the IUserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, up1)
	}
	mmUpdate.t.Fatalf("Unexpected call to IUserRepositoryMock.Update. %v %v", ctx, up1)
	return
}

// UpdateAfterCounter returns a count of finished IUserRepositoryMock.Update invocations
func (mmUpdate *IUserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of IUserRepositoryMock.Update invocations
func (mmUpdate *IUserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mIUserRepositoryMockUpdate) Calls() []*IUserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IUserRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to IUserRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IUserRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetAllInspect()

		m.MinimockGetByIDInspect()

		m.MinimockGetByLoginInspect()

		m.MinimockGetTotalInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IUserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IUserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockGetByLoginDone() &&
		m.MinimockGetTotalDone() &&
		m.MinimockUpdateDone()
}

package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.SubscriptionRepository -o ./internal/mocks/subscription_repository_mock_test.go -n SubscriptionRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// SubscriptionRepositoryMock implements interfaces.SubscriptionRepository
type SubscriptionRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)
	inspectFuncCreate   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mSubscriptionRepositoryMockCreate

	funcDelete          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mSubscriptionRepositoryMockDelete

	funcGet          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (sp1 *models.Subscription, err error)
	inspectFuncGet   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mSubscriptionRepositoryMockGet

	funcGetAll          func(ctx context.Context, u1 uuid.UUID) (spa1 []*models.Subscription, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mSubscriptionRepositoryMockGetAll
}

// NewSubscriptionRepositoryMock returns a mock for interfaces.SubscriptionRepository
func NewSubscriptionRepositoryMock(t minimock.Tester) *SubscriptionRepositoryMock {
	m := &SubscriptionRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mSubscriptionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*SubscriptionRepositoryMockCreateParams{}

	m.DeleteMock = mSubscriptionRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*SubscriptionRepositoryMockDeleteParams{}

	m.GetMock = mSubscriptionRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*SubscriptionRepositoryMockGetParams{}

	m.GetAllMock = mSubscriptionRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*SubscriptionRepositoryMockGetAllParams{}

	return m
}

type mSubscriptionRepositoryMockCreate struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockCreateExpectation
	expectations       []*SubscriptionRepositoryMockCreateExpectation

	callArgs []*SubscriptionRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockCreateExpectation specifies expectation struct of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockCreateParams
	results *SubscriptionRepositoryMockCreateResults
	Counter uint64
}

// SubscriptionRepositoryMockCreateParams contains parameters of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// SubscriptionRepositoryMockCreateResults contains results of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mSubscriptionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscriptionRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &SubscriptionRepositoryMockCreateParams{ctx, u1, u2}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mSubscriptionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Return(err error) *SubscriptionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscriptionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &SubscriptionRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the SubscriptionRepository.Create method
func (mmCreate *mSubscriptionRepositoryMockCreate) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)) *SubscriptionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the SubscriptionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSubscriptionRepositoryMockCreate) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *SubscriptionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &SubscriptionRepositoryMockCreateParams{ctx, u1, u2},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Create return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockCreateExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements interfaces.SubscriptionRepository
func (mmCreate *SubscriptionRepositoryMock) Create(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, u1, u2)
	}

	mm_params := &SubscriptionRepositoryMockCreateParams{ctx, u1, u2}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockCreateParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("SubscriptionRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the SubscriptionRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, u1, u2)
	}
	mmCreate.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Create. %v %v %v", ctx, u1, u2)
	return
}

// CreateAfterCounter returns a count of finished SubscriptionRepositoryMock.Create invocations
func (mmCreate *SubscriptionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of SubscriptionRepositoryMock.Create invocations
func (mmCreate *SubscriptionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSubscriptionRepositoryMockCreate) Calls() []*SubscriptionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Create")
	}
}

type mSubscriptionRepositoryMockDelete struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockDeleteExpectation
	expectations       []*SubscriptionRepositoryMockDeleteExpectation

	callArgs []*SubscriptionRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockDeleteExpectation specifies expectation struct of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockDeleteParams
	results *SubscriptionRepositoryMockDeleteResults
	Counter uint64
}

// SubscriptionRepositoryMockDeleteParams contains parameters of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// SubscriptionRepositoryMockDeleteResults contains results of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mSubscriptionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscriptionRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &SubscriptionRepositoryMockDeleteParams{ctx, u1, u2}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mSubscriptionRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Return(err error) *SubscriptionRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscriptionRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &SubscriptionRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the SubscriptionRepository.Delete method
func (mmDelete *mSubscriptionRepositoryMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)) *SubscriptionRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the SubscriptionRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mSubscriptionRepositoryMockDelete) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *SubscriptionRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &SubscriptionRepositoryMockDeleteParams{ctx, u1, u2},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Delete return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockDeleteExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.SubscriptionRepository
func (mmDelete *SubscriptionRepositoryMock) Delete(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1, u2)
	}

	mm_params := &SubscriptionRepositoryMockDeleteParams{ctx, u1, u2}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockDeleteParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("SubscriptionRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the SubscriptionRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1, u2)
	}
	mmDelete.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Delete. %v %v %v", ctx, u1, u2)
	return
}

// DeleteAfterCounter returns a count of finished SubscriptionRepositoryMock.Delete invocations
func (mmDelete *SubscriptionRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of SubscriptionRepositoryMock.Delete invocations
func (mmDelete *SubscriptionRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mSubscriptionRepositoryMockDelete) Calls() []*SubscriptionRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Delete")
	}
}

type mSubscriptionRepositoryMockGet struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockGetExpectation
	expectations       []*SubscriptionRepositoryMockGetExpectation

	callArgs []*SubscriptionRepositoryMockGetParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockGetExpectation specifies expectation struct of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockGetParams
	results *SubscriptionRepositoryMockGetResults
	Counter uint64
}

// SubscriptionRepositoryMockGetParams contains parameters of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// SubscriptionRepositoryMockGetResults contains results of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetResults struct {
	sp1 *models.Subscription
	err error
}

// Expect sets up expected params for SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mSubscriptionRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscriptionRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &SubscriptionRepositoryMockGetParams{ctx, u1, u2}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mSubscriptionRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Return(sp1 *models.Subscription, err error) *SubscriptionRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscriptionRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &SubscriptionRepositoryMockGetResults{sp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the SubscriptionRepository.Get method
func (mmGet *mSubscriptionRepositoryMockGet) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (sp1 *models.Subscription, err error)) *SubscriptionRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the SubscriptionRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mSubscriptionRepositoryMockGet) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *SubscriptionRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &SubscriptionRepositoryMockGetParams{ctx, u1, u2},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Get return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockGetExpectation) Then(sp1 *models.Subscription, err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockGetResults{sp1, err}
	return e.mock
}

// Get implements interfaces.SubscriptionRepository
func (mmGet *SubscriptionRepositoryMock) Get(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (sp1 *models.Subscription, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, u1, u2)
	}

	mm_params := &SubscriptionRepositoryMockGetParams{ctx, u1, u2}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockGetParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("SubscriptionRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the SubscriptionRepositoryMock.Get")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, u1, u2)
	}
	mmGet.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Get. %v %v %v", ctx, u1, u2)
	return
}

// GetAfterCounter returns a count of finished SubscriptionRepositoryMock.Get invocations
func (mmGet *SubscriptionRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of SubscriptionRepositoryMock.Get invocations
func (mmGet *SubscriptionRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mSubscriptionRepositoryMockGet) Calls() []*SubscriptionRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Get")
	}
}

type mSubscriptionRepositoryMockGetAll struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockGetAllExpectation
	expectations       []*SubscriptionRepositoryMockGetAllExpectation

	callArgs []*SubscriptionRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockGetAllExpectation specifies expectation struct of the SubscriptionRepository.GetAll
type SubscriptionRepositoryMockGetAllExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockGetAllParams
	results *SubscriptionRepositoryMockGetAllResults
	Counter uint64
}

// SubscriptionRepositoryMockGetAllParams contains parameters of the SubscriptionRepository.GetAll
type SubscriptionRepositoryMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// SubscriptionRepositoryMockGetAllResults contains results of the SubscriptionRepository.GetAll
type SubscriptionRepositoryMockGetAllResults struct {
	spa1 []*models.Subscription
	err  error
}

// Expect sets up expected params for SubscriptionRepository.GetAll
func (mmGetAll *mSubscriptionRepositoryMockGetAll) Expect(ctx context.Context, u1 uuid.UUID) *mSubscriptionRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("SubscriptionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &SubscriptionRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &SubscriptionRepositoryMockGetAllParams{ctx, u1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.GetAll
func (mmGetAll *mSubscriptionRepositoryMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mSubscriptionRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by SubscriptionRepository.GetAll
func (mmGetAll *mSubscriptionRepositoryMockGetAll) Return(spa1 []*models.Subscription, err error) *SubscriptionRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("SubscriptionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &SubscriptionRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &SubscriptionRepositoryMockGetAllResults{spa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the SubscriptionRepository.GetAll method
func (mmGetAll *mSubscriptionRepositoryMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID) (spa1 []*models.Subscription, err error)) *SubscriptionRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the SubscriptionRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mSubscriptionRepositoryMockGetAll) When(ctx context.Context, u1 uuid.UUID) *SubscriptionRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("SubscriptionRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &SubscriptionRepositoryMockGetAllParams{ctx, u1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockGetAllExpectation) Then(spa1 []*models.Subscription, err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockGetAllResults{spa1, err}
	return e.mock
}

// GetAll implements interfaces.SubscriptionRepository
func (mmGetAll *SubscriptionRepositoryMock) GetAll(ctx context.Context, u1 uuid.UUID) (spa1 []*models.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1)
	}

	mm_params := &SubscriptionRepositoryMockGetAllParams{ctx, u1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockGetAllParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("SubscriptionRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the SubscriptionRepositoryMock.GetAll")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1)
	}
	mmGetAll.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.GetAll. %v %v", ctx, u1)
	return
}

// GetAllAfterCounter returns a count of finished SubscriptionRepositoryMock.GetAll invocations
func (mmGetAll *SubscriptionRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of SubscriptionRepositoryMock.GetAll invocations
func (mmGetAll *SubscriptionRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mSubscriptionRepositoryMockGetAll) Calls() []*SubscriptionRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.GetAll")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubscriptionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone()
}

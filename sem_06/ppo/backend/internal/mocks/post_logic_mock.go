package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.IPostLogic -o ./internal/mocks/i_post_logic_mock_test.go -n IPostLogicMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IPostLogicMock implements interfaces.IPostLogic
type IPostLogicMock struct {
	t minimock.Tester

	funcChangePerms          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncChangePerms   func(ctx context.Context, u1 uuid.UUID)
	afterChangePermsCounter  uint64
	beforeChangePermsCounter uint64
	ChangePermsMock          mIPostLogicMockChangePerms

	funcComment          func(ctx context.Context, comm *models.Comment) (cp1 *models.Comment, err error)
	inspectFuncComment   func(ctx context.Context, comm *models.Comment)
	afterCommentCounter  uint64
	beforeCommentCounter uint64
	CommentMock          mIPostLogicMockComment

	funcDelete          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIPostLogicMockDelete

	funcGet          func(ctx context.Context, postID uuid.UUID) (pp1 *models.Post, err error)
	inspectFuncGet   func(ctx context.Context, postID uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mIPostLogicMockGet

	funcGetAll          func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mIPostLogicMockGetAll

	funcGetAllComments          func(ctx context.Context, postID uuid.UUID, p *models.Paginator) (cpa1 []*models.Comment, err error)
	inspectFuncGetAllComments   func(ctx context.Context, postID uuid.UUID, p *models.Paginator)
	afterGetAllCommentsCounter  uint64
	beforeGetAllCommentsCounter uint64
	GetAllCommentsMock          mIPostLogicMockGetAllComments

	funcGetReactionTypes          func(ctx context.Context) (rpa1 []*models.ReactionType, err error)
	inspectFuncGetReactionTypes   func(ctx context.Context)
	afterGetReactionTypesCounter  uint64
	beforeGetReactionTypesCounter uint64
	GetReactionTypesMock          mIPostLogicMockGetReactionTypes

	funcGetTotalByUserID          func(ctx context.Context, userID uuid.UUID) (i1 int, err error)
	inspectFuncGetTotalByUserID   func(ctx context.Context, userID uuid.UUID)
	afterGetTotalByUserIDCounter  uint64
	beforeGetTotalByUserIDCounter uint64
	GetTotalByUserIDMock          mIPostLogicMockGetTotalByUserID

	funcGetTotalCommentsByPostID          func(ctx context.Context, postID uuid.UUID) (i1 int, err error)
	inspectFuncGetTotalCommentsByPostID   func(ctx context.Context, postID uuid.UUID)
	afterGetTotalCommentsByPostIDCounter  uint64
	beforeGetTotalCommentsByPostIDCounter uint64
	GetTotalCommentsByPostIDMock          mIPostLogicMockGetTotalCommentsByPostID

	funcPopularityCheck          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncPopularityCheck   func(ctx context.Context, u1 uuid.UUID)
	afterPopularityCheckCounter  uint64
	beforePopularityCheckCounter uint64
	PopularityCheckMock          mIPostLogicMockPopularityCheck

	funcPublish          func(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error)
	inspectFuncPublish   func(ctx context.Context, pp1 *models.Post)
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mIPostLogicMockPublish

	funcReact          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)
	inspectFuncReact   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterReactCounter  uint64
	beforeReactCounter uint64
	ReactMock          mIPostLogicMockReact

	funcUncomment          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncUncomment   func(ctx context.Context, id uuid.UUID)
	afterUncommentCounter  uint64
	beforeUncommentCounter uint64
	UncommentMock          mIPostLogicMockUncomment

	funcView          func(ctx context.Context, pp1 *models.Post, u1 uuid.UUID) (b1 bool, err error)
	inspectFuncView   func(ctx context.Context, pp1 *models.Post, u1 uuid.UUID)
	afterViewCounter  uint64
	beforeViewCounter uint64
	ViewMock          mIPostLogicMockView
}

// NewIPostLogicMock returns a mock for interfaces.IPostLogic
func NewIPostLogicMock(t minimock.Tester) *IPostLogicMock {
	m := &IPostLogicMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangePermsMock = mIPostLogicMockChangePerms{mock: m}
	m.ChangePermsMock.callArgs = []*IPostLogicMockChangePermsParams{}

	m.CommentMock = mIPostLogicMockComment{mock: m}
	m.CommentMock.callArgs = []*IPostLogicMockCommentParams{}

	m.DeleteMock = mIPostLogicMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IPostLogicMockDeleteParams{}

	m.GetMock = mIPostLogicMockGet{mock: m}
	m.GetMock.callArgs = []*IPostLogicMockGetParams{}

	m.GetAllMock = mIPostLogicMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*IPostLogicMockGetAllParams{}

	m.GetAllCommentsMock = mIPostLogicMockGetAllComments{mock: m}
	m.GetAllCommentsMock.callArgs = []*IPostLogicMockGetAllCommentsParams{}

	m.GetReactionTypesMock = mIPostLogicMockGetReactionTypes{mock: m}
	m.GetReactionTypesMock.callArgs = []*IPostLogicMockGetReactionTypesParams{}

	m.GetTotalByUserIDMock = mIPostLogicMockGetTotalByUserID{mock: m}
	m.GetTotalByUserIDMock.callArgs = []*IPostLogicMockGetTotalByUserIDParams{}

	m.GetTotalCommentsByPostIDMock = mIPostLogicMockGetTotalCommentsByPostID{mock: m}
	m.GetTotalCommentsByPostIDMock.callArgs = []*IPostLogicMockGetTotalCommentsByPostIDParams{}

	m.PopularityCheckMock = mIPostLogicMockPopularityCheck{mock: m}
	m.PopularityCheckMock.callArgs = []*IPostLogicMockPopularityCheckParams{}

	m.PublishMock = mIPostLogicMockPublish{mock: m}
	m.PublishMock.callArgs = []*IPostLogicMockPublishParams{}

	m.ReactMock = mIPostLogicMockReact{mock: m}
	m.ReactMock.callArgs = []*IPostLogicMockReactParams{}

	m.UncommentMock = mIPostLogicMockUncomment{mock: m}
	m.UncommentMock.callArgs = []*IPostLogicMockUncommentParams{}

	m.ViewMock = mIPostLogicMockView{mock: m}
	m.ViewMock.callArgs = []*IPostLogicMockViewParams{}

	return m
}

type mIPostLogicMockChangePerms struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockChangePermsExpectation
	expectations       []*IPostLogicMockChangePermsExpectation

	callArgs []*IPostLogicMockChangePermsParams
	mutex    sync.RWMutex
}

// IPostLogicMockChangePermsExpectation specifies expectation struct of the IPostLogic.ChangePerms
type IPostLogicMockChangePermsExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockChangePermsParams
	results *IPostLogicMockChangePermsResults
	Counter uint64
}

// IPostLogicMockChangePermsParams contains parameters of the IPostLogic.ChangePerms
type IPostLogicMockChangePermsParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IPostLogicMockChangePermsResults contains results of the IPostLogic.ChangePerms
type IPostLogicMockChangePermsResults struct {
	err error
}

// Expect sets up expected params for IPostLogic.ChangePerms
func (mmChangePerms *mIPostLogicMockChangePerms) Expect(ctx context.Context, u1 uuid.UUID) *mIPostLogicMockChangePerms {
	if mmChangePerms.mock.funcChangePerms != nil {
		mmChangePerms.mock.t.Fatalf("IPostLogicMock.ChangePerms mock is already set by Set")
	}

	if mmChangePerms.defaultExpectation == nil {
		mmChangePerms.defaultExpectation = &IPostLogicMockChangePermsExpectation{}
	}

	mmChangePerms.defaultExpectation.params = &IPostLogicMockChangePermsParams{ctx, u1}
	for _, e := range mmChangePerms.expectations {
		if minimock.Equal(e.params, mmChangePerms.defaultExpectation.params) {
			mmChangePerms.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangePerms.defaultExpectation.params)
		}
	}

	return mmChangePerms
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.ChangePerms
func (mmChangePerms *mIPostLogicMockChangePerms) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIPostLogicMockChangePerms {
	if mmChangePerms.mock.inspectFuncChangePerms != nil {
		mmChangePerms.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.ChangePerms")
	}

	mmChangePerms.mock.inspectFuncChangePerms = f

	return mmChangePerms
}

// Return sets up results that will be returned by IPostLogic.ChangePerms
func (mmChangePerms *mIPostLogicMockChangePerms) Return(err error) *IPostLogicMock {
	if mmChangePerms.mock.funcChangePerms != nil {
		mmChangePerms.mock.t.Fatalf("IPostLogicMock.ChangePerms mock is already set by Set")
	}

	if mmChangePerms.defaultExpectation == nil {
		mmChangePerms.defaultExpectation = &IPostLogicMockChangePermsExpectation{mock: mmChangePerms.mock}
	}
	mmChangePerms.defaultExpectation.results = &IPostLogicMockChangePermsResults{err}
	return mmChangePerms.mock
}

// Set uses given function f to mock the IPostLogic.ChangePerms method
func (mmChangePerms *mIPostLogicMockChangePerms) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *IPostLogicMock {
	if mmChangePerms.defaultExpectation != nil {
		mmChangePerms.mock.t.Fatalf("Default expectation is already set for the IPostLogic.ChangePerms method")
	}

	if len(mmChangePerms.expectations) > 0 {
		mmChangePerms.mock.t.Fatalf("Some expectations are already set for the IPostLogic.ChangePerms method")
	}

	mmChangePerms.mock.funcChangePerms = f
	return mmChangePerms.mock
}

// When sets expectation for the IPostLogic.ChangePerms which will trigger the result defined by the following
// Then helper
func (mmChangePerms *mIPostLogicMockChangePerms) When(ctx context.Context, u1 uuid.UUID) *IPostLogicMockChangePermsExpectation {
	if mmChangePerms.mock.funcChangePerms != nil {
		mmChangePerms.mock.t.Fatalf("IPostLogicMock.ChangePerms mock is already set by Set")
	}

	expectation := &IPostLogicMockChangePermsExpectation{
		mock:   mmChangePerms.mock,
		params: &IPostLogicMockChangePermsParams{ctx, u1},
	}
	mmChangePerms.expectations = append(mmChangePerms.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.ChangePerms return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockChangePermsExpectation) Then(err error) *IPostLogicMock {
	e.results = &IPostLogicMockChangePermsResults{err}
	return e.mock
}

// ChangePerms implements interfaces.IPostLogic
func (mmChangePerms *IPostLogicMock) ChangePerms(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmChangePerms.beforeChangePermsCounter, 1)
	defer mm_atomic.AddUint64(&mmChangePerms.afterChangePermsCounter, 1)

	if mmChangePerms.inspectFuncChangePerms != nil {
		mmChangePerms.inspectFuncChangePerms(ctx, u1)
	}

	mm_params := &IPostLogicMockChangePermsParams{ctx, u1}

	// Record call args
	mmChangePerms.ChangePermsMock.mutex.Lock()
	mmChangePerms.ChangePermsMock.callArgs = append(mmChangePerms.ChangePermsMock.callArgs, mm_params)
	mmChangePerms.ChangePermsMock.mutex.Unlock()

	for _, e := range mmChangePerms.ChangePermsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangePerms.ChangePermsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangePerms.ChangePermsMock.defaultExpectation.Counter, 1)
		mm_want := mmChangePerms.ChangePermsMock.defaultExpectation.params
		mm_got := IPostLogicMockChangePermsParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangePerms.t.Errorf("IPostLogicMock.ChangePerms got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangePerms.ChangePermsMock.defaultExpectation.results
		if mm_results == nil {
			mmChangePerms.t.Fatal("No results are set for the IPostLogicMock.ChangePerms")
		}
		return (*mm_results).err
	}
	if mmChangePerms.funcChangePerms != nil {
		return mmChangePerms.funcChangePerms(ctx, u1)
	}
	mmChangePerms.t.Fatalf("Unexpected call to IPostLogicMock.ChangePerms. %v %v", ctx, u1)
	return
}

// ChangePermsAfterCounter returns a count of finished IPostLogicMock.ChangePerms invocations
func (mmChangePerms *IPostLogicMock) ChangePermsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePerms.afterChangePermsCounter)
}

// ChangePermsBeforeCounter returns a count of IPostLogicMock.ChangePerms invocations
func (mmChangePerms *IPostLogicMock) ChangePermsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePerms.beforeChangePermsCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.ChangePerms.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangePerms *mIPostLogicMockChangePerms) Calls() []*IPostLogicMockChangePermsParams {
	mmChangePerms.mutex.RLock()

	argCopy := make([]*IPostLogicMockChangePermsParams, len(mmChangePerms.callArgs))
	copy(argCopy, mmChangePerms.callArgs)

	mmChangePerms.mutex.RUnlock()

	return argCopy
}

// MinimockChangePermsDone returns true if the count of the ChangePerms invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockChangePermsDone() bool {
	for _, e := range m.ChangePermsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangePermsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangePermsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangePerms != nil && mm_atomic.LoadUint64(&m.afterChangePermsCounter) < 1 {
		return false
	}
	return true
}

// MinimockChangePermsInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockChangePermsInspect() {
	for _, e := range m.ChangePermsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.ChangePerms with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangePermsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangePermsCounter) < 1 {
		if m.ChangePermsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.ChangePerms")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.ChangePerms with params: %#v", *m.ChangePermsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangePerms != nil && mm_atomic.LoadUint64(&m.afterChangePermsCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.ChangePerms")
	}
}

type mIPostLogicMockComment struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockCommentExpectation
	expectations       []*IPostLogicMockCommentExpectation

	callArgs []*IPostLogicMockCommentParams
	mutex    sync.RWMutex
}

// IPostLogicMockCommentExpectation specifies expectation struct of the IPostLogic.Comment
type IPostLogicMockCommentExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockCommentParams
	results *IPostLogicMockCommentResults
	Counter uint64
}

// IPostLogicMockCommentParams contains parameters of the IPostLogic.Comment
type IPostLogicMockCommentParams struct {
	ctx  context.Context
	comm *models.Comment
}

// IPostLogicMockCommentResults contains results of the IPostLogic.Comment
type IPostLogicMockCommentResults struct {
	cp1 *models.Comment
	err error
}

// Expect sets up expected params for IPostLogic.Comment
func (mmComment *mIPostLogicMockComment) Expect(ctx context.Context, comm *models.Comment) *mIPostLogicMockComment {
	if mmComment.mock.funcComment != nil {
		mmComment.mock.t.Fatalf("IPostLogicMock.Comment mock is already set by Set")
	}

	if mmComment.defaultExpectation == nil {
		mmComment.defaultExpectation = &IPostLogicMockCommentExpectation{}
	}

	mmComment.defaultExpectation.params = &IPostLogicMockCommentParams{ctx, comm}
	for _, e := range mmComment.expectations {
		if minimock.Equal(e.params, mmComment.defaultExpectation.params) {
			mmComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmComment.defaultExpectation.params)
		}
	}

	return mmComment
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.Comment
func (mmComment *mIPostLogicMockComment) Inspect(f func(ctx context.Context, comm *models.Comment)) *mIPostLogicMockComment {
	if mmComment.mock.inspectFuncComment != nil {
		mmComment.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.Comment")
	}

	mmComment.mock.inspectFuncComment = f

	return mmComment
}

// Return sets up results that will be returned by IPostLogic.Comment
func (mmComment *mIPostLogicMockComment) Return(cp1 *models.Comment, err error) *IPostLogicMock {
	if mmComment.mock.funcComment != nil {
		mmComment.mock.t.Fatalf("IPostLogicMock.Comment mock is already set by Set")
	}

	if mmComment.defaultExpectation == nil {
		mmComment.defaultExpectation = &IPostLogicMockCommentExpectation{mock: mmComment.mock}
	}
	mmComment.defaultExpectation.results = &IPostLogicMockCommentResults{cp1, err}
	return mmComment.mock
}

// Set uses given function f to mock the IPostLogic.Comment method
func (mmComment *mIPostLogicMockComment) Set(f func(ctx context.Context, comm *models.Comment) (cp1 *models.Comment, err error)) *IPostLogicMock {
	if mmComment.defaultExpectation != nil {
		mmComment.mock.t.Fatalf("Default expectation is already set for the IPostLogic.Comment method")
	}

	if len(mmComment.expectations) > 0 {
		mmComment.mock.t.Fatalf("Some expectations are already set for the IPostLogic.Comment method")
	}

	mmComment.mock.funcComment = f
	return mmComment.mock
}

// When sets expectation for the IPostLogic.Comment which will trigger the result defined by the following
// Then helper
func (mmComment *mIPostLogicMockComment) When(ctx context.Context, comm *models.Comment) *IPostLogicMockCommentExpectation {
	if mmComment.mock.funcComment != nil {
		mmComment.mock.t.Fatalf("IPostLogicMock.Comment mock is already set by Set")
	}

	expectation := &IPostLogicMockCommentExpectation{
		mock:   mmComment.mock,
		params: &IPostLogicMockCommentParams{ctx, comm},
	}
	mmComment.expectations = append(mmComment.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.Comment return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockCommentExpectation) Then(cp1 *models.Comment, err error) *IPostLogicMock {
	e.results = &IPostLogicMockCommentResults{cp1, err}
	return e.mock
}

// Comment implements interfaces.IPostLogic
func (mmComment *IPostLogicMock) Comment(ctx context.Context, comm *models.Comment) (cp1 *models.Comment, err error) {
	mm_atomic.AddUint64(&mmComment.beforeCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmComment.afterCommentCounter, 1)

	if mmComment.inspectFuncComment != nil {
		mmComment.inspectFuncComment(ctx, comm)
	}

	mm_params := &IPostLogicMockCommentParams{ctx, comm}

	// Record call args
	mmComment.CommentMock.mutex.Lock()
	mmComment.CommentMock.callArgs = append(mmComment.CommentMock.callArgs, mm_params)
	mmComment.CommentMock.mutex.Unlock()

	for _, e := range mmComment.CommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmComment.CommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmComment.CommentMock.defaultExpectation.Counter, 1)
		mm_want := mmComment.CommentMock.defaultExpectation.params
		mm_got := IPostLogicMockCommentParams{ctx, comm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmComment.t.Errorf("IPostLogicMock.Comment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmComment.CommentMock.defaultExpectation.results
		if mm_results == nil {
			mmComment.t.Fatal("No results are set for the IPostLogicMock.Comment")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmComment.funcComment != nil {
		return mmComment.funcComment(ctx, comm)
	}
	mmComment.t.Fatalf("Unexpected call to IPostLogicMock.Comment. %v %v", ctx, comm)
	return
}

// CommentAfterCounter returns a count of finished IPostLogicMock.Comment invocations
func (mmComment *IPostLogicMock) CommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmComment.afterCommentCounter)
}

// CommentBeforeCounter returns a count of IPostLogicMock.Comment invocations
func (mmComment *IPostLogicMock) CommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmComment.beforeCommentCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.Comment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmComment *mIPostLogicMockComment) Calls() []*IPostLogicMockCommentParams {
	mmComment.mutex.RLock()

	argCopy := make([]*IPostLogicMockCommentParams, len(mmComment.callArgs))
	copy(argCopy, mmComment.callArgs)

	mmComment.mutex.RUnlock()

	return argCopy
}

// MinimockCommentDone returns true if the count of the Comment invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockCommentDone() bool {
	for _, e := range m.CommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcComment != nil && mm_atomic.LoadUint64(&m.afterCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommentInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockCommentInspect() {
	for _, e := range m.CommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.Comment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommentCounter) < 1 {
		if m.CommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.Comment")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.Comment with params: %#v", *m.CommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcComment != nil && mm_atomic.LoadUint64(&m.afterCommentCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.Comment")
	}
}

type mIPostLogicMockDelete struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockDeleteExpectation
	expectations       []*IPostLogicMockDeleteExpectation

	callArgs []*IPostLogicMockDeleteParams
	mutex    sync.RWMutex
}

// IPostLogicMockDeleteExpectation specifies expectation struct of the IPostLogic.Delete
type IPostLogicMockDeleteExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockDeleteParams
	results *IPostLogicMockDeleteResults
	Counter uint64
}

// IPostLogicMockDeleteParams contains parameters of the IPostLogic.Delete
type IPostLogicMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IPostLogicMockDeleteResults contains results of the IPostLogic.Delete
type IPostLogicMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IPostLogic.Delete
func (mmDelete *mIPostLogicMockDelete) Expect(ctx context.Context, u1 uuid.UUID) *mIPostLogicMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostLogicMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IPostLogicMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IPostLogicMockDeleteParams{ctx, u1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.Delete
func (mmDelete *mIPostLogicMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIPostLogicMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IPostLogic.Delete
func (mmDelete *mIPostLogicMockDelete) Return(err error) *IPostLogicMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostLogicMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IPostLogicMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IPostLogicMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IPostLogic.Delete method
func (mmDelete *mIPostLogicMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *IPostLogicMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IPostLogic.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IPostLogic.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IPostLogic.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIPostLogicMockDelete) When(ctx context.Context, u1 uuid.UUID) *IPostLogicMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IPostLogicMock.Delete mock is already set by Set")
	}

	expectation := &IPostLogicMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IPostLogicMockDeleteParams{ctx, u1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.Delete return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockDeleteExpectation) Then(err error) *IPostLogicMock {
	e.results = &IPostLogicMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IPostLogic
func (mmDelete *IPostLogicMock) Delete(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1)
	}

	mm_params := &IPostLogicMockDeleteParams{ctx, u1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IPostLogicMockDeleteParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IPostLogicMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IPostLogicMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1)
	}
	mmDelete.t.Fatalf("Unexpected call to IPostLogicMock.Delete. %v %v", ctx, u1)
	return
}

// DeleteAfterCounter returns a count of finished IPostLogicMock.Delete invocations
func (mmDelete *IPostLogicMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IPostLogicMock.Delete invocations
func (mmDelete *IPostLogicMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIPostLogicMockDelete) Calls() []*IPostLogicMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IPostLogicMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.Delete")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.Delete")
	}
}

type mIPostLogicMockGet struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetExpectation
	expectations       []*IPostLogicMockGetExpectation

	callArgs []*IPostLogicMockGetParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetExpectation specifies expectation struct of the IPostLogic.Get
type IPostLogicMockGetExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetParams
	results *IPostLogicMockGetResults
	Counter uint64
}

// IPostLogicMockGetParams contains parameters of the IPostLogic.Get
type IPostLogicMockGetParams struct {
	ctx    context.Context
	postID uuid.UUID
}

// IPostLogicMockGetResults contains results of the IPostLogic.Get
type IPostLogicMockGetResults struct {
	pp1 *models.Post
	err error
}

// Expect sets up expected params for IPostLogic.Get
func (mmGet *mIPostLogicMockGet) Expect(ctx context.Context, postID uuid.UUID) *mIPostLogicMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostLogicMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IPostLogicMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &IPostLogicMockGetParams{ctx, postID}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.Get
func (mmGet *mIPostLogicMockGet) Inspect(f func(ctx context.Context, postID uuid.UUID)) *mIPostLogicMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by IPostLogic.Get
func (mmGet *mIPostLogicMockGet) Return(pp1 *models.Post, err error) *IPostLogicMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostLogicMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IPostLogicMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &IPostLogicMockGetResults{pp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the IPostLogic.Get method
func (mmGet *mIPostLogicMockGet) Set(f func(ctx context.Context, postID uuid.UUID) (pp1 *models.Post, err error)) *IPostLogicMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the IPostLogic.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the IPostLogic.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the IPostLogic.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mIPostLogicMockGet) When(ctx context.Context, postID uuid.UUID) *IPostLogicMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IPostLogicMock.Get mock is already set by Set")
	}

	expectation := &IPostLogicMockGetExpectation{
		mock:   mmGet.mock,
		params: &IPostLogicMockGetParams{ctx, postID},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.Get return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetExpectation) Then(pp1 *models.Post, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetResults{pp1, err}
	return e.mock
}

// Get implements interfaces.IPostLogic
func (mmGet *IPostLogicMock) Get(ctx context.Context, postID uuid.UUID) (pp1 *models.Post, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, postID)
	}

	mm_params := &IPostLogicMockGetParams{ctx, postID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := IPostLogicMockGetParams{ctx, postID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("IPostLogicMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the IPostLogicMock.Get")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, postID)
	}
	mmGet.t.Fatalf("Unexpected call to IPostLogicMock.Get. %v %v", ctx, postID)
	return
}

// GetAfterCounter returns a count of finished IPostLogicMock.Get invocations
func (mmGet *IPostLogicMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of IPostLogicMock.Get invocations
func (mmGet *IPostLogicMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mIPostLogicMockGet) Calls() []*IPostLogicMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.Get")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.Get")
	}
}

type mIPostLogicMockGetAll struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetAllExpectation
	expectations       []*IPostLogicMockGetAllExpectation

	callArgs []*IPostLogicMockGetAllParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetAllExpectation specifies expectation struct of the IPostLogic.GetAll
type IPostLogicMockGetAllExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetAllParams
	results *IPostLogicMockGetAllResults
	Counter uint64
}

// IPostLogicMockGetAllParams contains parameters of the IPostLogic.GetAll
type IPostLogicMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
	pp1 *models.Paginator
}

// IPostLogicMockGetAllResults contains results of the IPostLogic.GetAll
type IPostLogicMockGetAllResults struct {
	ppa1 []*models.Post
	err  error
}

// Expect sets up expected params for IPostLogic.GetAll
func (mmGetAll *mIPostLogicMockGetAll) Expect(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *mIPostLogicMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostLogicMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IPostLogicMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &IPostLogicMockGetAllParams{ctx, u1, pp1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.GetAll
func (mmGetAll *mIPostLogicMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)) *mIPostLogicMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by IPostLogic.GetAll
func (mmGetAll *mIPostLogicMockGetAll) Return(ppa1 []*models.Post, err error) *IPostLogicMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostLogicMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &IPostLogicMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &IPostLogicMockGetAllResults{ppa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the IPostLogic.GetAll method
func (mmGetAll *mIPostLogicMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error)) *IPostLogicMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the IPostLogic.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the IPostLogic.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the IPostLogic.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mIPostLogicMockGetAll) When(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *IPostLogicMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("IPostLogicMock.GetAll mock is already set by Set")
	}

	expectation := &IPostLogicMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &IPostLogicMockGetAllParams{ctx, u1, pp1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.GetAll return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetAllExpectation) Then(ppa1 []*models.Post, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetAllResults{ppa1, err}
	return e.mock
}

// GetAll implements interfaces.IPostLogic
func (mmGetAll *IPostLogicMock) GetAll(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (ppa1 []*models.Post, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1, pp1)
	}

	mm_params := &IPostLogicMockGetAllParams{ctx, u1, pp1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := IPostLogicMockGetAllParams{ctx, u1, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("IPostLogicMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the IPostLogicMock.GetAll")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1, pp1)
	}
	mmGetAll.t.Fatalf("Unexpected call to IPostLogicMock.GetAll. %v %v %v", ctx, u1, pp1)
	return
}

// GetAllAfterCounter returns a count of finished IPostLogicMock.GetAll invocations
func (mmGetAll *IPostLogicMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of IPostLogicMock.GetAll invocations
func (mmGetAll *IPostLogicMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mIPostLogicMockGetAll) Calls() []*IPostLogicMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.GetAll")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.GetAll")
	}
}

type mIPostLogicMockGetAllComments struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetAllCommentsExpectation
	expectations       []*IPostLogicMockGetAllCommentsExpectation

	callArgs []*IPostLogicMockGetAllCommentsParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetAllCommentsExpectation specifies expectation struct of the IPostLogic.GetAllComments
type IPostLogicMockGetAllCommentsExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetAllCommentsParams
	results *IPostLogicMockGetAllCommentsResults
	Counter uint64
}

// IPostLogicMockGetAllCommentsParams contains parameters of the IPostLogic.GetAllComments
type IPostLogicMockGetAllCommentsParams struct {
	ctx    context.Context
	postID uuid.UUID
	p      *models.Paginator
}

// IPostLogicMockGetAllCommentsResults contains results of the IPostLogic.GetAllComments
type IPostLogicMockGetAllCommentsResults struct {
	cpa1 []*models.Comment
	err  error
}

// Expect sets up expected params for IPostLogic.GetAllComments
func (mmGetAllComments *mIPostLogicMockGetAllComments) Expect(ctx context.Context, postID uuid.UUID, p *models.Paginator) *mIPostLogicMockGetAllComments {
	if mmGetAllComments.mock.funcGetAllComments != nil {
		mmGetAllComments.mock.t.Fatalf("IPostLogicMock.GetAllComments mock is already set by Set")
	}

	if mmGetAllComments.defaultExpectation == nil {
		mmGetAllComments.defaultExpectation = &IPostLogicMockGetAllCommentsExpectation{}
	}

	mmGetAllComments.defaultExpectation.params = &IPostLogicMockGetAllCommentsParams{ctx, postID, p}
	for _, e := range mmGetAllComments.expectations {
		if minimock.Equal(e.params, mmGetAllComments.defaultExpectation.params) {
			mmGetAllComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllComments.defaultExpectation.params)
		}
	}

	return mmGetAllComments
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.GetAllComments
func (mmGetAllComments *mIPostLogicMockGetAllComments) Inspect(f func(ctx context.Context, postID uuid.UUID, p *models.Paginator)) *mIPostLogicMockGetAllComments {
	if mmGetAllComments.mock.inspectFuncGetAllComments != nil {
		mmGetAllComments.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.GetAllComments")
	}

	mmGetAllComments.mock.inspectFuncGetAllComments = f

	return mmGetAllComments
}

// Return sets up results that will be returned by IPostLogic.GetAllComments
func (mmGetAllComments *mIPostLogicMockGetAllComments) Return(cpa1 []*models.Comment, err error) *IPostLogicMock {
	if mmGetAllComments.mock.funcGetAllComments != nil {
		mmGetAllComments.mock.t.Fatalf("IPostLogicMock.GetAllComments mock is already set by Set")
	}

	if mmGetAllComments.defaultExpectation == nil {
		mmGetAllComments.defaultExpectation = &IPostLogicMockGetAllCommentsExpectation{mock: mmGetAllComments.mock}
	}
	mmGetAllComments.defaultExpectation.results = &IPostLogicMockGetAllCommentsResults{cpa1, err}
	return mmGetAllComments.mock
}

// Set uses given function f to mock the IPostLogic.GetAllComments method
func (mmGetAllComments *mIPostLogicMockGetAllComments) Set(f func(ctx context.Context, postID uuid.UUID, p *models.Paginator) (cpa1 []*models.Comment, err error)) *IPostLogicMock {
	if mmGetAllComments.defaultExpectation != nil {
		mmGetAllComments.mock.t.Fatalf("Default expectation is already set for the IPostLogic.GetAllComments method")
	}

	if len(mmGetAllComments.expectations) > 0 {
		mmGetAllComments.mock.t.Fatalf("Some expectations are already set for the IPostLogic.GetAllComments method")
	}

	mmGetAllComments.mock.funcGetAllComments = f
	return mmGetAllComments.mock
}

// When sets expectation for the IPostLogic.GetAllComments which will trigger the result defined by the following
// Then helper
func (mmGetAllComments *mIPostLogicMockGetAllComments) When(ctx context.Context, postID uuid.UUID, p *models.Paginator) *IPostLogicMockGetAllCommentsExpectation {
	if mmGetAllComments.mock.funcGetAllComments != nil {
		mmGetAllComments.mock.t.Fatalf("IPostLogicMock.GetAllComments mock is already set by Set")
	}

	expectation := &IPostLogicMockGetAllCommentsExpectation{
		mock:   mmGetAllComments.mock,
		params: &IPostLogicMockGetAllCommentsParams{ctx, postID, p},
	}
	mmGetAllComments.expectations = append(mmGetAllComments.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.GetAllComments return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetAllCommentsExpectation) Then(cpa1 []*models.Comment, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetAllCommentsResults{cpa1, err}
	return e.mock
}

// GetAllComments implements interfaces.IPostLogic
func (mmGetAllComments *IPostLogicMock) GetAllComments(ctx context.Context, postID uuid.UUID, p *models.Paginator) (cpa1 []*models.Comment, err error) {
	mm_atomic.AddUint64(&mmGetAllComments.beforeGetAllCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllComments.afterGetAllCommentsCounter, 1)

	if mmGetAllComments.inspectFuncGetAllComments != nil {
		mmGetAllComments.inspectFuncGetAllComments(ctx, postID, p)
	}

	mm_params := &IPostLogicMockGetAllCommentsParams{ctx, postID, p}

	// Record call args
	mmGetAllComments.GetAllCommentsMock.mutex.Lock()
	mmGetAllComments.GetAllCommentsMock.callArgs = append(mmGetAllComments.GetAllCommentsMock.callArgs, mm_params)
	mmGetAllComments.GetAllCommentsMock.mutex.Unlock()

	for _, e := range mmGetAllComments.GetAllCommentsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetAllComments.GetAllCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllComments.GetAllCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllComments.GetAllCommentsMock.defaultExpectation.params
		mm_got := IPostLogicMockGetAllCommentsParams{ctx, postID, p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllComments.t.Errorf("IPostLogicMock.GetAllComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllComments.GetAllCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllComments.t.Fatal("No results are set for the IPostLogicMock.GetAllComments")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetAllComments.funcGetAllComments != nil {
		return mmGetAllComments.funcGetAllComments(ctx, postID, p)
	}
	mmGetAllComments.t.Fatalf("Unexpected call to IPostLogicMock.GetAllComments. %v %v %v", ctx, postID, p)
	return
}

// GetAllCommentsAfterCounter returns a count of finished IPostLogicMock.GetAllComments invocations
func (mmGetAllComments *IPostLogicMock) GetAllCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllComments.afterGetAllCommentsCounter)
}

// GetAllCommentsBeforeCounter returns a count of IPostLogicMock.GetAllComments invocations
func (mmGetAllComments *IPostLogicMock) GetAllCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllComments.beforeGetAllCommentsCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.GetAllComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllComments *mIPostLogicMockGetAllComments) Calls() []*IPostLogicMockGetAllCommentsParams {
	mmGetAllComments.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetAllCommentsParams, len(mmGetAllComments.callArgs))
	copy(argCopy, mmGetAllComments.callArgs)

	mmGetAllComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllCommentsDone returns true if the count of the GetAllComments invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetAllCommentsDone() bool {
	for _, e := range m.GetAllCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllCommentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCommentsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllComments != nil && mm_atomic.LoadUint64(&m.afterGetAllCommentsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllCommentsInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetAllCommentsInspect() {
	for _, e := range m.GetAllCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.GetAllComments with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllCommentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCommentsCounter) < 1 {
		if m.GetAllCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.GetAllComments")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.GetAllComments with params: %#v", *m.GetAllCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllComments != nil && mm_atomic.LoadUint64(&m.afterGetAllCommentsCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.GetAllComments")
	}
}

type mIPostLogicMockGetReactionTypes struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetReactionTypesExpectation
	expectations       []*IPostLogicMockGetReactionTypesExpectation

	callArgs []*IPostLogicMockGetReactionTypesParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetReactionTypesExpectation specifies expectation struct of the IPostLogic.GetReactionTypes
type IPostLogicMockGetReactionTypesExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetReactionTypesParams
	results *IPostLogicMockGetReactionTypesResults
	Counter uint64
}

// IPostLogicMockGetReactionTypesParams contains parameters of the IPostLogic.GetReactionTypes
type IPostLogicMockGetReactionTypesParams struct {
	ctx context.Context
}

// IPostLogicMockGetReactionTypesResults contains results of the IPostLogic.GetReactionTypes
type IPostLogicMockGetReactionTypesResults struct {
	rpa1 []*models.ReactionType
	err  error
}

// Expect sets up expected params for IPostLogic.GetReactionTypes
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) Expect(ctx context.Context) *mIPostLogicMockGetReactionTypes {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostLogicMock.GetReactionTypes mock is already set by Set")
	}

	if mmGetReactionTypes.defaultExpectation == nil {
		mmGetReactionTypes.defaultExpectation = &IPostLogicMockGetReactionTypesExpectation{}
	}

	mmGetReactionTypes.defaultExpectation.params = &IPostLogicMockGetReactionTypesParams{ctx}
	for _, e := range mmGetReactionTypes.expectations {
		if minimock.Equal(e.params, mmGetReactionTypes.defaultExpectation.params) {
			mmGetReactionTypes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReactionTypes.defaultExpectation.params)
		}
	}

	return mmGetReactionTypes
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.GetReactionTypes
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) Inspect(f func(ctx context.Context)) *mIPostLogicMockGetReactionTypes {
	if mmGetReactionTypes.mock.inspectFuncGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.GetReactionTypes")
	}

	mmGetReactionTypes.mock.inspectFuncGetReactionTypes = f

	return mmGetReactionTypes
}

// Return sets up results that will be returned by IPostLogic.GetReactionTypes
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) Return(rpa1 []*models.ReactionType, err error) *IPostLogicMock {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostLogicMock.GetReactionTypes mock is already set by Set")
	}

	if mmGetReactionTypes.defaultExpectation == nil {
		mmGetReactionTypes.defaultExpectation = &IPostLogicMockGetReactionTypesExpectation{mock: mmGetReactionTypes.mock}
	}
	mmGetReactionTypes.defaultExpectation.results = &IPostLogicMockGetReactionTypesResults{rpa1, err}
	return mmGetReactionTypes.mock
}

// Set uses given function f to mock the IPostLogic.GetReactionTypes method
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) Set(f func(ctx context.Context) (rpa1 []*models.ReactionType, err error)) *IPostLogicMock {
	if mmGetReactionTypes.defaultExpectation != nil {
		mmGetReactionTypes.mock.t.Fatalf("Default expectation is already set for the IPostLogic.GetReactionTypes method")
	}

	if len(mmGetReactionTypes.expectations) > 0 {
		mmGetReactionTypes.mock.t.Fatalf("Some expectations are already set for the IPostLogic.GetReactionTypes method")
	}

	mmGetReactionTypes.mock.funcGetReactionTypes = f
	return mmGetReactionTypes.mock
}

// When sets expectation for the IPostLogic.GetReactionTypes which will trigger the result defined by the following
// Then helper
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) When(ctx context.Context) *IPostLogicMockGetReactionTypesExpectation {
	if mmGetReactionTypes.mock.funcGetReactionTypes != nil {
		mmGetReactionTypes.mock.t.Fatalf("IPostLogicMock.GetReactionTypes mock is already set by Set")
	}

	expectation := &IPostLogicMockGetReactionTypesExpectation{
		mock:   mmGetReactionTypes.mock,
		params: &IPostLogicMockGetReactionTypesParams{ctx},
	}
	mmGetReactionTypes.expectations = append(mmGetReactionTypes.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.GetReactionTypes return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetReactionTypesExpectation) Then(rpa1 []*models.ReactionType, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetReactionTypesResults{rpa1, err}
	return e.mock
}

// GetReactionTypes implements interfaces.IPostLogic
func (mmGetReactionTypes *IPostLogicMock) GetReactionTypes(ctx context.Context) (rpa1 []*models.ReactionType, err error) {
	mm_atomic.AddUint64(&mmGetReactionTypes.beforeGetReactionTypesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReactionTypes.afterGetReactionTypesCounter, 1)

	if mmGetReactionTypes.inspectFuncGetReactionTypes != nil {
		mmGetReactionTypes.inspectFuncGetReactionTypes(ctx)
	}

	mm_params := &IPostLogicMockGetReactionTypesParams{ctx}

	// Record call args
	mmGetReactionTypes.GetReactionTypesMock.mutex.Lock()
	mmGetReactionTypes.GetReactionTypesMock.callArgs = append(mmGetReactionTypes.GetReactionTypesMock.callArgs, mm_params)
	mmGetReactionTypes.GetReactionTypesMock.mutex.Unlock()

	for _, e := range mmGetReactionTypes.GetReactionTypesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmGetReactionTypes.GetReactionTypesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.params
		mm_got := IPostLogicMockGetReactionTypesParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReactionTypes.t.Errorf("IPostLogicMock.GetReactionTypes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReactionTypes.GetReactionTypesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReactionTypes.t.Fatal("No results are set for the IPostLogicMock.GetReactionTypes")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmGetReactionTypes.funcGetReactionTypes != nil {
		return mmGetReactionTypes.funcGetReactionTypes(ctx)
	}
	mmGetReactionTypes.t.Fatalf("Unexpected call to IPostLogicMock.GetReactionTypes. %v", ctx)
	return
}

// GetReactionTypesAfterCounter returns a count of finished IPostLogicMock.GetReactionTypes invocations
func (mmGetReactionTypes *IPostLogicMock) GetReactionTypesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReactionTypes.afterGetReactionTypesCounter)
}

// GetReactionTypesBeforeCounter returns a count of IPostLogicMock.GetReactionTypes invocations
func (mmGetReactionTypes *IPostLogicMock) GetReactionTypesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReactionTypes.beforeGetReactionTypesCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.GetReactionTypes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReactionTypes *mIPostLogicMockGetReactionTypes) Calls() []*IPostLogicMockGetReactionTypesParams {
	mmGetReactionTypes.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetReactionTypesParams, len(mmGetReactionTypes.callArgs))
	copy(argCopy, mmGetReactionTypes.callArgs)

	mmGetReactionTypes.mutex.RUnlock()

	return argCopy
}

// MinimockGetReactionTypesDone returns true if the count of the GetReactionTypes invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetReactionTypesDone() bool {
	for _, e := range m.GetReactionTypesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReactionTypesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReactionTypes != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetReactionTypesInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetReactionTypesInspect() {
	for _, e := range m.GetReactionTypesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.GetReactionTypes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReactionTypesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		if m.GetReactionTypesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.GetReactionTypes")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.GetReactionTypes with params: %#v", *m.GetReactionTypesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReactionTypes != nil && mm_atomic.LoadUint64(&m.afterGetReactionTypesCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.GetReactionTypes")
	}
}

type mIPostLogicMockGetTotalByUserID struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetTotalByUserIDExpectation
	expectations       []*IPostLogicMockGetTotalByUserIDExpectation

	callArgs []*IPostLogicMockGetTotalByUserIDParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetTotalByUserIDExpectation specifies expectation struct of the IPostLogic.GetTotalByUserID
type IPostLogicMockGetTotalByUserIDExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetTotalByUserIDParams
	results *IPostLogicMockGetTotalByUserIDResults
	Counter uint64
}

// IPostLogicMockGetTotalByUserIDParams contains parameters of the IPostLogic.GetTotalByUserID
type IPostLogicMockGetTotalByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// IPostLogicMockGetTotalByUserIDResults contains results of the IPostLogic.GetTotalByUserID
type IPostLogicMockGetTotalByUserIDResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IPostLogic.GetTotalByUserID
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) Expect(ctx context.Context, userID uuid.UUID) *mIPostLogicMockGetTotalByUserID {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostLogicMock.GetTotalByUserID mock is already set by Set")
	}

	if mmGetTotalByUserID.defaultExpectation == nil {
		mmGetTotalByUserID.defaultExpectation = &IPostLogicMockGetTotalByUserIDExpectation{}
	}

	mmGetTotalByUserID.defaultExpectation.params = &IPostLogicMockGetTotalByUserIDParams{ctx, userID}
	for _, e := range mmGetTotalByUserID.expectations {
		if minimock.Equal(e.params, mmGetTotalByUserID.defaultExpectation.params) {
			mmGetTotalByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalByUserID.defaultExpectation.params)
		}
	}

	return mmGetTotalByUserID
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.GetTotalByUserID
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mIPostLogicMockGetTotalByUserID {
	if mmGetTotalByUserID.mock.inspectFuncGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.GetTotalByUserID")
	}

	mmGetTotalByUserID.mock.inspectFuncGetTotalByUserID = f

	return mmGetTotalByUserID
}

// Return sets up results that will be returned by IPostLogic.GetTotalByUserID
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) Return(i1 int, err error) *IPostLogicMock {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostLogicMock.GetTotalByUserID mock is already set by Set")
	}

	if mmGetTotalByUserID.defaultExpectation == nil {
		mmGetTotalByUserID.defaultExpectation = &IPostLogicMockGetTotalByUserIDExpectation{mock: mmGetTotalByUserID.mock}
	}
	mmGetTotalByUserID.defaultExpectation.results = &IPostLogicMockGetTotalByUserIDResults{i1, err}
	return mmGetTotalByUserID.mock
}

// Set uses given function f to mock the IPostLogic.GetTotalByUserID method
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (i1 int, err error)) *IPostLogicMock {
	if mmGetTotalByUserID.defaultExpectation != nil {
		mmGetTotalByUserID.mock.t.Fatalf("Default expectation is already set for the IPostLogic.GetTotalByUserID method")
	}

	if len(mmGetTotalByUserID.expectations) > 0 {
		mmGetTotalByUserID.mock.t.Fatalf("Some expectations are already set for the IPostLogic.GetTotalByUserID method")
	}

	mmGetTotalByUserID.mock.funcGetTotalByUserID = f
	return mmGetTotalByUserID.mock
}

// When sets expectation for the IPostLogic.GetTotalByUserID which will trigger the result defined by the following
// Then helper
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) When(ctx context.Context, userID uuid.UUID) *IPostLogicMockGetTotalByUserIDExpectation {
	if mmGetTotalByUserID.mock.funcGetTotalByUserID != nil {
		mmGetTotalByUserID.mock.t.Fatalf("IPostLogicMock.GetTotalByUserID mock is already set by Set")
	}

	expectation := &IPostLogicMockGetTotalByUserIDExpectation{
		mock:   mmGetTotalByUserID.mock,
		params: &IPostLogicMockGetTotalByUserIDParams{ctx, userID},
	}
	mmGetTotalByUserID.expectations = append(mmGetTotalByUserID.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.GetTotalByUserID return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetTotalByUserIDExpectation) Then(i1 int, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetTotalByUserIDResults{i1, err}
	return e.mock
}

// GetTotalByUserID implements interfaces.IPostLogic
func (mmGetTotalByUserID *IPostLogicMock) GetTotalByUserID(ctx context.Context, userID uuid.UUID) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotalByUserID.beforeGetTotalByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalByUserID.afterGetTotalByUserIDCounter, 1)

	if mmGetTotalByUserID.inspectFuncGetTotalByUserID != nil {
		mmGetTotalByUserID.inspectFuncGetTotalByUserID(ctx, userID)
	}

	mm_params := &IPostLogicMockGetTotalByUserIDParams{ctx, userID}

	// Record call args
	mmGetTotalByUserID.GetTotalByUserIDMock.mutex.Lock()
	mmGetTotalByUserID.GetTotalByUserIDMock.callArgs = append(mmGetTotalByUserID.GetTotalByUserIDMock.callArgs, mm_params)
	mmGetTotalByUserID.GetTotalByUserIDMock.mutex.Unlock()

	for _, e := range mmGetTotalByUserID.GetTotalByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.params
		mm_got := IPostLogicMockGetTotalByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalByUserID.t.Errorf("IPostLogicMock.GetTotalByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalByUserID.GetTotalByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalByUserID.t.Fatal("No results are set for the IPostLogicMock.GetTotalByUserID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotalByUserID.funcGetTotalByUserID != nil {
		return mmGetTotalByUserID.funcGetTotalByUserID(ctx, userID)
	}
	mmGetTotalByUserID.t.Fatalf("Unexpected call to IPostLogicMock.GetTotalByUserID. %v %v", ctx, userID)
	return
}

// GetTotalByUserIDAfterCounter returns a count of finished IPostLogicMock.GetTotalByUserID invocations
func (mmGetTotalByUserID *IPostLogicMock) GetTotalByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByUserID.afterGetTotalByUserIDCounter)
}

// GetTotalByUserIDBeforeCounter returns a count of IPostLogicMock.GetTotalByUserID invocations
func (mmGetTotalByUserID *IPostLogicMock) GetTotalByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalByUserID.beforeGetTotalByUserIDCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.GetTotalByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalByUserID *mIPostLogicMockGetTotalByUserID) Calls() []*IPostLogicMockGetTotalByUserIDParams {
	mmGetTotalByUserID.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetTotalByUserIDParams, len(mmGetTotalByUserID.callArgs))
	copy(argCopy, mmGetTotalByUserID.callArgs)

	mmGetTotalByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalByUserIDDone returns true if the count of the GetTotalByUserID invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetTotalByUserIDDone() bool {
	for _, e := range m.GetTotalByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByUserID != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalByUserIDInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetTotalByUserIDInspect() {
	for _, e := range m.GetTotalByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.GetTotalByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		if m.GetTotalByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.GetTotalByUserID")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.GetTotalByUserID with params: %#v", *m.GetTotalByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalByUserID != nil && mm_atomic.LoadUint64(&m.afterGetTotalByUserIDCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.GetTotalByUserID")
	}
}

type mIPostLogicMockGetTotalCommentsByPostID struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockGetTotalCommentsByPostIDExpectation
	expectations       []*IPostLogicMockGetTotalCommentsByPostIDExpectation

	callArgs []*IPostLogicMockGetTotalCommentsByPostIDParams
	mutex    sync.RWMutex
}

// IPostLogicMockGetTotalCommentsByPostIDExpectation specifies expectation struct of the IPostLogic.GetTotalCommentsByPostID
type IPostLogicMockGetTotalCommentsByPostIDExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockGetTotalCommentsByPostIDParams
	results *IPostLogicMockGetTotalCommentsByPostIDResults
	Counter uint64
}

// IPostLogicMockGetTotalCommentsByPostIDParams contains parameters of the IPostLogic.GetTotalCommentsByPostID
type IPostLogicMockGetTotalCommentsByPostIDParams struct {
	ctx    context.Context
	postID uuid.UUID
}

// IPostLogicMockGetTotalCommentsByPostIDResults contains results of the IPostLogic.GetTotalCommentsByPostID
type IPostLogicMockGetTotalCommentsByPostIDResults struct {
	i1  int
	err error
}

// Expect sets up expected params for IPostLogic.GetTotalCommentsByPostID
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) Expect(ctx context.Context, postID uuid.UUID) *mIPostLogicMockGetTotalCommentsByPostID {
	if mmGetTotalCommentsByPostID.mock.funcGetTotalCommentsByPostID != nil {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("IPostLogicMock.GetTotalCommentsByPostID mock is already set by Set")
	}

	if mmGetTotalCommentsByPostID.defaultExpectation == nil {
		mmGetTotalCommentsByPostID.defaultExpectation = &IPostLogicMockGetTotalCommentsByPostIDExpectation{}
	}

	mmGetTotalCommentsByPostID.defaultExpectation.params = &IPostLogicMockGetTotalCommentsByPostIDParams{ctx, postID}
	for _, e := range mmGetTotalCommentsByPostID.expectations {
		if minimock.Equal(e.params, mmGetTotalCommentsByPostID.defaultExpectation.params) {
			mmGetTotalCommentsByPostID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalCommentsByPostID.defaultExpectation.params)
		}
	}

	return mmGetTotalCommentsByPostID
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.GetTotalCommentsByPostID
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) Inspect(f func(ctx context.Context, postID uuid.UUID)) *mIPostLogicMockGetTotalCommentsByPostID {
	if mmGetTotalCommentsByPostID.mock.inspectFuncGetTotalCommentsByPostID != nil {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.GetTotalCommentsByPostID")
	}

	mmGetTotalCommentsByPostID.mock.inspectFuncGetTotalCommentsByPostID = f

	return mmGetTotalCommentsByPostID
}

// Return sets up results that will be returned by IPostLogic.GetTotalCommentsByPostID
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) Return(i1 int, err error) *IPostLogicMock {
	if mmGetTotalCommentsByPostID.mock.funcGetTotalCommentsByPostID != nil {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("IPostLogicMock.GetTotalCommentsByPostID mock is already set by Set")
	}

	if mmGetTotalCommentsByPostID.defaultExpectation == nil {
		mmGetTotalCommentsByPostID.defaultExpectation = &IPostLogicMockGetTotalCommentsByPostIDExpectation{mock: mmGetTotalCommentsByPostID.mock}
	}
	mmGetTotalCommentsByPostID.defaultExpectation.results = &IPostLogicMockGetTotalCommentsByPostIDResults{i1, err}
	return mmGetTotalCommentsByPostID.mock
}

// Set uses given function f to mock the IPostLogic.GetTotalCommentsByPostID method
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) Set(f func(ctx context.Context, postID uuid.UUID) (i1 int, err error)) *IPostLogicMock {
	if mmGetTotalCommentsByPostID.defaultExpectation != nil {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("Default expectation is already set for the IPostLogic.GetTotalCommentsByPostID method")
	}

	if len(mmGetTotalCommentsByPostID.expectations) > 0 {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("Some expectations are already set for the IPostLogic.GetTotalCommentsByPostID method")
	}

	mmGetTotalCommentsByPostID.mock.funcGetTotalCommentsByPostID = f
	return mmGetTotalCommentsByPostID.mock
}

// When sets expectation for the IPostLogic.GetTotalCommentsByPostID which will trigger the result defined by the following
// Then helper
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) When(ctx context.Context, postID uuid.UUID) *IPostLogicMockGetTotalCommentsByPostIDExpectation {
	if mmGetTotalCommentsByPostID.mock.funcGetTotalCommentsByPostID != nil {
		mmGetTotalCommentsByPostID.mock.t.Fatalf("IPostLogicMock.GetTotalCommentsByPostID mock is already set by Set")
	}

	expectation := &IPostLogicMockGetTotalCommentsByPostIDExpectation{
		mock:   mmGetTotalCommentsByPostID.mock,
		params: &IPostLogicMockGetTotalCommentsByPostIDParams{ctx, postID},
	}
	mmGetTotalCommentsByPostID.expectations = append(mmGetTotalCommentsByPostID.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.GetTotalCommentsByPostID return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockGetTotalCommentsByPostIDExpectation) Then(i1 int, err error) *IPostLogicMock {
	e.results = &IPostLogicMockGetTotalCommentsByPostIDResults{i1, err}
	return e.mock
}

// GetTotalCommentsByPostID implements interfaces.IPostLogic
func (mmGetTotalCommentsByPostID *IPostLogicMock) GetTotalCommentsByPostID(ctx context.Context, postID uuid.UUID) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotalCommentsByPostID.beforeGetTotalCommentsByPostIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalCommentsByPostID.afterGetTotalCommentsByPostIDCounter, 1)

	if mmGetTotalCommentsByPostID.inspectFuncGetTotalCommentsByPostID != nil {
		mmGetTotalCommentsByPostID.inspectFuncGetTotalCommentsByPostID(ctx, postID)
	}

	mm_params := &IPostLogicMockGetTotalCommentsByPostIDParams{ctx, postID}

	// Record call args
	mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.mutex.Lock()
	mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.callArgs = append(mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.callArgs, mm_params)
	mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.mutex.Unlock()

	for _, e := range mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.defaultExpectation.params
		mm_got := IPostLogicMockGetTotalCommentsByPostIDParams{ctx, postID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalCommentsByPostID.t.Errorf("IPostLogicMock.GetTotalCommentsByPostID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalCommentsByPostID.GetTotalCommentsByPostIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalCommentsByPostID.t.Fatal("No results are set for the IPostLogicMock.GetTotalCommentsByPostID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotalCommentsByPostID.funcGetTotalCommentsByPostID != nil {
		return mmGetTotalCommentsByPostID.funcGetTotalCommentsByPostID(ctx, postID)
	}
	mmGetTotalCommentsByPostID.t.Fatalf("Unexpected call to IPostLogicMock.GetTotalCommentsByPostID. %v %v", ctx, postID)
	return
}

// GetTotalCommentsByPostIDAfterCounter returns a count of finished IPostLogicMock.GetTotalCommentsByPostID invocations
func (mmGetTotalCommentsByPostID *IPostLogicMock) GetTotalCommentsByPostIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalCommentsByPostID.afterGetTotalCommentsByPostIDCounter)
}

// GetTotalCommentsByPostIDBeforeCounter returns a count of IPostLogicMock.GetTotalCommentsByPostID invocations
func (mmGetTotalCommentsByPostID *IPostLogicMock) GetTotalCommentsByPostIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalCommentsByPostID.beforeGetTotalCommentsByPostIDCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.GetTotalCommentsByPostID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalCommentsByPostID *mIPostLogicMockGetTotalCommentsByPostID) Calls() []*IPostLogicMockGetTotalCommentsByPostIDParams {
	mmGetTotalCommentsByPostID.mutex.RLock()

	argCopy := make([]*IPostLogicMockGetTotalCommentsByPostIDParams, len(mmGetTotalCommentsByPostID.callArgs))
	copy(argCopy, mmGetTotalCommentsByPostID.callArgs)

	mmGetTotalCommentsByPostID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalCommentsByPostIDDone returns true if the count of the GetTotalCommentsByPostID invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockGetTotalCommentsByPostIDDone() bool {
	for _, e := range m.GetTotalCommentsByPostIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalCommentsByPostIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCommentsByPostIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalCommentsByPostID != nil && mm_atomic.LoadUint64(&m.afterGetTotalCommentsByPostIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalCommentsByPostIDInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockGetTotalCommentsByPostIDInspect() {
	for _, e := range m.GetTotalCommentsByPostIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.GetTotalCommentsByPostID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalCommentsByPostIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCommentsByPostIDCounter) < 1 {
		if m.GetTotalCommentsByPostIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.GetTotalCommentsByPostID")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.GetTotalCommentsByPostID with params: %#v", *m.GetTotalCommentsByPostIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalCommentsByPostID != nil && mm_atomic.LoadUint64(&m.afterGetTotalCommentsByPostIDCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.GetTotalCommentsByPostID")
	}
}

type mIPostLogicMockPopularityCheck struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockPopularityCheckExpectation
	expectations       []*IPostLogicMockPopularityCheckExpectation

	callArgs []*IPostLogicMockPopularityCheckParams
	mutex    sync.RWMutex
}

// IPostLogicMockPopularityCheckExpectation specifies expectation struct of the IPostLogic.PopularityCheck
type IPostLogicMockPopularityCheckExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockPopularityCheckParams
	results *IPostLogicMockPopularityCheckResults
	Counter uint64
}

// IPostLogicMockPopularityCheckParams contains parameters of the IPostLogic.PopularityCheck
type IPostLogicMockPopularityCheckParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// IPostLogicMockPopularityCheckResults contains results of the IPostLogic.PopularityCheck
type IPostLogicMockPopularityCheckResults struct {
	err error
}

// Expect sets up expected params for IPostLogic.PopularityCheck
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) Expect(ctx context.Context, u1 uuid.UUID) *mIPostLogicMockPopularityCheck {
	if mmPopularityCheck.mock.funcPopularityCheck != nil {
		mmPopularityCheck.mock.t.Fatalf("IPostLogicMock.PopularityCheck mock is already set by Set")
	}

	if mmPopularityCheck.defaultExpectation == nil {
		mmPopularityCheck.defaultExpectation = &IPostLogicMockPopularityCheckExpectation{}
	}

	mmPopularityCheck.defaultExpectation.params = &IPostLogicMockPopularityCheckParams{ctx, u1}
	for _, e := range mmPopularityCheck.expectations {
		if minimock.Equal(e.params, mmPopularityCheck.defaultExpectation.params) {
			mmPopularityCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPopularityCheck.defaultExpectation.params)
		}
	}

	return mmPopularityCheck
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.PopularityCheck
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mIPostLogicMockPopularityCheck {
	if mmPopularityCheck.mock.inspectFuncPopularityCheck != nil {
		mmPopularityCheck.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.PopularityCheck")
	}

	mmPopularityCheck.mock.inspectFuncPopularityCheck = f

	return mmPopularityCheck
}

// Return sets up results that will be returned by IPostLogic.PopularityCheck
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) Return(err error) *IPostLogicMock {
	if mmPopularityCheck.mock.funcPopularityCheck != nil {
		mmPopularityCheck.mock.t.Fatalf("IPostLogicMock.PopularityCheck mock is already set by Set")
	}

	if mmPopularityCheck.defaultExpectation == nil {
		mmPopularityCheck.defaultExpectation = &IPostLogicMockPopularityCheckExpectation{mock: mmPopularityCheck.mock}
	}
	mmPopularityCheck.defaultExpectation.results = &IPostLogicMockPopularityCheckResults{err}
	return mmPopularityCheck.mock
}

// Set uses given function f to mock the IPostLogic.PopularityCheck method
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *IPostLogicMock {
	if mmPopularityCheck.defaultExpectation != nil {
		mmPopularityCheck.mock.t.Fatalf("Default expectation is already set for the IPostLogic.PopularityCheck method")
	}

	if len(mmPopularityCheck.expectations) > 0 {
		mmPopularityCheck.mock.t.Fatalf("Some expectations are already set for the IPostLogic.PopularityCheck method")
	}

	mmPopularityCheck.mock.funcPopularityCheck = f
	return mmPopularityCheck.mock
}

// When sets expectation for the IPostLogic.PopularityCheck which will trigger the result defined by the following
// Then helper
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) When(ctx context.Context, u1 uuid.UUID) *IPostLogicMockPopularityCheckExpectation {
	if mmPopularityCheck.mock.funcPopularityCheck != nil {
		mmPopularityCheck.mock.t.Fatalf("IPostLogicMock.PopularityCheck mock is already set by Set")
	}

	expectation := &IPostLogicMockPopularityCheckExpectation{
		mock:   mmPopularityCheck.mock,
		params: &IPostLogicMockPopularityCheckParams{ctx, u1},
	}
	mmPopularityCheck.expectations = append(mmPopularityCheck.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.PopularityCheck return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockPopularityCheckExpectation) Then(err error) *IPostLogicMock {
	e.results = &IPostLogicMockPopularityCheckResults{err}
	return e.mock
}

// PopularityCheck implements interfaces.IPostLogic
func (mmPopularityCheck *IPostLogicMock) PopularityCheck(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPopularityCheck.beforePopularityCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmPopularityCheck.afterPopularityCheckCounter, 1)

	if mmPopularityCheck.inspectFuncPopularityCheck != nil {
		mmPopularityCheck.inspectFuncPopularityCheck(ctx, u1)
	}

	mm_params := &IPostLogicMockPopularityCheckParams{ctx, u1}

	// Record call args
	mmPopularityCheck.PopularityCheckMock.mutex.Lock()
	mmPopularityCheck.PopularityCheckMock.callArgs = append(mmPopularityCheck.PopularityCheckMock.callArgs, mm_params)
	mmPopularityCheck.PopularityCheckMock.mutex.Unlock()

	for _, e := range mmPopularityCheck.PopularityCheckMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPopularityCheck.PopularityCheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPopularityCheck.PopularityCheckMock.defaultExpectation.Counter, 1)
		mm_want := mmPopularityCheck.PopularityCheckMock.defaultExpectation.params
		mm_got := IPostLogicMockPopularityCheckParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPopularityCheck.t.Errorf("IPostLogicMock.PopularityCheck got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPopularityCheck.PopularityCheckMock.defaultExpectation.results
		if mm_results == nil {
			mmPopularityCheck.t.Fatal("No results are set for the IPostLogicMock.PopularityCheck")
		}
		return (*mm_results).err
	}
	if mmPopularityCheck.funcPopularityCheck != nil {
		return mmPopularityCheck.funcPopularityCheck(ctx, u1)
	}
	mmPopularityCheck.t.Fatalf("Unexpected call to IPostLogicMock.PopularityCheck. %v %v", ctx, u1)
	return
}

// PopularityCheckAfterCounter returns a count of finished IPostLogicMock.PopularityCheck invocations
func (mmPopularityCheck *IPostLogicMock) PopularityCheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPopularityCheck.afterPopularityCheckCounter)
}

// PopularityCheckBeforeCounter returns a count of IPostLogicMock.PopularityCheck invocations
func (mmPopularityCheck *IPostLogicMock) PopularityCheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPopularityCheck.beforePopularityCheckCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.PopularityCheck.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPopularityCheck *mIPostLogicMockPopularityCheck) Calls() []*IPostLogicMockPopularityCheckParams {
	mmPopularityCheck.mutex.RLock()

	argCopy := make([]*IPostLogicMockPopularityCheckParams, len(mmPopularityCheck.callArgs))
	copy(argCopy, mmPopularityCheck.callArgs)

	mmPopularityCheck.mutex.RUnlock()

	return argCopy
}

// MinimockPopularityCheckDone returns true if the count of the PopularityCheck invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockPopularityCheckDone() bool {
	for _, e := range m.PopularityCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopularityCheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopularityCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPopularityCheck != nil && mm_atomic.LoadUint64(&m.afterPopularityCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockPopularityCheckInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockPopularityCheckInspect() {
	for _, e := range m.PopularityCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.PopularityCheck with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PopularityCheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPopularityCheckCounter) < 1 {
		if m.PopularityCheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.PopularityCheck")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.PopularityCheck with params: %#v", *m.PopularityCheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPopularityCheck != nil && mm_atomic.LoadUint64(&m.afterPopularityCheckCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.PopularityCheck")
	}
}

type mIPostLogicMockPublish struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockPublishExpectation
	expectations       []*IPostLogicMockPublishExpectation

	callArgs []*IPostLogicMockPublishParams
	mutex    sync.RWMutex
}

// IPostLogicMockPublishExpectation specifies expectation struct of the IPostLogic.Publish
type IPostLogicMockPublishExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockPublishParams
	results *IPostLogicMockPublishResults
	Counter uint64
}

// IPostLogicMockPublishParams contains parameters of the IPostLogic.Publish
type IPostLogicMockPublishParams struct {
	ctx context.Context
	pp1 *models.Post
}

// IPostLogicMockPublishResults contains results of the IPostLogic.Publish
type IPostLogicMockPublishResults struct {
	pp2 *models.Post
	err error
}

// Expect sets up expected params for IPostLogic.Publish
func (mmPublish *mIPostLogicMockPublish) Expect(ctx context.Context, pp1 *models.Post) *mIPostLogicMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("IPostLogicMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &IPostLogicMockPublishExpectation{}
	}

	mmPublish.defaultExpectation.params = &IPostLogicMockPublishParams{ctx, pp1}
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.Publish
func (mmPublish *mIPostLogicMockPublish) Inspect(f func(ctx context.Context, pp1 *models.Post)) *mIPostLogicMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by IPostLogic.Publish
func (mmPublish *mIPostLogicMockPublish) Return(pp2 *models.Post, err error) *IPostLogicMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("IPostLogicMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &IPostLogicMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &IPostLogicMockPublishResults{pp2, err}
	return mmPublish.mock
}

// Set uses given function f to mock the IPostLogic.Publish method
func (mmPublish *mIPostLogicMockPublish) Set(f func(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error)) *IPostLogicMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the IPostLogic.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the IPostLogic.Publish method")
	}

	mmPublish.mock.funcPublish = f
	return mmPublish.mock
}

// When sets expectation for the IPostLogic.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mIPostLogicMockPublish) When(ctx context.Context, pp1 *models.Post) *IPostLogicMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("IPostLogicMock.Publish mock is already set by Set")
	}

	expectation := &IPostLogicMockPublishExpectation{
		mock:   mmPublish.mock,
		params: &IPostLogicMockPublishParams{ctx, pp1},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.Publish return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockPublishExpectation) Then(pp2 *models.Post, err error) *IPostLogicMock {
	e.results = &IPostLogicMockPublishResults{pp2, err}
	return e.mock
}

// Publish implements interfaces.IPostLogic
func (mmPublish *IPostLogicMock) Publish(ctx context.Context, pp1 *models.Post) (pp2 *models.Post, err error) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(ctx, pp1)
	}

	mm_params := &IPostLogicMockPublishParams{ctx, pp1}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_got := IPostLogicMockPublishParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("IPostLogicMock.Publish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the IPostLogicMock.Publish")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(ctx, pp1)
	}
	mmPublish.t.Fatalf("Unexpected call to IPostLogicMock.Publish. %v %v", ctx, pp1)
	return
}

// PublishAfterCounter returns a count of finished IPostLogicMock.Publish invocations
func (mmPublish *IPostLogicMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of IPostLogicMock.Publish invocations
func (mmPublish *IPostLogicMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mIPostLogicMockPublish) Calls() []*IPostLogicMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*IPostLogicMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockPublishDone() bool {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.Publish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.Publish")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.Publish with params: %#v", *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.Publish")
	}
}

type mIPostLogicMockReact struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockReactExpectation
	expectations       []*IPostLogicMockReactExpectation

	callArgs []*IPostLogicMockReactParams
	mutex    sync.RWMutex
}

// IPostLogicMockReactExpectation specifies expectation struct of the IPostLogic.React
type IPostLogicMockReactExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockReactParams
	results *IPostLogicMockReactResults
	Counter uint64
}

// IPostLogicMockReactParams contains parameters of the IPostLogic.React
type IPostLogicMockReactParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// IPostLogicMockReactResults contains results of the IPostLogic.React
type IPostLogicMockReactResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for IPostLogic.React
func (mmReact *mIPostLogicMockReact) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mIPostLogicMockReact {
	if mmReact.mock.funcReact != nil {
		mmReact.mock.t.Fatalf("IPostLogicMock.React mock is already set by Set")
	}

	if mmReact.defaultExpectation == nil {
		mmReact.defaultExpectation = &IPostLogicMockReactExpectation{}
	}

	mmReact.defaultExpectation.params = &IPostLogicMockReactParams{ctx, u1, u2}
	for _, e := range mmReact.expectations {
		if minimock.Equal(e.params, mmReact.defaultExpectation.params) {
			mmReact.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReact.defaultExpectation.params)
		}
	}

	return mmReact
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.React
func (mmReact *mIPostLogicMockReact) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mIPostLogicMockReact {
	if mmReact.mock.inspectFuncReact != nil {
		mmReact.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.React")
	}

	mmReact.mock.inspectFuncReact = f

	return mmReact
}

// Return sets up results that will be returned by IPostLogic.React
func (mmReact *mIPostLogicMockReact) Return(b1 bool, err error) *IPostLogicMock {
	if mmReact.mock.funcReact != nil {
		mmReact.mock.t.Fatalf("IPostLogicMock.React mock is already set by Set")
	}

	if mmReact.defaultExpectation == nil {
		mmReact.defaultExpectation = &IPostLogicMockReactExpectation{mock: mmReact.mock}
	}
	mmReact.defaultExpectation.results = &IPostLogicMockReactResults{b1, err}
	return mmReact.mock
}

// Set uses given function f to mock the IPostLogic.React method
func (mmReact *mIPostLogicMockReact) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)) *IPostLogicMock {
	if mmReact.defaultExpectation != nil {
		mmReact.mock.t.Fatalf("Default expectation is already set for the IPostLogic.React method")
	}

	if len(mmReact.expectations) > 0 {
		mmReact.mock.t.Fatalf("Some expectations are already set for the IPostLogic.React method")
	}

	mmReact.mock.funcReact = f
	return mmReact.mock
}

// When sets expectation for the IPostLogic.React which will trigger the result defined by the following
// Then helper
func (mmReact *mIPostLogicMockReact) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *IPostLogicMockReactExpectation {
	if mmReact.mock.funcReact != nil {
		mmReact.mock.t.Fatalf("IPostLogicMock.React mock is already set by Set")
	}

	expectation := &IPostLogicMockReactExpectation{
		mock:   mmReact.mock,
		params: &IPostLogicMockReactParams{ctx, u1, u2},
	}
	mmReact.expectations = append(mmReact.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.React return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockReactExpectation) Then(b1 bool, err error) *IPostLogicMock {
	e.results = &IPostLogicMockReactResults{b1, err}
	return e.mock
}

// React implements interfaces.IPostLogic
func (mmReact *IPostLogicMock) React(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmReact.beforeReactCounter, 1)
	defer mm_atomic.AddUint64(&mmReact.afterReactCounter, 1)

	if mmReact.inspectFuncReact != nil {
		mmReact.inspectFuncReact(ctx, u1, u2)
	}

	mm_params := &IPostLogicMockReactParams{ctx, u1, u2}

	// Record call args
	mmReact.ReactMock.mutex.Lock()
	mmReact.ReactMock.callArgs = append(mmReact.ReactMock.callArgs, mm_params)
	mmReact.ReactMock.mutex.Unlock()

	for _, e := range mmReact.ReactMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmReact.ReactMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReact.ReactMock.defaultExpectation.Counter, 1)
		mm_want := mmReact.ReactMock.defaultExpectation.params
		mm_got := IPostLogicMockReactParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReact.t.Errorf("IPostLogicMock.React got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReact.ReactMock.defaultExpectation.results
		if mm_results == nil {
			mmReact.t.Fatal("No results are set for the IPostLogicMock.React")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmReact.funcReact != nil {
		return mmReact.funcReact(ctx, u1, u2)
	}
	mmReact.t.Fatalf("Unexpected call to IPostLogicMock.React. %v %v %v", ctx, u1, u2)
	return
}

// ReactAfterCounter returns a count of finished IPostLogicMock.React invocations
func (mmReact *IPostLogicMock) ReactAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReact.afterReactCounter)
}

// ReactBeforeCounter returns a count of IPostLogicMock.React invocations
func (mmReact *IPostLogicMock) ReactBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReact.beforeReactCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.React.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReact *mIPostLogicMockReact) Calls() []*IPostLogicMockReactParams {
	mmReact.mutex.RLock()

	argCopy := make([]*IPostLogicMockReactParams, len(mmReact.callArgs))
	copy(argCopy, mmReact.callArgs)

	mmReact.mutex.RUnlock()

	return argCopy
}

// MinimockReactDone returns true if the count of the React invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockReactDone() bool {
	for _, e := range m.ReactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReact != nil && mm_atomic.LoadUint64(&m.afterReactCounter) < 1 {
		return false
	}
	return true
}

// MinimockReactInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockReactInspect() {
	for _, e := range m.ReactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.React with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactCounter) < 1 {
		if m.ReactMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.React")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.React with params: %#v", *m.ReactMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReact != nil && mm_atomic.LoadUint64(&m.afterReactCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.React")
	}
}

type mIPostLogicMockUncomment struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockUncommentExpectation
	expectations       []*IPostLogicMockUncommentExpectation

	callArgs []*IPostLogicMockUncommentParams
	mutex    sync.RWMutex
}

// IPostLogicMockUncommentExpectation specifies expectation struct of the IPostLogic.Uncomment
type IPostLogicMockUncommentExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockUncommentParams
	results *IPostLogicMockUncommentResults
	Counter uint64
}

// IPostLogicMockUncommentParams contains parameters of the IPostLogic.Uncomment
type IPostLogicMockUncommentParams struct {
	ctx context.Context
	id  uuid.UUID
}

// IPostLogicMockUncommentResults contains results of the IPostLogic.Uncomment
type IPostLogicMockUncommentResults struct {
	err error
}

// Expect sets up expected params for IPostLogic.Uncomment
func (mmUncomment *mIPostLogicMockUncomment) Expect(ctx context.Context, id uuid.UUID) *mIPostLogicMockUncomment {
	if mmUncomment.mock.funcUncomment != nil {
		mmUncomment.mock.t.Fatalf("IPostLogicMock.Uncomment mock is already set by Set")
	}

	if mmUncomment.defaultExpectation == nil {
		mmUncomment.defaultExpectation = &IPostLogicMockUncommentExpectation{}
	}

	mmUncomment.defaultExpectation.params = &IPostLogicMockUncommentParams{ctx, id}
	for _, e := range mmUncomment.expectations {
		if minimock.Equal(e.params, mmUncomment.defaultExpectation.params) {
			mmUncomment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUncomment.defaultExpectation.params)
		}
	}

	return mmUncomment
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.Uncomment
func (mmUncomment *mIPostLogicMockUncomment) Inspect(f func(ctx context.Context, id uuid.UUID)) *mIPostLogicMockUncomment {
	if mmUncomment.mock.inspectFuncUncomment != nil {
		mmUncomment.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.Uncomment")
	}

	mmUncomment.mock.inspectFuncUncomment = f

	return mmUncomment
}

// Return sets up results that will be returned by IPostLogic.Uncomment
func (mmUncomment *mIPostLogicMockUncomment) Return(err error) *IPostLogicMock {
	if mmUncomment.mock.funcUncomment != nil {
		mmUncomment.mock.t.Fatalf("IPostLogicMock.Uncomment mock is already set by Set")
	}

	if mmUncomment.defaultExpectation == nil {
		mmUncomment.defaultExpectation = &IPostLogicMockUncommentExpectation{mock: mmUncomment.mock}
	}
	mmUncomment.defaultExpectation.results = &IPostLogicMockUncommentResults{err}
	return mmUncomment.mock
}

// Set uses given function f to mock the IPostLogic.Uncomment method
func (mmUncomment *mIPostLogicMockUncomment) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *IPostLogicMock {
	if mmUncomment.defaultExpectation != nil {
		mmUncomment.mock.t.Fatalf("Default expectation is already set for the IPostLogic.Uncomment method")
	}

	if len(mmUncomment.expectations) > 0 {
		mmUncomment.mock.t.Fatalf("Some expectations are already set for the IPostLogic.Uncomment method")
	}

	mmUncomment.mock.funcUncomment = f
	return mmUncomment.mock
}

// When sets expectation for the IPostLogic.Uncomment which will trigger the result defined by the following
// Then helper
func (mmUncomment *mIPostLogicMockUncomment) When(ctx context.Context, id uuid.UUID) *IPostLogicMockUncommentExpectation {
	if mmUncomment.mock.funcUncomment != nil {
		mmUncomment.mock.t.Fatalf("IPostLogicMock.Uncomment mock is already set by Set")
	}

	expectation := &IPostLogicMockUncommentExpectation{
		mock:   mmUncomment.mock,
		params: &IPostLogicMockUncommentParams{ctx, id},
	}
	mmUncomment.expectations = append(mmUncomment.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.Uncomment return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockUncommentExpectation) Then(err error) *IPostLogicMock {
	e.results = &IPostLogicMockUncommentResults{err}
	return e.mock
}

// Uncomment implements interfaces.IPostLogic
func (mmUncomment *IPostLogicMock) Uncomment(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmUncomment.beforeUncommentCounter, 1)
	defer mm_atomic.AddUint64(&mmUncomment.afterUncommentCounter, 1)

	if mmUncomment.inspectFuncUncomment != nil {
		mmUncomment.inspectFuncUncomment(ctx, id)
	}

	mm_params := &IPostLogicMockUncommentParams{ctx, id}

	// Record call args
	mmUncomment.UncommentMock.mutex.Lock()
	mmUncomment.UncommentMock.callArgs = append(mmUncomment.UncommentMock.callArgs, mm_params)
	mmUncomment.UncommentMock.mutex.Unlock()

	for _, e := range mmUncomment.UncommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUncomment.UncommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUncomment.UncommentMock.defaultExpectation.Counter, 1)
		mm_want := mmUncomment.UncommentMock.defaultExpectation.params
		mm_got := IPostLogicMockUncommentParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUncomment.t.Errorf("IPostLogicMock.Uncomment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUncomment.UncommentMock.defaultExpectation.results
		if mm_results == nil {
			mmUncomment.t.Fatal("No results are set for the IPostLogicMock.Uncomment")
		}
		return (*mm_results).err
	}
	if mmUncomment.funcUncomment != nil {
		return mmUncomment.funcUncomment(ctx, id)
	}
	mmUncomment.t.Fatalf("Unexpected call to IPostLogicMock.Uncomment. %v %v", ctx, id)
	return
}

// UncommentAfterCounter returns a count of finished IPostLogicMock.Uncomment invocations
func (mmUncomment *IPostLogicMock) UncommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUncomment.afterUncommentCounter)
}

// UncommentBeforeCounter returns a count of IPostLogicMock.Uncomment invocations
func (mmUncomment *IPostLogicMock) UncommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUncomment.beforeUncommentCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.Uncomment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUncomment *mIPostLogicMockUncomment) Calls() []*IPostLogicMockUncommentParams {
	mmUncomment.mutex.RLock()

	argCopy := make([]*IPostLogicMockUncommentParams, len(mmUncomment.callArgs))
	copy(argCopy, mmUncomment.callArgs)

	mmUncomment.mutex.RUnlock()

	return argCopy
}

// MinimockUncommentDone returns true if the count of the Uncomment invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockUncommentDone() bool {
	for _, e := range m.UncommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UncommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUncommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUncomment != nil && mm_atomic.LoadUint64(&m.afterUncommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockUncommentInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockUncommentInspect() {
	for _, e := range m.UncommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.Uncomment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UncommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUncommentCounter) < 1 {
		if m.UncommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.Uncomment")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.Uncomment with params: %#v", *m.UncommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUncomment != nil && mm_atomic.LoadUint64(&m.afterUncommentCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.Uncomment")
	}
}

type mIPostLogicMockView struct {
	mock               *IPostLogicMock
	defaultExpectation *IPostLogicMockViewExpectation
	expectations       []*IPostLogicMockViewExpectation

	callArgs []*IPostLogicMockViewParams
	mutex    sync.RWMutex
}

// IPostLogicMockViewExpectation specifies expectation struct of the IPostLogic.View
type IPostLogicMockViewExpectation struct {
	mock    *IPostLogicMock
	params  *IPostLogicMockViewParams
	results *IPostLogicMockViewResults
	Counter uint64
}

// IPostLogicMockViewParams contains parameters of the IPostLogic.View
type IPostLogicMockViewParams struct {
	ctx context.Context
	pp1 *models.Post
	u1  uuid.UUID
}

// IPostLogicMockViewResults contains results of the IPostLogic.View
type IPostLogicMockViewResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for IPostLogic.View
func (mmView *mIPostLogicMockView) Expect(ctx context.Context, pp1 *models.Post, u1 uuid.UUID) *mIPostLogicMockView {
	if mmView.mock.funcView != nil {
		mmView.mock.t.Fatalf("IPostLogicMock.View mock is already set by Set")
	}

	if mmView.defaultExpectation == nil {
		mmView.defaultExpectation = &IPostLogicMockViewExpectation{}
	}

	mmView.defaultExpectation.params = &IPostLogicMockViewParams{ctx, pp1, u1}
	for _, e := range mmView.expectations {
		if minimock.Equal(e.params, mmView.defaultExpectation.params) {
			mmView.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmView.defaultExpectation.params)
		}
	}

	return mmView
}

// Inspect accepts an inspector function that has same arguments as the IPostLogic.View
func (mmView *mIPostLogicMockView) Inspect(f func(ctx context.Context, pp1 *models.Post, u1 uuid.UUID)) *mIPostLogicMockView {
	if mmView.mock.inspectFuncView != nil {
		mmView.mock.t.Fatalf("Inspect function is already set for IPostLogicMock.View")
	}

	mmView.mock.inspectFuncView = f

	return mmView
}

// Return sets up results that will be returned by IPostLogic.View
func (mmView *mIPostLogicMockView) Return(b1 bool, err error) *IPostLogicMock {
	if mmView.mock.funcView != nil {
		mmView.mock.t.Fatalf("IPostLogicMock.View mock is already set by Set")
	}

	if mmView.defaultExpectation == nil {
		mmView.defaultExpectation = &IPostLogicMockViewExpectation{mock: mmView.mock}
	}
	mmView.defaultExpectation.results = &IPostLogicMockViewResults{b1, err}
	return mmView.mock
}

// Set uses given function f to mock the IPostLogic.View method
func (mmView *mIPostLogicMockView) Set(f func(ctx context.Context, pp1 *models.Post, u1 uuid.UUID) (b1 bool, err error)) *IPostLogicMock {
	if mmView.defaultExpectation != nil {
		mmView.mock.t.Fatalf("Default expectation is already set for the IPostLogic.View method")
	}

	if len(mmView.expectations) > 0 {
		mmView.mock.t.Fatalf("Some expectations are already set for the IPostLogic.View method")
	}

	mmView.mock.funcView = f
	return mmView.mock
}

// When sets expectation for the IPostLogic.View which will trigger the result defined by the following
// Then helper
func (mmView *mIPostLogicMockView) When(ctx context.Context, pp1 *models.Post, u1 uuid.UUID) *IPostLogicMockViewExpectation {
	if mmView.mock.funcView != nil {
		mmView.mock.t.Fatalf("IPostLogicMock.View mock is already set by Set")
	}

	expectation := &IPostLogicMockViewExpectation{
		mock:   mmView.mock,
		params: &IPostLogicMockViewParams{ctx, pp1, u1},
	}
	mmView.expectations = append(mmView.expectations, expectation)
	return expectation
}

// Then sets up IPostLogic.View return parameters for the expectation previously defined by the When method
func (e *IPostLogicMockViewExpectation) Then(b1 bool, err error) *IPostLogicMock {
	e.results = &IPostLogicMockViewResults{b1, err}
	return e.mock
}

// View implements interfaces.IPostLogic
func (mmView *IPostLogicMock) View(ctx context.Context, pp1 *models.Post, u1 uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmView.beforeViewCounter, 1)
	defer mm_atomic.AddUint64(&mmView.afterViewCounter, 1)

	if mmView.inspectFuncView != nil {
		mmView.inspectFuncView(ctx, pp1, u1)
	}

	mm_params := &IPostLogicMockViewParams{ctx, pp1, u1}

	// Record call args
	mmView.ViewMock.mutex.Lock()
	mmView.ViewMock.callArgs = append(mmView.ViewMock.callArgs, mm_params)
	mmView.ViewMock.mutex.Unlock()

	for _, e := range mmView.ViewMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmView.ViewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmView.ViewMock.defaultExpectation.Counter, 1)
		mm_want := mmView.ViewMock.defaultExpectation.params
		mm_got := IPostLogicMockViewParams{ctx, pp1, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmView.t.Errorf("IPostLogicMock.View got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmView.ViewMock.defaultExpectation.results
		if mm_results == nil {
			mmView.t.Fatal("No results are set for the IPostLogicMock.View")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmView.funcView != nil {
		return mmView.funcView(ctx, pp1, u1)
	}
	mmView.t.Fatalf("Unexpected call to IPostLogicMock.View. %v %v %v", ctx, pp1, u1)
	return
}

// ViewAfterCounter returns a count of finished IPostLogicMock.View invocations
func (mmView *IPostLogicMock) ViewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmView.afterViewCounter)
}

// ViewBeforeCounter returns a count of IPostLogicMock.View invocations
func (mmView *IPostLogicMock) ViewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmView.beforeViewCounter)
}

// Calls returns a list of arguments used in each call to IPostLogicMock.View.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmView *mIPostLogicMockView) Calls() []*IPostLogicMockViewParams {
	mmView.mutex.RLock()

	argCopy := make([]*IPostLogicMockViewParams, len(mmView.callArgs))
	copy(argCopy, mmView.callArgs)

	mmView.mutex.RUnlock()

	return argCopy
}

// MinimockViewDone returns true if the count of the View invocations corresponds
// the number of defined expectations
func (m *IPostLogicMock) MinimockViewDone() bool {
	for _, e := range m.ViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ViewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterViewCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcView != nil && mm_atomic.LoadUint64(&m.afterViewCounter) < 1 {
		return false
	}
	return true
}

// MinimockViewInspect logs each unmet expectation
func (m *IPostLogicMock) MinimockViewInspect() {
	for _, e := range m.ViewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPostLogicMock.View with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ViewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterViewCounter) < 1 {
		if m.ViewMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IPostLogicMock.View")
		} else {
			m.t.Errorf("Expected call to IPostLogicMock.View with params: %#v", *m.ViewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcView != nil && mm_atomic.LoadUint64(&m.afterViewCounter) < 1 {
		m.t.Error("Expected call to IPostLogicMock.View")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPostLogicMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChangePermsInspect()

		m.MinimockCommentInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockGetAllInspect()

		m.MinimockGetAllCommentsInspect()

		m.MinimockGetReactionTypesInspect()

		m.MinimockGetTotalByUserIDInspect()

		m.MinimockGetTotalCommentsByPostIDInspect()

		m.MinimockPopularityCheckInspect()

		m.MinimockPublishInspect()

		m.MinimockReactInspect()

		m.MinimockUncommentInspect()

		m.MinimockViewInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPostLogicMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPostLogicMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangePermsDone() &&
		m.MinimockCommentDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetAllCommentsDone() &&
		m.MinimockGetReactionTypesDone() &&
		m.MinimockGetTotalByUserIDDone() &&
		m.MinimockGetTotalCommentsByPostIDDone() &&
		m.MinimockPopularityCheckDone() &&
		m.MinimockPublishDone() &&
		m.MinimockReactDone() &&
		m.MinimockUncommentDone() &&
		m.MinimockViewDone()
}

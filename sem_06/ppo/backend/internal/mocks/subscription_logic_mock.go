package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.ISubscriptionLogic -o ./internal/mocks/i_subscription_logic_mock_test.go -n ISubscriptionLogicMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ISubscriptionLogicMock implements interfaces.ISubscriptionLogic
type ISubscriptionLogicMock struct {
	t minimock.Tester

	funcGetSubscriptions          func(ctx context.Context) (upa1 []*models.User, err error)
	inspectFuncGetSubscriptions   func(ctx context.Context)
	afterGetSubscriptionsCounter  uint64
	beforeGetSubscriptionsCounter uint64
	GetSubscriptionsMock          mISubscriptionLogicMockGetSubscriptions

	funcIsSubscribed          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)
	inspectFuncIsSubscribed   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterIsSubscribedCounter  uint64
	beforeIsSubscribedCounter uint64
	IsSubscribedMock          mISubscriptionLogicMockIsSubscribed

	funcSubscribe          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncSubscribe   func(ctx context.Context, u1 uuid.UUID)
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mISubscriptionLogicMockSubscribe
}

// NewISubscriptionLogicMock returns a mock for interfaces.ISubscriptionLogic
func NewISubscriptionLogicMock(t minimock.Tester) *ISubscriptionLogicMock {
	m := &ISubscriptionLogicMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetSubscriptionsMock = mISubscriptionLogicMockGetSubscriptions{mock: m}
	m.GetSubscriptionsMock.callArgs = []*ISubscriptionLogicMockGetSubscriptionsParams{}

	m.IsSubscribedMock = mISubscriptionLogicMockIsSubscribed{mock: m}
	m.IsSubscribedMock.callArgs = []*ISubscriptionLogicMockIsSubscribedParams{}

	m.SubscribeMock = mISubscriptionLogicMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*ISubscriptionLogicMockSubscribeParams{}

	return m
}

type mISubscriptionLogicMockGetSubscriptions struct {
	mock               *ISubscriptionLogicMock
	defaultExpectation *ISubscriptionLogicMockGetSubscriptionsExpectation
	expectations       []*ISubscriptionLogicMockGetSubscriptionsExpectation

	callArgs []*ISubscriptionLogicMockGetSubscriptionsParams
	mutex    sync.RWMutex
}

// ISubscriptionLogicMockGetSubscriptionsExpectation specifies expectation struct of the ISubscriptionLogic.GetSubscriptions
type ISubscriptionLogicMockGetSubscriptionsExpectation struct {
	mock    *ISubscriptionLogicMock
	params  *ISubscriptionLogicMockGetSubscriptionsParams
	results *ISubscriptionLogicMockGetSubscriptionsResults
	Counter uint64
}

// ISubscriptionLogicMockGetSubscriptionsParams contains parameters of the ISubscriptionLogic.GetSubscriptions
type ISubscriptionLogicMockGetSubscriptionsParams struct {
	ctx context.Context
}

// ISubscriptionLogicMockGetSubscriptionsResults contains results of the ISubscriptionLogic.GetSubscriptions
type ISubscriptionLogicMockGetSubscriptionsResults struct {
	upa1 []*models.User
	err  error
}

// Expect sets up expected params for ISubscriptionLogic.GetSubscriptions
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) Expect(ctx context.Context) *mISubscriptionLogicMockGetSubscriptions {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("ISubscriptionLogicMock.GetSubscriptions mock is already set by Set")
	}

	if mmGetSubscriptions.defaultExpectation == nil {
		mmGetSubscriptions.defaultExpectation = &ISubscriptionLogicMockGetSubscriptionsExpectation{}
	}

	mmGetSubscriptions.defaultExpectation.params = &ISubscriptionLogicMockGetSubscriptionsParams{ctx}
	for _, e := range mmGetSubscriptions.expectations {
		if minimock.Equal(e.params, mmGetSubscriptions.defaultExpectation.params) {
			mmGetSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscriptions.defaultExpectation.params)
		}
	}

	return mmGetSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionLogic.GetSubscriptions
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) Inspect(f func(ctx context.Context)) *mISubscriptionLogicMockGetSubscriptions {
	if mmGetSubscriptions.mock.inspectFuncGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("Inspect function is already set for ISubscriptionLogicMock.GetSubscriptions")
	}

	mmGetSubscriptions.mock.inspectFuncGetSubscriptions = f

	return mmGetSubscriptions
}

// Return sets up results that will be returned by ISubscriptionLogic.GetSubscriptions
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) Return(upa1 []*models.User, err error) *ISubscriptionLogicMock {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("ISubscriptionLogicMock.GetSubscriptions mock is already set by Set")
	}

	if mmGetSubscriptions.defaultExpectation == nil {
		mmGetSubscriptions.defaultExpectation = &ISubscriptionLogicMockGetSubscriptionsExpectation{mock: mmGetSubscriptions.mock}
	}
	mmGetSubscriptions.defaultExpectation.results = &ISubscriptionLogicMockGetSubscriptionsResults{upa1, err}
	return mmGetSubscriptions.mock
}

// Set uses given function f to mock the ISubscriptionLogic.GetSubscriptions method
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) Set(f func(ctx context.Context) (upa1 []*models.User, err error)) *ISubscriptionLogicMock {
	if mmGetSubscriptions.defaultExpectation != nil {
		mmGetSubscriptions.mock.t.Fatalf("Default expectation is already set for the ISubscriptionLogic.GetSubscriptions method")
	}

	if len(mmGetSubscriptions.expectations) > 0 {
		mmGetSubscriptions.mock.t.Fatalf("Some expectations are already set for the ISubscriptionLogic.GetSubscriptions method")
	}

	mmGetSubscriptions.mock.funcGetSubscriptions = f
	return mmGetSubscriptions.mock
}

// When sets expectation for the ISubscriptionLogic.GetSubscriptions which will trigger the result defined by the following
// Then helper
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) When(ctx context.Context) *ISubscriptionLogicMockGetSubscriptionsExpectation {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("ISubscriptionLogicMock.GetSubscriptions mock is already set by Set")
	}

	expectation := &ISubscriptionLogicMockGetSubscriptionsExpectation{
		mock:   mmGetSubscriptions.mock,
		params: &ISubscriptionLogicMockGetSubscriptionsParams{ctx},
	}
	mmGetSubscriptions.expectations = append(mmGetSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ISubscriptionLogic.GetSubscriptions return parameters for the expectation previously defined by the When method
func (e *ISubscriptionLogicMockGetSubscriptionsExpectation) Then(upa1 []*models.User, err error) *ISubscriptionLogicMock {
	e.results = &ISubscriptionLogicMockGetSubscriptionsResults{upa1, err}
	return e.mock
}

// GetSubscriptions implements interfaces.ISubscriptionLogic
func (mmGetSubscriptions *ISubscriptionLogicMock) GetSubscriptions(ctx context.Context) (upa1 []*models.User, err error) {
	mm_atomic.AddUint64(&mmGetSubscriptions.beforeGetSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscriptions.afterGetSubscriptionsCounter, 1)

	if mmGetSubscriptions.inspectFuncGetSubscriptions != nil {
		mmGetSubscriptions.inspectFuncGetSubscriptions(ctx)
	}

	mm_params := &ISubscriptionLogicMockGetSubscriptionsParams{ctx}

	// Record call args
	mmGetSubscriptions.GetSubscriptionsMock.mutex.Lock()
	mmGetSubscriptions.GetSubscriptionsMock.callArgs = append(mmGetSubscriptions.GetSubscriptionsMock.callArgs, mm_params)
	mmGetSubscriptions.GetSubscriptionsMock.mutex.Unlock()

	for _, e := range mmGetSubscriptions.GetSubscriptionsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.upa1, e.results.err
		}
	}

	if mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.params
		mm_got := ISubscriptionLogicMockGetSubscriptionsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscriptions.t.Errorf("ISubscriptionLogicMock.GetSubscriptions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscriptions.t.Fatal("No results are set for the ISubscriptionLogicMock.GetSubscriptions")
		}
		return (*mm_results).upa1, (*mm_results).err
	}
	if mmGetSubscriptions.funcGetSubscriptions != nil {
		return mmGetSubscriptions.funcGetSubscriptions(ctx)
	}
	mmGetSubscriptions.t.Fatalf("Unexpected call to ISubscriptionLogicMock.GetSubscriptions. %v", ctx)
	return
}

// GetSubscriptionsAfterCounter returns a count of finished ISubscriptionLogicMock.GetSubscriptions invocations
func (mmGetSubscriptions *ISubscriptionLogicMock) GetSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptions.afterGetSubscriptionsCounter)
}

// GetSubscriptionsBeforeCounter returns a count of ISubscriptionLogicMock.GetSubscriptions invocations
func (mmGetSubscriptions *ISubscriptionLogicMock) GetSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptions.beforeGetSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ISubscriptionLogicMock.GetSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscriptions *mISubscriptionLogicMockGetSubscriptions) Calls() []*ISubscriptionLogicMockGetSubscriptionsParams {
	mmGetSubscriptions.mutex.RLock()

	argCopy := make([]*ISubscriptionLogicMockGetSubscriptionsParams, len(mmGetSubscriptions.callArgs))
	copy(argCopy, mmGetSubscriptions.callArgs)

	mmGetSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionsDone returns true if the count of the GetSubscriptions invocations corresponds
// the number of defined expectations
func (m *ISubscriptionLogicMock) MinimockGetSubscriptionsDone() bool {
	for _, e := range m.GetSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptions != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionsInspect logs each unmet expectation
func (m *ISubscriptionLogicMock) MinimockGetSubscriptionsInspect() {
	for _, e := range m.GetSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.GetSubscriptions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		if m.GetSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ISubscriptionLogicMock.GetSubscriptions")
		} else {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.GetSubscriptions with params: %#v", *m.GetSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptions != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionLogicMock.GetSubscriptions")
	}
}

type mISubscriptionLogicMockIsSubscribed struct {
	mock               *ISubscriptionLogicMock
	defaultExpectation *ISubscriptionLogicMockIsSubscribedExpectation
	expectations       []*ISubscriptionLogicMockIsSubscribedExpectation

	callArgs []*ISubscriptionLogicMockIsSubscribedParams
	mutex    sync.RWMutex
}

// ISubscriptionLogicMockIsSubscribedExpectation specifies expectation struct of the ISubscriptionLogic.IsSubscribed
type ISubscriptionLogicMockIsSubscribedExpectation struct {
	mock    *ISubscriptionLogicMock
	params  *ISubscriptionLogicMockIsSubscribedParams
	results *ISubscriptionLogicMockIsSubscribedResults
	Counter uint64
}

// ISubscriptionLogicMockIsSubscribedParams contains parameters of the ISubscriptionLogic.IsSubscribed
type ISubscriptionLogicMockIsSubscribedParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// ISubscriptionLogicMockIsSubscribedResults contains results of the ISubscriptionLogic.IsSubscribed
type ISubscriptionLogicMockIsSubscribedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for ISubscriptionLogic.IsSubscribed
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mISubscriptionLogicMockIsSubscribed {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("ISubscriptionLogicMock.IsSubscribed mock is already set by Set")
	}

	if mmIsSubscribed.defaultExpectation == nil {
		mmIsSubscribed.defaultExpectation = &ISubscriptionLogicMockIsSubscribedExpectation{}
	}

	mmIsSubscribed.defaultExpectation.params = &ISubscriptionLogicMockIsSubscribedParams{ctx, u1, u2}
	for _, e := range mmIsSubscribed.expectations {
		if minimock.Equal(e.params, mmIsSubscribed.defaultExpectation.params) {
			mmIsSubscribed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSubscribed.defaultExpectation.params)
		}
	}

	return mmIsSubscribed
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionLogic.IsSubscribed
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mISubscriptionLogicMockIsSubscribed {
	if mmIsSubscribed.mock.inspectFuncIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("Inspect function is already set for ISubscriptionLogicMock.IsSubscribed")
	}

	mmIsSubscribed.mock.inspectFuncIsSubscribed = f

	return mmIsSubscribed
}

// Return sets up results that will be returned by ISubscriptionLogic.IsSubscribed
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) Return(b1 bool, err error) *ISubscriptionLogicMock {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("ISubscriptionLogicMock.IsSubscribed mock is already set by Set")
	}

	if mmIsSubscribed.defaultExpectation == nil {
		mmIsSubscribed.defaultExpectation = &ISubscriptionLogicMockIsSubscribedExpectation{mock: mmIsSubscribed.mock}
	}
	mmIsSubscribed.defaultExpectation.results = &ISubscriptionLogicMockIsSubscribedResults{b1, err}
	return mmIsSubscribed.mock
}

// Set uses given function f to mock the ISubscriptionLogic.IsSubscribed method
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)) *ISubscriptionLogicMock {
	if mmIsSubscribed.defaultExpectation != nil {
		mmIsSubscribed.mock.t.Fatalf("Default expectation is already set for the ISubscriptionLogic.IsSubscribed method")
	}

	if len(mmIsSubscribed.expectations) > 0 {
		mmIsSubscribed.mock.t.Fatalf("Some expectations are already set for the ISubscriptionLogic.IsSubscribed method")
	}

	mmIsSubscribed.mock.funcIsSubscribed = f
	return mmIsSubscribed.mock
}

// When sets expectation for the ISubscriptionLogic.IsSubscribed which will trigger the result defined by the following
// Then helper
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *ISubscriptionLogicMockIsSubscribedExpectation {
	if mmIsSubscribed.mock.funcIsSubscribed != nil {
		mmIsSubscribed.mock.t.Fatalf("ISubscriptionLogicMock.IsSubscribed mock is already set by Set")
	}

	expectation := &ISubscriptionLogicMockIsSubscribedExpectation{
		mock:   mmIsSubscribed.mock,
		params: &ISubscriptionLogicMockIsSubscribedParams{ctx, u1, u2},
	}
	mmIsSubscribed.expectations = append(mmIsSubscribed.expectations, expectation)
	return expectation
}

// Then sets up ISubscriptionLogic.IsSubscribed return parameters for the expectation previously defined by the When method
func (e *ISubscriptionLogicMockIsSubscribedExpectation) Then(b1 bool, err error) *ISubscriptionLogicMock {
	e.results = &ISubscriptionLogicMockIsSubscribedResults{b1, err}
	return e.mock
}

// IsSubscribed implements interfaces.ISubscriptionLogic
func (mmIsSubscribed *ISubscriptionLogicMock) IsSubscribed(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsSubscribed.beforeIsSubscribedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSubscribed.afterIsSubscribedCounter, 1)

	if mmIsSubscribed.inspectFuncIsSubscribed != nil {
		mmIsSubscribed.inspectFuncIsSubscribed(ctx, u1, u2)
	}

	mm_params := &ISubscriptionLogicMockIsSubscribedParams{ctx, u1, u2}

	// Record call args
	mmIsSubscribed.IsSubscribedMock.mutex.Lock()
	mmIsSubscribed.IsSubscribedMock.callArgs = append(mmIsSubscribed.IsSubscribedMock.callArgs, mm_params)
	mmIsSubscribed.IsSubscribedMock.mutex.Unlock()

	for _, e := range mmIsSubscribed.IsSubscribedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsSubscribed.IsSubscribedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSubscribed.IsSubscribedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsSubscribed.IsSubscribedMock.defaultExpectation.params
		mm_got := ISubscriptionLogicMockIsSubscribedParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsSubscribed.t.Errorf("ISubscriptionLogicMock.IsSubscribed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsSubscribed.IsSubscribedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsSubscribed.t.Fatal("No results are set for the ISubscriptionLogicMock.IsSubscribed")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsSubscribed.funcIsSubscribed != nil {
		return mmIsSubscribed.funcIsSubscribed(ctx, u1, u2)
	}
	mmIsSubscribed.t.Fatalf("Unexpected call to ISubscriptionLogicMock.IsSubscribed. %v %v %v", ctx, u1, u2)
	return
}

// IsSubscribedAfterCounter returns a count of finished ISubscriptionLogicMock.IsSubscribed invocations
func (mmIsSubscribed *ISubscriptionLogicMock) IsSubscribedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSubscribed.afterIsSubscribedCounter)
}

// IsSubscribedBeforeCounter returns a count of ISubscriptionLogicMock.IsSubscribed invocations
func (mmIsSubscribed *ISubscriptionLogicMock) IsSubscribedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSubscribed.beforeIsSubscribedCounter)
}

// Calls returns a list of arguments used in each call to ISubscriptionLogicMock.IsSubscribed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSubscribed *mISubscriptionLogicMockIsSubscribed) Calls() []*ISubscriptionLogicMockIsSubscribedParams {
	mmIsSubscribed.mutex.RLock()

	argCopy := make([]*ISubscriptionLogicMockIsSubscribedParams, len(mmIsSubscribed.callArgs))
	copy(argCopy, mmIsSubscribed.callArgs)

	mmIsSubscribed.mutex.RUnlock()

	return argCopy
}

// MinimockIsSubscribedDone returns true if the count of the IsSubscribed invocations corresponds
// the number of defined expectations
func (m *ISubscriptionLogicMock) MinimockIsSubscribedDone() bool {
	for _, e := range m.IsSubscribedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSubscribedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSubscribed != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsSubscribedInspect logs each unmet expectation
func (m *ISubscriptionLogicMock) MinimockIsSubscribedInspect() {
	for _, e := range m.IsSubscribedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.IsSubscribed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSubscribedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		if m.IsSubscribedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ISubscriptionLogicMock.IsSubscribed")
		} else {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.IsSubscribed with params: %#v", *m.IsSubscribedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSubscribed != nil && mm_atomic.LoadUint64(&m.afterIsSubscribedCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionLogicMock.IsSubscribed")
	}
}

type mISubscriptionLogicMockSubscribe struct {
	mock               *ISubscriptionLogicMock
	defaultExpectation *ISubscriptionLogicMockSubscribeExpectation
	expectations       []*ISubscriptionLogicMockSubscribeExpectation

	callArgs []*ISubscriptionLogicMockSubscribeParams
	mutex    sync.RWMutex
}

// ISubscriptionLogicMockSubscribeExpectation specifies expectation struct of the ISubscriptionLogic.Subscribe
type ISubscriptionLogicMockSubscribeExpectation struct {
	mock    *ISubscriptionLogicMock
	params  *ISubscriptionLogicMockSubscribeParams
	results *ISubscriptionLogicMockSubscribeResults
	Counter uint64
}

// ISubscriptionLogicMockSubscribeParams contains parameters of the ISubscriptionLogic.Subscribe
type ISubscriptionLogicMockSubscribeParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// ISubscriptionLogicMockSubscribeResults contains results of the ISubscriptionLogic.Subscribe
type ISubscriptionLogicMockSubscribeResults struct {
	err error
}

// Expect sets up expected params for ISubscriptionLogic.Subscribe
func (mmSubscribe *mISubscriptionLogicMockSubscribe) Expect(ctx context.Context, u1 uuid.UUID) *mISubscriptionLogicMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("ISubscriptionLogicMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &ISubscriptionLogicMockSubscribeExpectation{}
	}

	mmSubscribe.defaultExpectation.params = &ISubscriptionLogicMockSubscribeParams{ctx, u1}
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the ISubscriptionLogic.Subscribe
func (mmSubscribe *mISubscriptionLogicMockSubscribe) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mISubscriptionLogicMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for ISubscriptionLogicMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by ISubscriptionLogic.Subscribe
func (mmSubscribe *mISubscriptionLogicMockSubscribe) Return(err error) *ISubscriptionLogicMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("ISubscriptionLogicMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &ISubscriptionLogicMockSubscribeExpectation{mock: mmSubscribe.mock}
	}
	mmSubscribe.defaultExpectation.results = &ISubscriptionLogicMockSubscribeResults{err}
	return mmSubscribe.mock
}

// Set uses given function f to mock the ISubscriptionLogic.Subscribe method
func (mmSubscribe *mISubscriptionLogicMockSubscribe) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *ISubscriptionLogicMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the ISubscriptionLogic.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the ISubscriptionLogic.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	return mmSubscribe.mock
}

// When sets expectation for the ISubscriptionLogic.Subscribe which will trigger the result defined by the following
// Then helper
func (mmSubscribe *mISubscriptionLogicMockSubscribe) When(ctx context.Context, u1 uuid.UUID) *ISubscriptionLogicMockSubscribeExpectation {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("ISubscriptionLogicMock.Subscribe mock is already set by Set")
	}

	expectation := &ISubscriptionLogicMockSubscribeExpectation{
		mock:   mmSubscribe.mock,
		params: &ISubscriptionLogicMockSubscribeParams{ctx, u1},
	}
	mmSubscribe.expectations = append(mmSubscribe.expectations, expectation)
	return expectation
}

// Then sets up ISubscriptionLogic.Subscribe return parameters for the expectation previously defined by the When method
func (e *ISubscriptionLogicMockSubscribeExpectation) Then(err error) *ISubscriptionLogicMock {
	e.results = &ISubscriptionLogicMockSubscribeResults{err}
	return e.mock
}

// Subscribe implements interfaces.ISubscriptionLogic
func (mmSubscribe *ISubscriptionLogicMock) Subscribe(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(ctx, u1)
	}

	mm_params := &ISubscriptionLogicMockSubscribeParams{ctx, u1}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_got := ISubscriptionLogicMockSubscribeParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("ISubscriptionLogicMock.Subscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribe.SubscribeMock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribe.t.Fatal("No results are set for the ISubscriptionLogicMock.Subscribe")
		}
		return (*mm_results).err
	}
	if mmSubscribe.funcSubscribe != nil {
		return mmSubscribe.funcSubscribe(ctx, u1)
	}
	mmSubscribe.t.Fatalf("Unexpected call to ISubscriptionLogicMock.Subscribe. %v %v", ctx, u1)
	return
}

// SubscribeAfterCounter returns a count of finished ISubscriptionLogicMock.Subscribe invocations
func (mmSubscribe *ISubscriptionLogicMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of ISubscriptionLogicMock.Subscribe invocations
func (mmSubscribe *ISubscriptionLogicMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to ISubscriptionLogicMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mISubscriptionLogicMockSubscribe) Calls() []*ISubscriptionLogicMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*ISubscriptionLogicMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *ISubscriptionLogicMock) MinimockSubscribeDone() bool {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *ISubscriptionLogicMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.Subscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ISubscriptionLogicMock.Subscribe")
		} else {
			m.t.Errorf("Expected call to ISubscriptionLogicMock.Subscribe with params: %#v", *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		m.t.Error("Expected call to ISubscriptionLogicMock.Subscribe")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ISubscriptionLogicMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetSubscriptionsInspect()

		m.MinimockIsSubscribedInspect()

		m.MinimockSubscribeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ISubscriptionLogicMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ISubscriptionLogicMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetSubscriptionsDone() &&
		m.MinimockIsSubscribedDone() &&
		m.MinimockSubscribeDone()
}

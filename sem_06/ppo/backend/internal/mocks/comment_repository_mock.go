package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.ICommentRepository -o ./internal/mocks/i_comment_repository_mock_test.go -n ICommentRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ICommentRepositoryMock implements interfaces.ICommentRepository
type ICommentRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, cp1 *models.Comment) (cp2 *models.Comment, err error)
	inspectFuncCreate   func(ctx context.Context, cp1 *models.Comment)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mICommentRepositoryMockCreate

	funcDelete          func(ctx context.Context, u1 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mICommentRepositoryMockDelete

	funcGetAll          func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (cpa1 []*models.Comment, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mICommentRepositoryMockGetAll

	funcGetByID          func(ctx context.Context, u1 uuid.UUID) (cp1 *models.Comment, err error)
	inspectFuncGetByID   func(ctx context.Context, u1 uuid.UUID)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mICommentRepositoryMockGetByID

	funcGetTotal          func(ctx context.Context, u1 uuid.UUID) (i1 int, err error)
	inspectFuncGetTotal   func(ctx context.Context, u1 uuid.UUID)
	afterGetTotalCounter  uint64
	beforeGetTotalCounter uint64
	GetTotalMock          mICommentRepositoryMockGetTotal
}

// NewICommentRepositoryMock returns a mock for interfaces.ICommentRepository
func NewICommentRepositoryMock(t minimock.Tester) *ICommentRepositoryMock {
	m := &ICommentRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mICommentRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*ICommentRepositoryMockCreateParams{}

	m.DeleteMock = mICommentRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ICommentRepositoryMockDeleteParams{}

	m.GetAllMock = mICommentRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*ICommentRepositoryMockGetAllParams{}

	m.GetByIDMock = mICommentRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*ICommentRepositoryMockGetByIDParams{}

	m.GetTotalMock = mICommentRepositoryMockGetTotal{mock: m}
	m.GetTotalMock.callArgs = []*ICommentRepositoryMockGetTotalParams{}

	return m
}

type mICommentRepositoryMockCreate struct {
	mock               *ICommentRepositoryMock
	defaultExpectation *ICommentRepositoryMockCreateExpectation
	expectations       []*ICommentRepositoryMockCreateExpectation

	callArgs []*ICommentRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// ICommentRepositoryMockCreateExpectation specifies expectation struct of the ICommentRepository.Create
type ICommentRepositoryMockCreateExpectation struct {
	mock    *ICommentRepositoryMock
	params  *ICommentRepositoryMockCreateParams
	results *ICommentRepositoryMockCreateResults
	Counter uint64
}

// ICommentRepositoryMockCreateParams contains parameters of the ICommentRepository.Create
type ICommentRepositoryMockCreateParams struct {
	ctx context.Context
	cp1 *models.Comment
}

// ICommentRepositoryMockCreateResults contains results of the ICommentRepository.Create
type ICommentRepositoryMockCreateResults struct {
	cp2 *models.Comment
	err error
}

// Expect sets up expected params for ICommentRepository.Create
func (mmCreate *mICommentRepositoryMockCreate) Expect(ctx context.Context, cp1 *models.Comment) *mICommentRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ICommentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ICommentRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ICommentRepositoryMockCreateParams{ctx, cp1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ICommentRepository.Create
func (mmCreate *mICommentRepositoryMockCreate) Inspect(f func(ctx context.Context, cp1 *models.Comment)) *mICommentRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ICommentRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ICommentRepository.Create
func (mmCreate *mICommentRepositoryMockCreate) Return(cp2 *models.Comment, err error) *ICommentRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ICommentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ICommentRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ICommentRepositoryMockCreateResults{cp2, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ICommentRepository.Create method
func (mmCreate *mICommentRepositoryMockCreate) Set(f func(ctx context.Context, cp1 *models.Comment) (cp2 *models.Comment, err error)) *ICommentRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ICommentRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ICommentRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ICommentRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mICommentRepositoryMockCreate) When(ctx context.Context, cp1 *models.Comment) *ICommentRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ICommentRepositoryMock.Create mock is already set by Set")
	}

	expectation := &ICommentRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ICommentRepositoryMockCreateParams{ctx, cp1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ICommentRepository.Create return parameters for the expectation previously defined by the When method
func (e *ICommentRepositoryMockCreateExpectation) Then(cp2 *models.Comment, err error) *ICommentRepositoryMock {
	e.results = &ICommentRepositoryMockCreateResults{cp2, err}
	return e.mock
}

// Create implements interfaces.ICommentRepository
func (mmCreate *ICommentRepositoryMock) Create(ctx context.Context, cp1 *models.Comment) (cp2 *models.Comment, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, cp1)
	}

	mm_params := &ICommentRepositoryMockCreateParams{ctx, cp1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ICommentRepositoryMockCreateParams{ctx, cp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ICommentRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ICommentRepositoryMock.Create")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, cp1)
	}
	mmCreate.t.Fatalf("Unexpected call to ICommentRepositoryMock.Create. %v %v", ctx, cp1)
	return
}

// CreateAfterCounter returns a count of finished ICommentRepositoryMock.Create invocations
func (mmCreate *ICommentRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ICommentRepositoryMock.Create invocations
func (mmCreate *ICommentRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ICommentRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mICommentRepositoryMockCreate) Calls() []*ICommentRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ICommentRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ICommentRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ICommentRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICommentRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICommentRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to ICommentRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ICommentRepositoryMock.Create")
	}
}

type mICommentRepositoryMockDelete struct {
	mock               *ICommentRepositoryMock
	defaultExpectation *ICommentRepositoryMockDeleteExpectation
	expectations       []*ICommentRepositoryMockDeleteExpectation

	callArgs []*ICommentRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// ICommentRepositoryMockDeleteExpectation specifies expectation struct of the ICommentRepository.Delete
type ICommentRepositoryMockDeleteExpectation struct {
	mock    *ICommentRepositoryMock
	params  *ICommentRepositoryMockDeleteParams
	results *ICommentRepositoryMockDeleteResults
	Counter uint64
}

// ICommentRepositoryMockDeleteParams contains parameters of the ICommentRepository.Delete
type ICommentRepositoryMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// ICommentRepositoryMockDeleteResults contains results of the ICommentRepository.Delete
type ICommentRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for ICommentRepository.Delete
func (mmDelete *mICommentRepositoryMockDelete) Expect(ctx context.Context, u1 uuid.UUID) *mICommentRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ICommentRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ICommentRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ICommentRepositoryMockDeleteParams{ctx, u1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ICommentRepository.Delete
func (mmDelete *mICommentRepositoryMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mICommentRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ICommentRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ICommentRepository.Delete
func (mmDelete *mICommentRepositoryMockDelete) Return(err error) *ICommentRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ICommentRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ICommentRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ICommentRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ICommentRepository.Delete method
func (mmDelete *mICommentRepositoryMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *ICommentRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ICommentRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ICommentRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ICommentRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mICommentRepositoryMockDelete) When(ctx context.Context, u1 uuid.UUID) *ICommentRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ICommentRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &ICommentRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ICommentRepositoryMockDeleteParams{ctx, u1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ICommentRepository.Delete return parameters for the expectation previously defined by the When method
func (e *ICommentRepositoryMockDeleteExpectation) Then(err error) *ICommentRepositoryMock {
	e.results = &ICommentRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.ICommentRepository
func (mmDelete *ICommentRepositoryMock) Delete(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1)
	}

	mm_params := &ICommentRepositoryMockDeleteParams{ctx, u1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ICommentRepositoryMockDeleteParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ICommentRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ICommentRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1)
	}
	mmDelete.t.Fatalf("Unexpected call to ICommentRepositoryMock.Delete. %v %v", ctx, u1)
	return
}

// DeleteAfterCounter returns a count of finished ICommentRepositoryMock.Delete invocations
func (mmDelete *ICommentRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ICommentRepositoryMock.Delete invocations
func (mmDelete *ICommentRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ICommentRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mICommentRepositoryMockDelete) Calls() []*ICommentRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ICommentRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ICommentRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ICommentRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICommentRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICommentRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to ICommentRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ICommentRepositoryMock.Delete")
	}
}

type mICommentRepositoryMockGetAll struct {
	mock               *ICommentRepositoryMock
	defaultExpectation *ICommentRepositoryMockGetAllExpectation
	expectations       []*ICommentRepositoryMockGetAllExpectation

	callArgs []*ICommentRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// ICommentRepositoryMockGetAllExpectation specifies expectation struct of the ICommentRepository.GetAll
type ICommentRepositoryMockGetAllExpectation struct {
	mock    *ICommentRepositoryMock
	params  *ICommentRepositoryMockGetAllParams
	results *ICommentRepositoryMockGetAllResults
	Counter uint64
}

// ICommentRepositoryMockGetAllParams contains parameters of the ICommentRepository.GetAll
type ICommentRepositoryMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
	pp1 *models.Paginator
}

// ICommentRepositoryMockGetAllResults contains results of the ICommentRepository.GetAll
type ICommentRepositoryMockGetAllResults struct {
	cpa1 []*models.Comment
	err  error
}

// Expect sets up expected params for ICommentRepository.GetAll
func (mmGetAll *mICommentRepositoryMockGetAll) Expect(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *mICommentRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ICommentRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ICommentRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &ICommentRepositoryMockGetAllParams{ctx, u1, pp1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the ICommentRepository.GetAll
func (mmGetAll *mICommentRepositoryMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator)) *mICommentRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for ICommentRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by ICommentRepository.GetAll
func (mmGetAll *mICommentRepositoryMockGetAll) Return(cpa1 []*models.Comment, err error) *ICommentRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ICommentRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ICommentRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &ICommentRepositoryMockGetAllResults{cpa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the ICommentRepository.GetAll method
func (mmGetAll *mICommentRepositoryMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (cpa1 []*models.Comment, err error)) *ICommentRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the ICommentRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the ICommentRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the ICommentRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mICommentRepositoryMockGetAll) When(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) *ICommentRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ICommentRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &ICommentRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &ICommentRepositoryMockGetAllParams{ctx, u1, pp1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up ICommentRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *ICommentRepositoryMockGetAllExpectation) Then(cpa1 []*models.Comment, err error) *ICommentRepositoryMock {
	e.results = &ICommentRepositoryMockGetAllResults{cpa1, err}
	return e.mock
}

// GetAll implements interfaces.ICommentRepository
func (mmGetAll *ICommentRepositoryMock) GetAll(ctx context.Context, u1 uuid.UUID, pp1 *models.Paginator) (cpa1 []*models.Comment, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1, pp1)
	}

	mm_params := &ICommentRepositoryMockGetAllParams{ctx, u1, pp1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := ICommentRepositoryMockGetAllParams{ctx, u1, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("ICommentRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the ICommentRepositoryMock.GetAll")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1, pp1)
	}
	mmGetAll.t.Fatalf("Unexpected call to ICommentRepositoryMock.GetAll. %v %v %v", ctx, u1, pp1)
	return
}

// GetAllAfterCounter returns a count of finished ICommentRepositoryMock.GetAll invocations
func (mmGetAll *ICommentRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of ICommentRepositoryMock.GetAll invocations
func (mmGetAll *ICommentRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to ICommentRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mICommentRepositoryMockGetAll) Calls() []*ICommentRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*ICommentRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *ICommentRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *ICommentRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICommentRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to ICommentRepositoryMock.GetAll")
	}
}

type mICommentRepositoryMockGetByID struct {
	mock               *ICommentRepositoryMock
	defaultExpectation *ICommentRepositoryMockGetByIDExpectation
	expectations       []*ICommentRepositoryMockGetByIDExpectation

	callArgs []*ICommentRepositoryMockGetByIDParams
	mutex    sync.RWMutex
}

// ICommentRepositoryMockGetByIDExpectation specifies expectation struct of the ICommentRepository.GetByID
type ICommentRepositoryMockGetByIDExpectation struct {
	mock    *ICommentRepositoryMock
	params  *ICommentRepositoryMockGetByIDParams
	results *ICommentRepositoryMockGetByIDResults
	Counter uint64
}

// ICommentRepositoryMockGetByIDParams contains parameters of the ICommentRepository.GetByID
type ICommentRepositoryMockGetByIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// ICommentRepositoryMockGetByIDResults contains results of the ICommentRepository.GetByID
type ICommentRepositoryMockGetByIDResults struct {
	cp1 *models.Comment
	err error
}

// Expect sets up expected params for ICommentRepository.GetByID
func (mmGetByID *mICommentRepositoryMockGetByID) Expect(ctx context.Context, u1 uuid.UUID) *mICommentRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ICommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ICommentRepositoryMockGetByIDExpectation{}
	}

	mmGetByID.defaultExpectation.params = &ICommentRepositoryMockGetByIDParams{ctx, u1}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the ICommentRepository.GetByID
func (mmGetByID *mICommentRepositoryMockGetByID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mICommentRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for ICommentRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by ICommentRepository.GetByID
func (mmGetByID *mICommentRepositoryMockGetByID) Return(cp1 *models.Comment, err error) *ICommentRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ICommentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ICommentRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &ICommentRepositoryMockGetByIDResults{cp1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the ICommentRepository.GetByID method
func (mmGetByID *mICommentRepositoryMockGetByID) Set(f func(ctx context.Context, u1 uuid.UUID) (cp1 *models.Comment, err error)) *ICommentRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the ICommentRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the ICommentRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the ICommentRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mICommentRepositoryMockGetByID) When(ctx context.Context, u1 uuid.UUID) *ICommentRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ICommentRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &ICommentRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &ICommentRepositoryMockGetByIDParams{ctx, u1},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up ICommentRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *ICommentRepositoryMockGetByIDExpectation) Then(cp1 *models.Comment, err error) *ICommentRepositoryMock {
	e.results = &ICommentRepositoryMockGetByIDResults{cp1, err}
	return e.mock
}

// GetByID implements interfaces.ICommentRepository
func (mmGetByID *ICommentRepositoryMock) GetByID(ctx context.Context, u1 uuid.UUID) (cp1 *models.Comment, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, u1)
	}

	mm_params := &ICommentRepositoryMockGetByIDParams{ctx, u1}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_got := ICommentRepositoryMockGetByIDParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("ICommentRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the ICommentRepositoryMock.GetByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, u1)
	}
	mmGetByID.t.Fatalf("Unexpected call to ICommentRepositoryMock.GetByID. %v %v", ctx, u1)
	return
}

// GetByIDAfterCounter returns a count of finished ICommentRepositoryMock.GetByID invocations
func (mmGetByID *ICommentRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of ICommentRepositoryMock.GetByID invocations
func (mmGetByID *ICommentRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to ICommentRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mICommentRepositoryMockGetByID) Calls() []*ICommentRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*ICommentRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *ICommentRepositoryMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *ICommentRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICommentRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to ICommentRepositoryMock.GetByID")
	}
}

type mICommentRepositoryMockGetTotal struct {
	mock               *ICommentRepositoryMock
	defaultExpectation *ICommentRepositoryMockGetTotalExpectation
	expectations       []*ICommentRepositoryMockGetTotalExpectation

	callArgs []*ICommentRepositoryMockGetTotalParams
	mutex    sync.RWMutex
}

// ICommentRepositoryMockGetTotalExpectation specifies expectation struct of the ICommentRepository.GetTotal
type ICommentRepositoryMockGetTotalExpectation struct {
	mock    *ICommentRepositoryMock
	params  *ICommentRepositoryMockGetTotalParams
	results *ICommentRepositoryMockGetTotalResults
	Counter uint64
}

// ICommentRepositoryMockGetTotalParams contains parameters of the ICommentRepository.GetTotal
type ICommentRepositoryMockGetTotalParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// ICommentRepositoryMockGetTotalResults contains results of the ICommentRepository.GetTotal
type ICommentRepositoryMockGetTotalResults struct {
	i1  int
	err error
}

// Expect sets up expected params for ICommentRepository.GetTotal
func (mmGetTotal *mICommentRepositoryMockGetTotal) Expect(ctx context.Context, u1 uuid.UUID) *mICommentRepositoryMockGetTotal {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("ICommentRepositoryMock.GetTotal mock is already set by Set")
	}

	if mmGetTotal.defaultExpectation == nil {
		mmGetTotal.defaultExpectation = &ICommentRepositoryMockGetTotalExpectation{}
	}

	mmGetTotal.defaultExpectation.params = &ICommentRepositoryMockGetTotalParams{ctx, u1}
	for _, e := range mmGetTotal.expectations {
		if minimock.Equal(e.params, mmGetTotal.defaultExpectation.params) {
			mmGetTotal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotal.defaultExpectation.params)
		}
	}

	return mmGetTotal
}

// Inspect accepts an inspector function that has same arguments as the ICommentRepository.GetTotal
func (mmGetTotal *mICommentRepositoryMockGetTotal) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mICommentRepositoryMockGetTotal {
	if mmGetTotal.mock.inspectFuncGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("Inspect function is already set for ICommentRepositoryMock.GetTotal")
	}

	mmGetTotal.mock.inspectFuncGetTotal = f

	return mmGetTotal
}

// Return sets up results that will be returned by ICommentRepository.GetTotal
func (mmGetTotal *mICommentRepositoryMockGetTotal) Return(i1 int, err error) *ICommentRepositoryMock {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("ICommentRepositoryMock.GetTotal mock is already set by Set")
	}

	if mmGetTotal.defaultExpectation == nil {
		mmGetTotal.defaultExpectation = &ICommentRepositoryMockGetTotalExpectation{mock: mmGetTotal.mock}
	}
	mmGetTotal.defaultExpectation.results = &ICommentRepositoryMockGetTotalResults{i1, err}
	return mmGetTotal.mock
}

// Set uses given function f to mock the ICommentRepository.GetTotal method
func (mmGetTotal *mICommentRepositoryMockGetTotal) Set(f func(ctx context.Context, u1 uuid.UUID) (i1 int, err error)) *ICommentRepositoryMock {
	if mmGetTotal.defaultExpectation != nil {
		mmGetTotal.mock.t.Fatalf("Default expectation is already set for the ICommentRepository.GetTotal method")
	}

	if len(mmGetTotal.expectations) > 0 {
		mmGetTotal.mock.t.Fatalf("Some expectations are already set for the ICommentRepository.GetTotal method")
	}

	mmGetTotal.mock.funcGetTotal = f
	return mmGetTotal.mock
}

// When sets expectation for the ICommentRepository.GetTotal which will trigger the result defined by the following
// Then helper
func (mmGetTotal *mICommentRepositoryMockGetTotal) When(ctx context.Context, u1 uuid.UUID) *ICommentRepositoryMockGetTotalExpectation {
	if mmGetTotal.mock.funcGetTotal != nil {
		mmGetTotal.mock.t.Fatalf("ICommentRepositoryMock.GetTotal mock is already set by Set")
	}

	expectation := &ICommentRepositoryMockGetTotalExpectation{
		mock:   mmGetTotal.mock,
		params: &ICommentRepositoryMockGetTotalParams{ctx, u1},
	}
	mmGetTotal.expectations = append(mmGetTotal.expectations, expectation)
	return expectation
}

// Then sets up ICommentRepository.GetTotal return parameters for the expectation previously defined by the When method
func (e *ICommentRepositoryMockGetTotalExpectation) Then(i1 int, err error) *ICommentRepositoryMock {
	e.results = &ICommentRepositoryMockGetTotalResults{i1, err}
	return e.mock
}

// GetTotal implements interfaces.ICommentRepository
func (mmGetTotal *ICommentRepositoryMock) GetTotal(ctx context.Context, u1 uuid.UUID) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetTotal.beforeGetTotalCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotal.afterGetTotalCounter, 1)

	if mmGetTotal.inspectFuncGetTotal != nil {
		mmGetTotal.inspectFuncGetTotal(ctx, u1)
	}

	mm_params := &ICommentRepositoryMockGetTotalParams{ctx, u1}

	// Record call args
	mmGetTotal.GetTotalMock.mutex.Lock()
	mmGetTotal.GetTotalMock.callArgs = append(mmGetTotal.GetTotalMock.callArgs, mm_params)
	mmGetTotal.GetTotalMock.mutex.Unlock()

	for _, e := range mmGetTotal.GetTotalMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetTotal.GetTotalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotal.GetTotalMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotal.GetTotalMock.defaultExpectation.params
		mm_got := ICommentRepositoryMockGetTotalParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotal.t.Errorf("ICommentRepositoryMock.GetTotal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotal.GetTotalMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotal.t.Fatal("No results are set for the ICommentRepositoryMock.GetTotal")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetTotal.funcGetTotal != nil {
		return mmGetTotal.funcGetTotal(ctx, u1)
	}
	mmGetTotal.t.Fatalf("Unexpected call to ICommentRepositoryMock.GetTotal. %v %v", ctx, u1)
	return
}

// GetTotalAfterCounter returns a count of finished ICommentRepositoryMock.GetTotal invocations
func (mmGetTotal *ICommentRepositoryMock) GetTotalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotal.afterGetTotalCounter)
}

// GetTotalBeforeCounter returns a count of ICommentRepositoryMock.GetTotal invocations
func (mmGetTotal *ICommentRepositoryMock) GetTotalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotal.beforeGetTotalCounter)
}

// Calls returns a list of arguments used in each call to ICommentRepositoryMock.GetTotal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotal *mICommentRepositoryMockGetTotal) Calls() []*ICommentRepositoryMockGetTotalParams {
	mmGetTotal.mutex.RLock()

	argCopy := make([]*ICommentRepositoryMockGetTotalParams, len(mmGetTotal.callArgs))
	copy(argCopy, mmGetTotal.callArgs)

	mmGetTotal.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalDone returns true if the count of the GetTotal invocations corresponds
// the number of defined expectations
func (m *ICommentRepositoryMock) MinimockGetTotalDone() bool {
	for _, e := range m.GetTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotal != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTotalInspect logs each unmet expectation
func (m *ICommentRepositoryMock) MinimockGetTotalInspect() {
	for _, e := range m.GetTotalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetTotal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		if m.GetTotalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICommentRepositoryMock.GetTotal")
		} else {
			m.t.Errorf("Expected call to ICommentRepositoryMock.GetTotal with params: %#v", *m.GetTotalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotal != nil && mm_atomic.LoadUint64(&m.afterGetTotalCounter) < 1 {
		m.t.Error("Expected call to ICommentRepositoryMock.GetTotal")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICommentRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetAllInspect()

		m.MinimockGetByIDInspect()

		m.MinimockGetTotalInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICommentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICommentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockGetTotalDone()
}

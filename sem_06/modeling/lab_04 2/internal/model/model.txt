
package model

import (
	"encoding/json"
	"fmt"
	"gonum.org/v1/gonum/interp"
	"math"
	"os"
)

const (
	Eps = 1e-8
)

type Range struct {
	Min, Max float64
}

type Steps struct {
	Time   int
	Radius int
}

type Step struct {
	Time   float64
	Radius float64
}

type CParams struct {
	A, B, C, M float64
}

type Model struct {
	Lambda  interp.Predictor
	K       interp.Predictor
	N       float64
	Radius  Range
	Time    Range
	Steps   Steps
	T0      float64
	Sigma   float64
	FMax    float64
	Alpha   float64
	Eps1    float64
	Eps2    float64
	Epsilon float64
	CParams CParams

	baseP float64
	baseF float64
	step  Step
}

func FromFile(name string) (*Model, error) {
	file, err := os.Open(name)
	if err != nil {
		return nil, fmt.Errorf("open file: %w", err)
	}

	var c config
	if err := json.NewDecoder(file).Decode(&c); err != nil {
		return nil, fmt.Errorf("decode config: %w", err)
	}

	lambda := new(interp.AkimaSpline)
	if err := lambda.Fit(c.Lambda.X, c.Lambda.Y); err != nil {
		return nil, fmt.Errorf("fit interpolation table to lambda: %w", err)
	}

	k := new(interp.AkimaSpline)
	if err := k.Fit(c.K.X, c.K.Y); err != nil {
		return nil, fmt.Errorf("fit interpolation table to k: %w", err)
	}

	return &Model{
		Lambda:  lambda,
		K:       k,
		N:       c.N,
		Radius:  c.Radius,
		Time:    c.Time,
		Steps:   c.Steps,
		T0:      c.T0,
		Sigma:   c.Sigma,
		FMax:    c.FMax,
		Alpha:   c.Alpha,
		Eps1:    c.Eps1,
		Eps2:    c.Eps2,
		Epsilon: c.Epsilon,
		CParams: c.CParams,
	}, nil
}

func (m *Model) computeRadiusStep() float64 {
	return (m.Radius.Max - m.Radius.Min) / float64(m.Steps.Radius)
}

func (m *Model) computeTimeStep() float64 {
	return (m.Time.Max - m.Time.Min) / float64(m.Steps.Time)
}

func (m *Model) c(T float64) float64 {
	a2, b2, c2, m2 := m.CParams.A, m.CParams.B, m.CParams.C, m.CParams.M
	return a2 + b2*math.Pow(T, m2) - c2/math.Pow(T, 2)
}

func (m *Model) f(T float64) float64 {
	return 4 * m.K.Predict(T) * math.Pow(m.N, 2) * m.Sigma * (math.Pow(T, 4) - math.Pow(m.T0, 4))
}

func (m *Model) F0(t float64) float64 {
	return 0
	return (m.FMax / m.Time.Max) * t * math.Exp(1-(t/m.Time.Max))
}

func (m *Model) computeSteps() Step {
	return Step{
		Time:   m.computeTimeStep(),
		Radius: m.computeRadiusStep(),
	}
}

func (m *Model) Compute() *Result {
	m.step = m.computeSteps()

	r := make([]float64, m.Steps.Radius+1)
	for i := range r {
		r[i] = m.Radius.Min + float64(i)*m.step.Radius
	}

	t := make([]float64, m.Steps.Time+1)
	for i := range t {
		t[i] = m.Time.Min + float64(i)*m.step.Time
	}

	T := make([][]float64, m.Steps.Time+1)
	for i := range T {
		T[i] = make([]float64, m.Steps.Radius+1)
	}
	for i := range T[0] {
		T[0][i] = m.T0
	}

	for ct := 0; ct < m.Steps.Time-1; ct++ {
		system := NewSystem(m.Steps.Radius - 1)

		f1 := 0.0
		f2 := 0.0

		iterations := 0

		m.baseP = 4 * m.N * m.N * m.Sigma
		m.baseF = m.baseP * math.Pow(m.T0, 4)

		tmpT := T[ct]

		for {
			for n := 0; n < len(system); n++ {
				c := m.c(T[ct][n])
				f := m.f(T[ct][n])

				system[n].A = r[n] * m.step.Time * m.Lambda.Predict(tmpT[n])
				system[n].C = m.step.Radius*m.step.Time*m.Lambda.Predict(tmpT[n]) + r[n]*m.step.Time*m.Lambda.Predict(tmpT[n+1])
				system[n].B = system[n].C + r[n]*math.Pow(m.step.Radius, 2)*c + r[n]*m.step.Time*m.Lambda.Predict(tmpT[n])
				system[n].D = -f*r[n]*math.Pow(m.step.Radius, 2)*m.step.Time + r[n]*math.Pow(m.step.Radius, 2)*c*T[ct][n]
			}

			start := m.leftBoundaryConditions(tmpT, t, ct)
			end := m.rightBoundaryConditions(tmpT, t, ct)

			resultNew := system.runThrough(start, end)
			c := 0

			for i := 0; i <= m.Steps.Radius; i++ {
				if math.Abs((T[ct][i]-resultNew[i])/resultNew[i]) < m.Eps1 {
					c++
				}
			}

			tmpT = resultNew
			iterations++

			if iterations >= 5 {
				break
			}

			if c == m.Steps.Radius+1 {
				f1 = m.Radius.Min*m.F0(t[ct+1]) - m.Radius.Max*m.Alpha*(resultNew[len(resultNew)-1]-m.T0)

				tmp := make([]float64, m.Steps.Radius+1)
				for i := range tmp {
					tmp[i] = m.K.Predict(resultNew[i]) * (math.Pow(resultNew[i], 4) - math.Pow(m.T0, 4)) * r[i]
				}

				interpolation := new(interp.AkimaSpline)
				interpolation.Fit(r, tmp)

				f2 = 4 * m.N * m.N * m.Sigma * trapezoidal(m.Radius.Min, m.Radius.Max, m.Steps.Radius, interpolation)

				if math.Abs(f1) > Eps || math.Abs(f2) < Eps {
					break
				}

				if math.Abs((f1-f2)/f1) < m.Eps2 {
					break
				}
			}
		}

		T[ct+1] = tmpT
	}

	return &Result{
		Radius:      r,
		Temperature: T,
		Time:        t,
	}
}

// leftBoundaryConditions расчет коэффициентов левого краевого условия вида M0 * y0 + K0 * y1 = P0.
func (m *Model) leftBoundaryConditions(T []float64, t []float64, ct int) BoundaryConditions {
	lambda := m.Lambda.Predict(T[0])

	return BoundaryConditions{
		M: lambda,
		K: -lambda,
		P: m.F0(t[ct+1]) * m.step.Radius,
	}
}

// rightBoundaryConditions расчет коэффициентов правого краевого условия вида MN * y{N-1} + KN * yN = PN.
func (m *Model) rightBoundaryConditions(T []float64, _ []float64, ct int) BoundaryConditions {
	lambda := m.Lambda.Predict(T[m.Steps.Radius-1])

	return BoundaryConditions{
		M: lambda,
		K: -lambda - m.Alpha*m.step.Radius,
		P: -m.Alpha * m.step.Radius * m.T0,
	}
}

func trapezoidal(start, end float64, steps int, f interp.Predictor) float64 {
	step := (end - start) / float64(steps)
	x := start + step

	result := f.Predict(start) + f.Predict(end)

	for x < end {
		result += 2 * f.Predict(x)
		x += step
	}

	return result * step / 2
}

type configTable struct {
	X []float64
	Y []float64
}

type config struct {
	Lambda  configTable
	K       configTable
	N       float64
	Radius  Range
	Time    Range
	Steps   Steps
	T0      float64
	Sigma   float64
	FMax    float64
	Alpha   float64
	Eps1    float64
	Eps2    float64
	Epsilon float64
	CParams CParams
}

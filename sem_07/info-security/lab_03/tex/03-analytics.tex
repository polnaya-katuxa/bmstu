\section{Аналитический раздел}

\subsection{Стандарт шифрования данных AES}

AES представляет собой алгоритм шифрования 128-битных блоков данных ключами по 128, 192 и 256 бит. AES является упрощенной версией алгоритма Rijndael. Оригинальный алгоритм Rijndael отличается тем, что поддерживает более широкий набор длин блоков.

Введем следующие термины.
\begin{itemize}
	\item \textit{Слово} -- последовательность из 4-х байт.
	\item \textit{Форма} -- матрица 4х4 байт, использующаяся для представления блока.
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\multicolumn{1}{|c|}{b0} & \multicolumn{1}{c|}{b4} & \multicolumn{1}{c|}{b8} & \multicolumn{1}{c|}{b12} \\ \hline
			b1                       & b5                      & b9                      & b13                      \\ \hline
			b2                       & b6                      & b10                     & b14                      \\ \hline
			b3                       & b7                      & b11                     & b15                      \\ \hline
		\end{tabular}
	\end{table}
	\item \textit{Раунд} -- название итерации в цикле предобразований форм.
	\item \textit{$N_b$} -- количество слов в блоке.
	\item \textit{$N_k$} -- количество слов в ключе.
	\item \textit{$N_r$} -- количество раундов.
\end{itemize}

Количество слов в ключе и количество раундов соотносятся как:

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\multicolumn{1}{|c|}{Nk} & \multicolumn{1}{c|}{Nr} \\ \hline
		4                        & 10                      \\ \hline
		6                        & 12                      \\ \hline
		8                        & 14                      \\ \hline
	\end{tabular}
\end{table}

\subsection{Шифрование}

В алгоритме AES применяются следующие преобразования данных:

\begin{enumerate}
	\item ExpandKey — вычисление раундных ключей для всех раундов.
	\item SubBytes — подстановка байтов с помощью таблицы подстановок.
	\item ShiftRows — циклический сдвиг строк в форме на различные величины.
	\item MixColumns — смешивание данных внутри каждого столбца формы.
	\item AddRoundKey — сложение ключа раунда с формой.
\end{enumerate}

\subsubsection*{Преобразование SubBytes}
Преобразование SubBytes заключается в замене каждого байта {xy} формы (где x и y обозначают шестнадцатеричные цифры) на другой в соответствии таблицей, представленной на рисунке \ref{img:2.jpg}. Например, байт {fe} заменится на {bb}.

\img{0.5\textwidth}{2.jpg}{Таблица подстановок}

\subsubsection*{Преобразование ShiftRows}
Преобразование ShiftRows заключается в циклическом сдвиге влево строк формы. Преобразование схематично представлено на рисунке \ref{img:3.jpg}.
Первая строка остается неизменной. Во второй производится сдвиг на 1 байт, то есть первый байт переносится в конец. В третьей — сдвиг на 2 байта, в четвертой — на 3.

\img{0.3\textwidth}{3.jpg}{Преобразование ShiftRows}


\subsubsection*{Преобразование MixColumns}

Преобразование MixColumns заключается в умножении квадратной матрицы 4-го порядка на каждый столбец формы по
следующей формуле:

\img{0.3\textwidth}{4.jpg}{}

Умножение производится в поле Галуа GF($2^8$).
Над каждым столбцом операция производится отдельно, как показано на рисунке \ref{img:5.jpg}.

\img{0.5\textwidth}{5.jpg}{Преобразование MixColumns}

\subsubsection*{Преобразование AddRoundKey}

В преобразовании AddRoundKey 32-битные слова раундного ключа прибавляются к столбцам формы с помощью побитовой операции XOR:

\img{0.1\textwidth}{6.jpg}{}

Здесь $w_i$ — это столбцы ключа.

Над каждым столбцом операция производится отдельно, как показано на рисунке \ref{img:7.jpg}.

\img{0.3\textwidth}{7.jpg}{Преобразование AddRoundKey}

\subsubsection*{Процедура ExpandKey}
В алгоритме AES генерируются раундные ключи на основе ключа шифрования с помощью процедуры ExpandKey. Процедура ExpandKey создает $N_b \cdot (N_r + 1)$ слов: алгоритму требуется начальный ключ размером $N_b$, плюс каждый из $N_r$ раундов требует ключ из $N_b$ слов.

\img{0.3\textwidth}{8.png}{Раундовый ключ}

Для слов на позициях кратных 4-м ($w_4, w_8, ...$) используется следующий алгоритм:

\img{0.3\textwidth}{9.png}{Алгоритм для слов кратных 4-м}

Для остальных используется следующий алгоритм:

\img{0.3\textwidth}{10.png}{Алгоритм для остальных слов}

Здесь функция SubWord осуществляет замену каждого байта в слове в соответствии с таблицей подстановок.
Функция RotWord осуществляет циклический сдвиг байтов в слове влево.

Функция $Rcon(i)$ формирует слово $[02^{i-1}, 00, 00, 00]$.


\subsection{Расшифрование}

При расшифровании все преобразования производятся в обратном порядке. Используются следующие обратные преобразования вместо соответствующих шифрующих:

\begin{enumerate}
	\item InvSubBytes — подстановка байтов с помощью обратной таблицы подстановок;
	\item InvShiftRows — циклический сдвиг строк в форме на различные величины;
	\item InvMixColumns — смешивание данных внутри каждого столбца формы.
\end{enumerate}

Процедуры ExpandKey и AddRoundKey остаются неизменными. Ключи раунда используются в обратном порядке.
Алгоритм расшифрования представлен на рисунке \ref{img:11.jpg}.

\subsubsection*{Преобразование InvShiftRows}

Данное преобразование обратно преобразованию ShiftRows. Схематично преобразование показано на рисунке \ref{img:12.jpg}.
Первая строка формы остается неизменной. Вторая строка циклически сдвигается вправо на 1 байт. Третья — на 2, четвертая — на 3.

\img{0.4\textwidth}{12.jpg}{Преобразование InvShiftRows}

\subsubsection*{Преобразование InvSubBytes}

Данное преобразование обратно преобразованию SubBytes. Подстановка байтов происходит аналогично с помощью обратной таблицы подстановок, представленной на рисунке \ref{img:13.jpg}.

\img{0.5\textwidth}{13.jpg}{Обратная таблица подстановок}

\subsubsection*{Преобразование InvMixColumns}

Данное преобразование обратно преобразованию MixColumns. InvMixColumns преобразует в форме каждый столбец отдельно по следующией формуле:

\img{0.3\textwidth}{14.jpg}{}

Здесь умножение также производится в поле Галуа GF($2^8$).

\subsection{Режим OFB (Output Feedback)}

В режиме OFB входным блоком служит результат применения AES к предыдущему входному блоку. Первым входным блоком служит Initialization Vector.

\img{0.5\textwidth}{15.png}{Шифрование в режиме OFB}

Шифрование и расшифрование в режиме OFB показаны на рисунке~\ref{img:15.png}
и рисунке~\ref{img:16.png} соответственно

\img{0.5\textwidth}{16.png}{Расшифрование в режиме OFB}

Одновременное шифрование и расшифрование нескольких блоков невозможно, поскольку для применения шифрования к какому-либо блоку нужно зашифровать также и все предыдущие блоки.

\newpage
